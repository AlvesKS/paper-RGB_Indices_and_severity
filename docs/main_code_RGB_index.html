<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Kaique" />


<title>Untitled</title>

<script src="site_libs/header-attrs-2.5/header-attrs.js"></script>
<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/pagedtable-1.1/css/pagedtable.css" rel="stylesheet" />
<script src="site_libs/pagedtable-1.1/js/pagedtable.js"></script>
<link href="site_libs/anchor-sections-1.0/anchor-sections.css" rel="stylesheet" />
<script src="site_libs/anchor-sections-1.0/anchor-sections.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
#rmd-source-code {
  display: none;
}
</style>

<link rel="stylesheet" href="my-style.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}

.tocify-subheader {
  display: inline;
}
.tocify-subheader .tocify-item {
  font-size: 0.95em;
}

</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">RGB-indices and severity</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">
    <span class="fa fa fa fa-home"></span>
     
    About
  </a>
</li>
<li>
  <a href="main_code_RGB_index.html">
    <span class="fa fa fa fa-file-code-o"></span>
     
    Data analysis
  </a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/AlvesKS/paper-RGB_Indices_and_severity">
    <span class="fa fa-github-square"></span>
     
    source
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">

<div class="btn-group pull-right">
<button type="button" class="btn btn-default btn-xs dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu" style="min-width: 50px;">
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Untitled</h1>
<h4 class="author">Kaique</h4>
<h4 class="date">25/10/2020</h4>

</div>


<div id="necessary-packages" class="section level1">
<h1>Necessary packages</h1>
<pre class="r"><code>library(tidyverse)
library(FIELDimageR)
library(raster)
library(readxl)
library(gsheet)
library(foreach)
library(agricolae)
library(reshape2)
library(cowplot)
library(gbm)
library(lime)
library(lme4)
library(DescTools)
library(factoextra)
library(FactoMineR)
library(corrplot)
library(magick)
library(patchwork)
library(forcats)
library(ggdist)</code></pre>
</div>
<div id="example-of-rgb-indices-for-one-image" class="section level1">
<h1>Example of RGB indices for one image</h1>
<p>Load pictures names</p>
<pre class="r"><code>pics&lt;-list.files(&quot;./pics/01-soybean-rust-bg-blue&quot;)
length(pics)</code></pre>
<pre><code>## [1] 203</code></pre>
<pre class="r"><code># write(pics, &quot;pics_names.txt&quot;)</code></pre>
<p>List of RGB-based spectral indices to be calculated in the image</p>
<pre class="r"><code># Vegetation indices
index = c(&quot;BI&quot;,&quot;SCI&quot;,&quot;GLI&quot;,&quot;HI&quot;,&quot;SI&quot;,&quot;VARI&quot;,&quot;HUE&quot;,&quot;BGI&quot;,&quot;NGRDI&quot;)</code></pre>
<p>Load a single image</p>
<pre class="r"><code>#Choose one image to prepare the pipeline
EX.L1&lt;-stack(paste(&quot;./pics/01-soybean-rust-bg-blue/&quot;,pics[110],sep = &quot;&quot;))
EX.L1&lt;-aggregate(EX.L1, fact=7)
EX.L.Shape&lt;-fieldPolygon(mosaic=EX.L1, extent=T, plot =T)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-4-1.png" width="672" /></p>
<pre class="r"><code># plotRGB(EX.L.Shape)</code></pre>
<pre class="r"><code>EX1.Indices&lt;- fieldIndex(mosaic = EX.L1,
                         index = index, 
                         myIndex = c(&quot;Blue&quot;), plot = T)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-5-1.png" width="672" /></p>
<pre class="r"><code>plot(EX1.Indices$Blue)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-6-1.png" width="672" /></p>
<pre class="r"><code>hist(EX1.Indices$Blue)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-6-2.png" width="672" /></p>
<div id="mask" class="section level3">
<h3>mask</h3>
<pre class="r"><code># EX.L2&lt;-fieldMask(mosaic=EX.L1, myIndex = &quot;Red&quot;, cropValue=200, cropAbove=T, plot = T)
# EX.L2&lt;-fieldMask(mosaic=EX.L1, index = &quot;BI&quot;, cropValue=1, cropAbove=F, plot = T)
EX.L2&lt;-fieldMask(mosaic=EX.L1, myIndex = c(&quot;Blue&quot;), cropValue=90, cropAbove=T, plot = T)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;
## [1] &quot;Mask equation myIndex=Blue&quot;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-7-1.png" width="672" /></p>
<pre class="r"><code># plotRGB(EX.L2$newMosaic)
plotRGB(EX.L2$newMosaic)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-7-2.png" width="672" /></p>
<pre class="r"><code>class(EX.L2$mask)</code></pre>
<pre><code>## [1] &quot;RasterStack&quot;
## attr(,&quot;package&quot;)
## [1] &quot;raster&quot;</code></pre>
<pre class="r"><code>rgb_fig = RStoolbox::ggRGB(EX.L2$newMosaic,
                 r = 1,
                 g = 2,
                 b = 3)+
  theme_void()+
  coord_fixed()</code></pre>
<pre><code>## Coordinate system already present. Adding new coordinate system, which will replace the existing one.</code></pre>
<pre class="r"><code>cut = mask(EX.L1, EX.L2$newMosaic)
plot(cut)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-9-1.png" width="672" /></p>
<pre class="r"><code>EX.L4&lt;-fieldIndex(mosaic=cut,
                  index = index)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-9-2.png" width="672" /></p>
<pre class="r"><code>plot(EX.L4$BGI)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-9-3.png" width="672" /></p>
<pre class="r"><code>gli_fig = as.data.frame(EX.L4$NGRDI, xy=TRUE, na.rm =T) %&gt;% 
  ggplot(aes(x, y, fill = NGRDI))+
  geom_tile()+
  # scale_fill_distiller(palette = &quot;Spectral&quot;, direction = 1)+
  scale_fill_gradient2(low = &quot;red&quot;, mid =&quot;green&quot;, high = &quot;green&quot;, midpoint = 0.2)+
  # scale_fill_viridis_c(option = &quot;B&quot;,direction = -1)+
  theme_void()+
  coord_fixed()</code></pre>
<pre class="r"><code>plot_grid(rgb_fig, gli_fig, axis = &quot;b&quot;,
          rel_widths = c(0.9,1),
          labels = c(&quot;RGB&quot;, &quot;NGRDI&quot;),
          scale = 0.90)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-11-1.png" width="672" /></p>
<pre class="r"><code># ggsave(&quot;figs/leaf_gli.png&quot;,dpi = 600, height = 3, width =10 )</code></pre>
<pre class="r"><code>df = as(EX.L4, &quot;SpatialPixelsDataFrame&quot;)
dff = as.data.frame(df) %&gt;% 
  gather(1:(3+length(index)), key = &quot;index&quot;, value = &quot;value&quot; ) %&gt;%
  filter(!is.na(value),
         !is.infinite(value)) %&gt;% 
  group_by(index) %&gt;% 
  summarise(mean = mean(value, na.rm = T),
            std = sd(value),
            Q25 = quantile(value,0.25),
            Q50 = quantile(value,0.50),
            Q75 = quantile(value,0.75)) %&gt;% 
  mutate(leaf = pics[30])</code></pre>
<pre><code>## `summarise()` ungrouping output (override with `.groups` argument)</code></pre>
</div>
</div>
<div id="wheat-leaf-blast" class="section level1">
<h1>Wheat leaf blast</h1>
<pre class="r"><code>pics&lt;-list.files(&quot;./pics/01-Wheat_leaf_blast&quot;)
# length(pics)
#indices
index = c(&quot;BI&quot;,&quot;SCI&quot;,&quot;GLI&quot;,&quot;HI&quot;,&quot;SI&quot;,&quot;VARI&quot;,&quot;HUE&quot;,&quot;BGI&quot;,&quot;NGRDI&quot;)


box = data.frame()

for(i in 1:length(pics)){

EX.L1&lt;-stack(paste(&quot;./pics/01-Wheat_leaf_blast/&quot;,pics[i],sep = &quot;&quot;))
EX.L1&lt;-aggregate(EX.L1, fact=10)
EX.L.Shape&lt;-fieldPolygon(mosaic=EX.L1, extent=T, plot = F)

EX1.Indices&lt;- fieldIndex(mosaic = EX.L1,
                         index = index, 
                         myIndex = c(&quot;Green&quot;), plot = F)

EX.L2&lt;-fieldMask(mosaic=EX.L1,  myIndex = c(&quot;Blue&quot;), cropValue=180, cropAbove=T, plot = F)

cut = mask(EX.L1, EX.L2$newMosaic)
EX.L4&lt;-fieldIndex(mosaic=cut,
                  index =index,
                  plot =F)


df = as(EX.L4, &quot;SpatialPixelsDataFrame&quot;)
dff = as.data.frame(df) %&gt;% 
  mutate(gray = 0.299*Red+0.587*Green+0.114*Blue) %&gt;% 
  gather(c(1:(3+length(index)),15), key = &quot;index&quot;, value = &quot;value&quot; ) %&gt;%
  filter(!is.na(value),
         !is.infinite(value)) %&gt;% 
  group_by(index) %&gt;% 
  dplyr::summarise(mean = mean(value, na.rm = T),
            std = sd(value),
            Q25 = quantile(value,0.25),
            Q50 = quantile(value,0.50),
            Q75 = quantile(value,0.75)) %&gt;% 
  mutate(leaf = pics[i])


box = box %&gt;% 
  bind_rows(dff)}
length(unique(box$leaf))
write.table(box,&quot;data/indexes_WLB.txt&quot;)</code></pre>
<pre class="r"><code>box = read.table(&quot;data/indexes_WLB.txt&quot;)</code></pre>
</div>
<div id="load-severity-data" class="section level1">
<h1>Load severity data</h1>
<pre class="r"><code># sev_data = gsheet2tbl(&quot;https://docs.google.com/spreadsheets/d/106sg_O8DeALZpWnxERQNgk8UKgsFbhobWwrl4JXOzbo/edit#gid=0&quot;)


sev = gsheet2tbl(&quot;https://docs.google.com/spreadsheets/d/106sg_O8DeALZpWnxERQNgk8UKgsFbhobWwrl4JXOzbo/edit#gid=0&quot;)
# sev


blast_data = gsheet2tbl(&quot;https://docs.google.com/spreadsheets/d/1KnJ9N8jqKPMjCt8jCLv7OqYL9hLyYeK8wkGEBmlGSVI/edit?usp=sharing&quot;) %&gt;% 
  dplyr::select(code, city, region, position_wheat, host,species)
# blast_data

sev_data = full_join(sev, blast_data, by = &quot;code&quot;) %&gt;% 
  mutate(n = seq(1:1123)) %&gt;% 
  filter(n&lt;201) %&gt;% 
  dplyr::select(-n) %&gt;% 
  
  dplyr::select(pic_name, sev)
# sev_data


length(unique(sev$pic_name))</code></pre>
<pre><code>## [1] 200</code></pre>
<pre class="r"><code>all_data = box %&gt;%
  separate(leaf, into = c(&quot;pic_name&quot;, &quot;jpg&quot;), sep = &quot;.jpg&quot;) %&gt;%
  # separate(pic_name, into = c(&quot;hh&quot;, &quot;isolate&quot;,&quot;repp&quot;), sep = &quot;_&quot;, remove = F) %&gt;%
  dplyr::select(-jpg) %&gt;% 
  full_join(sev_data) %&gt;% 
  # filter(sev&gt;0) %&gt;% 
  mutate(sev = case_when(sev==0 ~0.01,
                         sev &gt;0 ~sev)) %&gt;% 
  filter(!is.na(index)) %&gt;% 
  mutate(sev = sev)</code></pre>
<pre><code>## Joining, by = &quot;pic_name&quot;</code></pre>
<pre class="r"><code>length(unique(all_data$pic_name))</code></pre>
<pre><code>## [1] 200</code></pre>
<pre class="r"><code># length(unique(box$leaf))</code></pre>
<pre class="r"><code>summary(sev$sev)</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##  0.0000  0.6375 49.6250 44.0737 76.0050 99.9300</code></pre>
<div id="images" class="section level3">
<h3>Images</h3>
<pre class="r"><code>hist_sev_WLB =  sev %&gt;% 
  ggplot(aes(sev))+
  geom_histogram(color = &quot;white&quot;, fill = &quot;black&quot;, bins = 20)+
  theme_minimal_hgrid(font_size = 10)+
  labs(x = &quot;Severity (%)&quot;,
       y = &quot;Frequency&quot;)+
  scale_x_continuous(limits = c(-5,105), breaks = seq(0,100,25))+
  # theme_void()+
  # coord_fixed()+
  theme(panel.background = element_rect(color = &quot;black&quot;),
        axis.title.y = element_text(size=8))
hist_sev_WLB</code></pre>
<pre><code>## Warning: Removed 2 rows containing missing values (geom_bar).</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-18-1.png" width="672" /></p>
<pre class="r"><code>EX.L1&lt;-stack(paste(&quot;./pics/01-Wheat_leaf_blast/&quot;,&quot;G_758_R2.jpg&quot;,sep = &quot;&quot;))
EX.L1&lt;-aggregate(EX.L1, fact=10)
EX.L.Shape&lt;-fieldPolygon(mosaic=EX.L1, extent=T, plot = F)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;</code></pre>
<pre class="r"><code>EX1.Indices&lt;- fieldIndex(mosaic = EX.L1,
                         index = index, 
                         myIndex = c(&quot;Green&quot;), plot = F)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;</code></pre>
<pre class="r"><code>EX.L2&lt;-fieldMask(mosaic=EX.L1,  myIndex = c(&quot;Blue&quot;), cropValue=180, cropAbove=T, plot = F)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;
## [1] &quot;Mask equation myIndex=Blue&quot;</code></pre>
<pre class="r"><code>cut = mask(EX.L1, EX.L2$newMosaic)
EX.L4&lt;-fieldIndex(mosaic=cut,
                  index =index,
                  plot =F)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;</code></pre>
<pre class="r"><code># plot(EX.L4$NGRDI)</code></pre>
<pre class="r"><code>rgb_fig_wlb = RStoolbox::ggRGB(EX.L2$newMosaic,
                 r = 1,
                 g = 2,
                 b = 3)+
  theme_map()+
  coord_fixed()+
  theme(panel.background = element_rect(color = &quot;white&quot;))</code></pre>
<pre><code>## Coordinate system already present. Adding new coordinate system, which will replace the existing one.</code></pre>
<pre class="r"><code>gli_fig_wlb = as.data.frame(EX.L4$VARI, xy=TRUE, na.rm =T) %&gt;% 
  ggplot(aes(x, y, fill = VARI))+
  geom_tile()+
  scale_fill_viridis_c(option = &quot;B&quot;,direction = -1)+
  theme_map()+
  coord_fixed()+
  theme(panel.background = element_rect(color = &quot;white&quot;),
        legend.title = element_text(size = 8),
        legend.text = element_text(size = 8))</code></pre>
<pre class="r"><code># plot_grid(rgb_fig, gli_fig, axis = &quot;b&quot;,
#           rel_widths = c(0.9,1),
#           labels = c(&quot;RGB&quot;, &quot;NGRDI&quot;),
#           scale = 0.90)

rgb_fig_wlb + gli_fig_wlb + hist_sev_WLB</code></pre>
<pre><code>## Warning: Removed 2 rows containing missing values (geom_bar).</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-21-1.png" width="672" /></p>
<pre class="r"><code># ggsave(&quot;figs/leaf_gli_wlb.png&quot;,dpi = 600, height = 4, width =12)</code></pre>
</div>
<div id="relationship-sev-indices" class="section level3">
<h3>Relationship sev indices</h3>
<pre class="r"><code>rgb_gg = all_data %&gt;% 
  filter(index %in% c(&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;)) %&gt;% 
    ggplot(aes(mean, sev, color = index)) + 
  # geom_text()+
  geom_point(color = &quot;gray&quot;, size  =3)+
  geom_smooth(se = F, size = 2)+
  facet_wrap(~index, scales = &quot;free_x&quot;, nrow =1)+
  scale_color_manual(values = c(&quot;steelblue&quot;,&quot;darkgreen&quot;, &quot;darkred&quot;))+
  theme_minimal_hgrid()+
  labs(x = &quot;Mean value in the image&quot;,
       y = &quot;Disease severity (%)&quot;)+
  theme(panel.border = element_rect(color = &quot;gray&quot;))+
  theme(legend.position = &quot;none&quot;)
rgb_gg</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-22-1.png" width="672" /></p>
<pre class="r"><code>index_gg = all_data %&gt;% 
  filter(!index %in% c(&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;)) %&gt;% 
    ggplot(aes(mean, sev)) + 
  # geom_text()+
  geom_point(color = &quot;gray&quot;, size  =3)+
  geom_smooth(color = &quot;black&quot;, se = F, size = 2)+
  facet_wrap(~index, scales = &quot;free_x&quot;, nrow =2)+
  theme_minimal_hgrid()+
  labs(x = &quot;Mean index value in the image&quot;,
       y = &quot;Disease severity (%)&quot;)+
  theme(panel.border = element_rect(color = &quot;gray&quot;))
index_gg</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-23-1.png" width="672" /></p>
<pre class="r"><code>plot_grid(
  plot_grid(NULL,rgb_gg,NULL, rel_widths =c(0.18,1,0.2), nrow = 1),
          index_gg,
          nrow = 2,
          rel_heights = c(0.5,1))</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;
## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-24-1.png" width="672" /></p>
<pre class="r"><code>ggsave(&quot;figs/index_sev_WLB.png&quot;, dpi = 500, height = 8, width = 10)</code></pre>
<pre class="r"><code>cor_wlb = all_data %&gt;% 
  group_by(index) %&gt;% 
  dplyr::summarise(cor = round(  cor.test(mean,sev, method = &quot;spearman&quot;)$estimate,3),
                   P_value = cor.test(mean,sev, method = &quot;spearman&quot;)$p.value) %&gt;% 
  arrange(-cor)</code></pre>
<pre><code>## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties</code></pre>
<pre><code>## `summarise()` ungrouping output (override with `.groups` argument)</code></pre>
<pre class="r"><code>cor_wlb</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["index"],"name":[1],"type":["chr"],"align":["left"]},{"label":["cor"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["P_value"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"SCI","2":"0.867","3":"1.135116e-61"},{"1":"HI","2":"0.823","3":"1.704811e-50"},{"1":"Blue","2":"0.822","3":"2.697964e-50"},{"1":"HUE","2":"0.752","3":"9.442985e-38"},{"1":"Red","2":"0.666","3":"5.109759e-27"},{"1":"BI","2":"0.643","3":"1.121893e-24"},{"1":"gray","2":"0.590","3":"4.157148e-20"},{"1":"BGI","2":"0.475","3":"1.217604e-12"},{"1":"Green","2":"0.436","3":"1.069223e-10"},{"1":"SI","2":"0.382","3":"2.333742e-08"},{"1":"NGRDI","2":"-0.867","3":"1.135116e-61"},{"1":"VARI","2":"-0.870","3":"1.058165e-62"},{"1":"GLI","2":"-0.886","3":"4.527714e-68"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
</div>
<div id="spread" class="section level3">
<h3>Spread</h3>
<pre class="r"><code>all_data_spread_wlb = all_data %&gt;% 
  # mutate(nn=1:length(all_data$pic_name)) %&gt;% 
  pivot_wider(id_col = c(pic_name,sev),
              names_from = index, 
              values_from =  mean)   
head(all_data_spread_wlb)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["pic_name"],"name":[1],"type":["chr"],"align":["left"]},{"label":["sev"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["BGI"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["BI"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["Blue"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["GLI"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["gray"],"name":[7],"type":["dbl"],"align":["right"]},{"label":["Green"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["HI"],"name":[9],"type":["dbl"],"align":["right"]},{"label":["HUE"],"name":[10],"type":["dbl"],"align":["right"]},{"label":["NGRDI"],"name":[11],"type":["dbl"],"align":["right"]},{"label":["Red"],"name":[12],"type":["dbl"],"align":["right"]},{"label":["SCI"],"name":[13],"type":["dbl"],"align":["right"]},{"label":["SI"],"name":[14],"type":["dbl"],"align":["right"]},{"label":["VARI"],"name":[15],"type":["dbl"],"align":["right"]}],"data":[{"1":"G_108_R1","2":"0.20","3":"0.5353055","4":"107.27243","5":"71.72010","6":"0.1933751","7":"117.7501","8":"130.9462","9":"0.21822025","10":"-1.564933","11":"0.09695804","12":"109.39336","13":"-0.09695804","14":"0.2245992","15":"0.1360881"},{"1":"G_108_R2","2":"0.90","3":"0.6463659","4":"103.24035","5":"79.22453","6":"0.1478204","7":"111.6613","8":"122.1817","9":"0.04594559","10":"-1.502459","11":"0.08723410","12":"103.37453","13":"-0.08723410","14":"0.1319861","15":"0.1347354"},{"1":"G_108_R3","2":"0.28","3":"0.6777565","4":"99.33399","5":"79.35054","6":"0.1370868","7":"106.8201","8":"116.4214","9":"-0.09201103","10":"-1.550948","11":"0.08584901","12":"98.44382","13":"-0.08584901","14":"0.1101819","15":"0.1351493"},{"1":"G_108_R4","2":"0.14","3":"0.6489964","4":"103.63470","5":"79.83507","6":"0.1478598","7":"112.1051","8":"122.8038","9":"-0.04995640","10":"-1.562913","11":"0.08848845","12":"103.40509","13":"-0.08848845","14":"0.1290937","15":"0.1365299"},{"1":"G_110_R1","2":"0.19","3":"0.6512916","4":"102.44060","5":"79.28427","6":"0.1481314","7":"110.7991","8":"121.5047","9":"0.07295235","10":"-1.562977","11":"0.09026344","12":"101.79740","13":"-0.09026344","14":"0.1257136","15":"0.1396284"},{"1":"G_110_R2","2":"0.21","3":"0.6375932","4":"104.02830","5":"79.05746","6":"0.1505972","7":"112.7063","8":"123.5010","9":"0.06658159","10":"-1.562526","11":"0.08669032","12":"104.34316","13":"-0.08669032","14":"0.1396295","15":"0.1325084"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
</div>
<div id="gbm" class="section level2">
<h2>GBM</h2>
<pre class="r"><code>train=sample(x = 1:length(all_data_spread_wlb$sev), 
             size = round(0.75*length(all_data_spread_wlb$sev),1))
# length(train)
gbm.fit = gbm(sev ~BGI+BI+GLI+HI+HUE+NGRDI+VARI+gray+ Red+Green+Blue  + SI + SCI,
             data = all_data_spread_wlb[train,],
             distribution = &quot;gaussian&quot;,
              n.trees = 1000,
             interaction.depth = 3,
             shrinkage = 0.1,
             cv.folds = 5,
             n.cores = NULL, # will use all cores by default
             verbose = FALSE)
print(gbm.fit)</code></pre>
<pre><code>## gbm(formula = sev ~ BGI + BI + GLI + HI + HUE + NGRDI + VARI + 
##     gray + Red + Green + Blue + SI + SCI, distribution = &quot;gaussian&quot;, 
##     data = all_data_spread_wlb[train, ], n.trees = 1000, interaction.depth = 3, 
##     shrinkage = 0.1, cv.folds = 5, verbose = FALSE, n.cores = NULL)
## A gradient boosted model with gaussian loss function.
## 1000 iterations were performed.
## The best cross-validation iteration was 55.
## There were 13 predictors of which 13 had non-zero influence.</code></pre>
<pre class="r"><code>sqrt(min(gbm.fit$cv.error))</code></pre>
<pre><code>## [1] 9.365364</code></pre>
<pre class="r"><code>gbm.perf(gbm.fit, method = &quot;cv&quot;)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-28-1.png" width="672" /></p>
<pre><code>## [1] 55</code></pre>
<pre class="r"><code># find index for n trees with minimum CV error</code></pre>
<pre class="r"><code>min_MSE &lt;- which.min(gbm.fit$cv.error)
sqrt(gbm.fit$cv.error[min_MSE])</code></pre>
<pre><code>## [1] 9.365364</code></pre>
<pre class="r"><code># best.iter &lt;- gbm.perf(model1, method = &quot;test&quot;)
# print(best.iter)

pred = predict(gbm.fit, newdata = all_data_spread_wlb[-train,-1], ntrees = 5000 )</code></pre>
<pre><code>## Using 55 trees...</code></pre>
<pre class="r"><code>sqrt(mean(((pred)-all_data_spread_wlb$sev[-train])^2))</code></pre>
<pre><code>## [1] 10.20916</code></pre>
<pre class="r"><code>CCC((pred), all_data_spread_wlb$sev[-train])$rho.c$est</code></pre>
<pre><code>## [1] 0.9478986</code></pre>
<pre class="r"><code>plot((pred), (pred)-all_data_spread_wlb$sev[-train])
abline(a=0,b=0)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-30-1.png" width="672" /></p>
<div id="testing-various-hyperparameters" class="section level3">
<h3>Testing various hyperparameters</h3>
<p>Create hyperparameter grid</p>
<pre class="r"><code>hyper_grid &lt;- expand.grid(
  shrinkage = c(.001, .01, .1, .3),
  interaction.depth = c(1, 3, 5, 6),
  n.minobsinnode = c(5, 10, 15),
  bag.fraction = c(.5,.65, .8, 1), 
  optimal_trees = 0,               # a place to dump results
  min_RMSE = 0,
  CCC =0 # a place to dump results
)
# total number of combinations
nrow(hyper_grid)</code></pre>
<pre><code>## [1] 192</code></pre>
<pre class="r"><code># randomize data
set.seed(1234)
train=sample(x = 1:length(all_data_spread_wlb$sev), 
             size = round(0.80*length(all_data_spread_wlb$sev),1))

# grid search 
for(i in 1:nrow(hyper_grid)) {

# reproducibility
set.seed(123)


 # train model
gbm.tune &lt;- gbm(
  formula = (sev) ~BGI+BI+GLI+HI+HUE+NGRDI+VARI+gray +Red+Green+Blue + SI + SCI, #&lt;&lt;&lt;&lt;&lt;
  data = all_data_spread_wlb[train,],
  distribution = &quot;gaussian&quot;,
  n.trees = 5000,
  interaction.depth = hyper_grid$interaction.depth[i],
  shrinkage = hyper_grid$shrinkage[i],
  n.minobsinnode = hyper_grid$n.minobsinnode[i],
  bag.fraction = hyper_grid$bag.fraction[i],
  train.fraction = .75,
  n.cores = NULL, # will use all cores by default
  verbose = FALSE)

pred = predict(gbm.tune, newdata = all_data_spread_wlb[-train,-1], ntrees = 5000 )
 # add min training error and trees to grid
  hyper_grid$optimal_trees[i] &lt;- which.min(gbm.tune$valid.error)
  hyper_grid$min_RMSE[i] &lt;- sqrt(min(gbm.tune$valid.error))
  hyper_grid$CCC[i] = CCC(pred, all_data_spread_wlb$sev[-train])$rho.c$est#&lt;&lt;&lt;&lt;&lt;
  
}

best_par = hyper_grid %&gt;% 
  dplyr::arrange(-CCC) %&gt;%
  head(10)
best_par</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["shrinkage"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["interaction.depth"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["n.minobsinnode"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["bag.fraction"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["optimal_trees"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["min_RMSE"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["CCC"],"name":[7],"type":["dbl"],"align":["right"]}],"data":[{"1":"0.01","2":"5","3":"5","4":"0.80","5":"4988","6":"10.83493","7":"0.9731869","_rn_":"1"},{"1":"0.10","2":"5","3":"5","4":"0.50","5":"36","6":"10.88780","7":"0.9730593","_rn_":"2"},{"1":"0.30","2":"5","3":"5","4":"0.50","5":"19","6":"11.04311","7":"0.9729481","_rn_":"3"},{"1":"0.01","2":"6","3":"5","4":"0.80","5":"5000","6":"10.70554","7":"0.9722267","_rn_":"4"},{"1":"0.30","2":"3","3":"10","4":"0.80","5":"11","6":"10.84073","7":"0.9716871","_rn_":"5"},{"1":"0.01","2":"6","3":"5","4":"0.50","5":"331","6":"10.34085","7":"0.9716634","_rn_":"6"},{"1":"0.01","2":"5","3":"5","4":"0.65","5":"5000","6":"10.62293","7":"0.9713993","_rn_":"7"},{"1":"0.01","2":"6","3":"5","4":"0.65","5":"4970","6":"10.52067","7":"0.9713708","_rn_":"8"},{"1":"0.10","2":"5","3":"10","4":"0.80","5":"4985","6":"10.54148","7":"0.9711163","_rn_":"9"},{"1":"0.30","2":"5","3":"10","4":"1.00","5":"10","6":"11.28268","7":"0.9709846","_rn_":"10"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code># gbm.tune$fit</code></pre>
</div>
<div id="best-model" class="section level3">
<h3>Best model</h3>
<pre class="r"><code># for reproducibility
set.seed(123)

# train GBM model
gbm.fit.final_wlb &lt;- gbm(
  formula = (sev) ~BGI+BI+GLI+HI+HUE+NGRDI+VARI+Red+Green+Blue+gray+SI+SCI,
  data = all_data_spread_wlb[train,],
  distribution = &quot;gaussian&quot;,
  n.trees = best_par$optimal_trees[1],
  interaction.depth = best_par$interaction.depth[1],
  shrinkage = best_par$shrinkage[1],
  n.minobsinnode = best_par$n.minobsinnode[1],
  bag.fraction = best_par$bag.fraction[1], 
  train.fraction =0.75,
  n.cores = NULL, # will use all cores by default
  verbose = FALSE
  )</code></pre>
</div>
<div id="relative-influence" class="section level3">
<h3>Relative influence</h3>
<pre class="r"><code>par(mar = c(5, 8, 1, 1))
summary_gbm_wlb = summary(
  gbm.fit.final_wlb, 
  cBars = 15,
  method = relative.influence, # also can use permutation.test.gbm
  las = 2
  )</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-34-1.png" width="672" /></p>
<pre class="r"><code>rel_wlb = summary_gbm_wlb %&gt;% 
  rownames_to_column(&quot;index&quot;) %&gt;% 
  ggplot(aes(rel.inf, reorder(var, rel.inf)))+
  geom_col(aes(fill =rel.inf&gt;1, color =rel.inf&gt;1 ), width = 0.85)+
  theme_minimal_vgrid()+
  labs(x = &quot;Relative influence (%)&quot;,
       y = &quot;Model predictors&quot;,
       fill = &quot;RI &gt; 1%&quot;,
       color = &quot;RI &gt; 1%&quot;)
rel_wlb</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-34-2.png" width="672" /></p>
<pre class="r"><code># ggsave(&quot;figs/var_influence.png&quot;,dpi = 600, height = 4, width = 6)</code></pre>
<p>Partial dependence plots</p>
<pre class="r"><code>gbm.fit.final_wlb %&gt;%
  pdp::partial(pred.var = &quot;NGRDI&quot;, n.trees = gbm.fit.final_wlb$n.trees, grid.resolution = 100) %&gt;%
  ggplot(aes( NGRDI,(yhat)))+
  geom_line()</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-35-1.png" width="672" /></p>
<p>LIME</p>
<pre class="r"><code>model_type.gbm &lt;- function(x, ...) {
  return(&quot;regression&quot;)
}

predict_model.gbm &lt;- function(x, newdata, ...) {
  pred &lt;- predict(x, newdata, n.trees = x$n.trees)
  return(as.data.frame(pred))
}</code></pre>
<pre class="r"><code># get a few observations to perform local interpretation on
local_obs &lt;- (all_data_spread_wlb[-train,])[1:4, ]

# apply LIME
explainer &lt;- lime(all_data_spread_wlb[train,], gbm.fit.final_wlb)
explanation &lt;- lime::explain(local_obs, explainer, n_features = 7, n.trees =1)
plot_features(explanation)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-37-1.png" width="672" /></p>
</div>
</div>
<div id="prediction" class="section level2">
<h2>Prediction</h2>
<pre class="r"><code># predict values for test data
pred &lt;- predict(gbm.fit.final_wlb,
                n.trees = gbm.fit.final_wlb$n.trees,
                all_data_spread_wlb[-train,])

# results
caret::RMSE((pred), all_data_spread_wlb[-train,]$sev)</code></pre>
<pre><code>## [1] 7.852842</code></pre>
<pre class="r"><code>CCC((pred), all_data_spread_wlb$sev[-train])$rho.c$est</code></pre>
<pre><code>## [1] 0.9733397</code></pre>
<pre class="r"><code>cor((pred), all_data_spread_wlb$sev[-train])^2</code></pre>
<pre><code>## [1] 0.9491022</code></pre>
<pre class="r"><code>accuracy_wlb =data.frame(predi=pred, actual = all_data_spread_wlb$sev[-train]) %&gt;% 
  summarise(RMSE = caret::RMSE(pred, actual),
            r = cor(pred, actual),
            s.shift = CCC(pred, actual)$s.shift,
            l.shift = CCC(pred, actual)$l.shift,
            C.b = CCC(pred, actual)$C.b,
            CCC = CCC(pred, actual)$rho.c$est,
            CIS = paste(
  round(CCC(pred, all_data_spread_wlb$sev[-train])$rho.c[2],2),&quot;,&quot;,&quot; &quot;,
  round(CCC(pred, all_data_spread_wlb$sev[-train])$rho.c[3],2),sep = &quot;&quot;
  ))
accuracy_wlb</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["RMSE"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["r"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["s.shift"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["l.shift"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["C.b"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["CCC"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["CIS"],"name":[7],"type":["chr"],"align":["left"]}],"data":[{"1":"7.852842","2":"0.9742187","3":"1.030742","4":"0.02982214","5":"0.9990977","6":"0.9733397","7":"0.95, 0.99"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<div id="plot" class="section level4">
<h4>plot</h4>
<pre class="r"><code># plot_grid(
conc_wlb = data.frame(predict = pred, actual =all_data_spread_wlb$sev[-train]) %&gt;% 
ggplot(aes(actual,predict))+
  geom_point(size =2, color = &quot;gray&quot;)+
  geom_abline(intercept = 0, slope= 1, size = .81, color = &quot;black&quot;, linetype = &quot;dashed&quot;)+
  geom_smooth(method = &quot;lm&quot;, 
              color = &quot;red&quot;,
              size =.81, se =F,
              fullrange=T)+
  theme_minimal_grid()+
  labs(x = &quot;Predicted Severity (%)&quot;,
       y = &quot;Actual Severity (%)&quot;)+
  coord_equal(xlim = c(0,100),
              ylim = c(0,100))+
  xlim(0,100)

ggsave(&quot;figs/concordance.png&quot;, dpi = 600, height = 3.5, width = 4)</code></pre>
<pre><code>## `geom_smooth()` using formula &#39;y ~ x&#39;</code></pre>
</div>
</div>
</div>
<div id="soybean-rust" class="section level1">
<h1>Soybean Rust</h1>
<pre class="r"><code>pics&lt;-list.files(&quot;./pics/01-soybean-rust-bg-blue&quot;)
# length(pics)
#indices
index = c(&quot;BI&quot;,&quot;SCI&quot;,&quot;GLI&quot;,&quot;HI&quot;,&quot;SI&quot;,&quot;VARI&quot;,&quot;HUE&quot;,&quot;BGI&quot;,&quot;NGRDI&quot;)


box = data.frame()

for(i in 1:length(pics)){

EX.L1&lt;-stack(paste(&quot;./pics/01-soybean-rust-bg-blue/&quot;,pics[i],sep = &quot;&quot;))
EX.L1&lt;-aggregate(EX.L1, fact=7)
EX.L.Shape&lt;-fieldPolygon(mosaic=EX.L1, extent=T, plot = F)

EX1.Indices&lt;- fieldIndex(mosaic = EX.L1,
                         index = index, 
                         myIndex = c(&quot;Green&quot;), plot = F)

EX.L2&lt;-fieldMask(mosaic=EX.L1,  myIndex = c(&quot;Blue&quot;), cropValue=100, cropAbove=T, plot = F)

cut = mask(EX.L1, EX.L2$newMosaic)
EX.L4&lt;-fieldIndex(mosaic=cut,
                  index =index,
                  plot =F)


df = as(EX.L4, &quot;SpatialPixelsDataFrame&quot;)
dff = as.data.frame(df) %&gt;% 
  mutate(gray = 0.299*Red+0.587*Green+0.114*Blue) %&gt;% 
  gather(c(1:(3+length(index)),15), key = &quot;index&quot;, value = &quot;value&quot; ) %&gt;%
  filter(!is.na(value),
         !is.infinite(value)) %&gt;% 
  group_by(index) %&gt;% 
  dplyr::summarise(mean = mean(value, na.rm = T),
            std = sd(value),
            Q25 = quantile(value,0.25),
            Q50 = quantile(value,0.50),
            Q75 = quantile(value,0.75)) %&gt;% 
  mutate(leaf = pics[i])


box = box %&gt;% 
  bind_rows(dff)}
length(unique(box$leaf))
write.table(box,&quot;data/indexes_SBR.txt&quot;)</code></pre>
<pre class="r"><code>box = read.table(&quot;data/indexes_SBR.txt&quot;)</code></pre>
<div id="load-sbr-severity" class="section level3">
<h3>load SBR severity</h3>
<pre class="r"><code>sbr_load = gsheet2tbl(&quot;https://docs.google.com/spreadsheets/d/13TVKBQgfCAr7UGie_LHTF_kwPHC1XI_AkLKoRYtjPrQ/edit?usp=sharing&quot;)</code></pre>
<pre class="r"><code>all_data_sbr = box %&gt;% 
  separate(leaf, into=c(&quot;file&quot;,&quot;format&quot;), sep =&quot;_&quot;) %&gt;% 
  dplyr::select(-format) %&gt;% 
  full_join(sbr_load) %&gt;% 
  na.omit()</code></pre>
<pre><code>## Joining, by = &quot;file&quot;</code></pre>
<pre class="r"><code>length(unique(all_data_sbr$file))</code></pre>
<pre><code>## [1] 203</code></pre>
<pre class="r"><code>head(all_data_sbr)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["index"],"name":[1],"type":["chr"],"align":["left"]},{"label":["mean"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["std"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["Q25"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["Q50"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["Q75"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["file"],"name":[7],"type":["chr"],"align":["left"]},{"label":["sev"],"name":[8],"type":["dbl"],"align":["right"]}],"data":[{"1":"BGI","2":"0.3997101","3":"0.13599078","4":"0.3234259","5":"0.3843265","6":"0.4506906","7":"Ferrugem 1","8":"39.7","_rn_":"1"},{"1":"BI","2":"87.8460326","3":"14.91203193","4":"77.1221560","5":"87.0969043","6":"98.8352819","7":"Ferrugem 1","8":"39.7","_rn_":"2"},{"1":"Blue","2":"41.0937912","3":"11.80079235","4":"33.5510204","5":"40.1326531","6":"46.7959184","7":"Ferrugem 1","8":"39.7","_rn_":"3"},{"1":"GLI","2":"0.1959277","3":"0.06355385","4":"0.1562426","5":"0.1952057","6":"0.2354938","7":"Ferrugem 1","8":"39.7","_rn_":"4"},{"1":"gray","2":"96.1659570","3":"15.23897816","4":"85.5722755","5":"95.7584898","6":"107.3897857","7":"Ferrugem 1","8":"39.7","_rn_":"5"},{"1":"Green","2":"104.4390983","3":"13.30553965","4":"95.8163265","5":"104.3571429","6":"113.8163265","7":"Ferrugem 1","8":"39.7","_rn_":"6"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>summary(all_data_sbr$sev)</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##    0.04    5.52   20.10   25.11   38.07   89.67</code></pre>
</div>
<div id="images-1" class="section level3">
<h3>Images</h3>
<pre class="r"><code>hist_sev_sbr =  all_data_sbr %&gt;%
  pivot_wider(id_col = c(file,sev),
              names_from = index, 
              values_from =  mean) %&gt;%
  ggplot(aes(sev))+
  geom_histogram(color = &quot;white&quot;, fill = &quot;black&quot;, bins = 20)+
  theme_minimal_hgrid(font_size = 10)+
  labs(x = &quot;Severity (%)&quot;,
       y = &quot;Frequency&quot;)+
  scale_x_continuous(limits = c(-5,105), breaks = seq(0,100,25))+
  # theme_void()+
  # coord_fixed()+
  theme(panel.background = element_rect(color = &quot;black&quot;),
        axis.title.y = element_text(size=8))</code></pre>
<pre class="r"><code>EX.L1&lt;-stack(paste(&quot;./pics/01-soybean-rust-bg-blue/&quot;,&quot;Ferrugem 2_Median.jpg&quot;,sep = &quot;&quot;))
EX.L1&lt;-aggregate(EX.L1, fact=7)
EX.L.Shape&lt;-fieldPolygon(mosaic=EX.L1, extent=T, plot = F)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;</code></pre>
<pre class="r"><code>EX1.Indices&lt;- fieldIndex(mosaic = EX.L1,
                         index = index, 
                         myIndex = c(&quot;Green&quot;), plot = F)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;</code></pre>
<pre class="r"><code>EX.L2&lt;-fieldMask(mosaic=EX.L1,  myIndex = c(&quot;Blue&quot;), cropValue=100, cropAbove=T, plot = F)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;
## [1] &quot;Mask equation myIndex=Blue&quot;</code></pre>
<pre class="r"><code>cut = mask(EX.L1, EX.L2$newMosaic)
EX.L4&lt;-fieldIndex(mosaic=cut,
                  index =index,
                  plot =F)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;</code></pre>
<pre class="r"><code># plot(EX.L4$HUE)</code></pre>
<pre class="r"><code>rgb_fig_sbr = RStoolbox::ggRGB(EX.L2$newMosaic,
                 r = 1,
                 g = 2,
                 b = 3)+
  theme_map()+
  coord_fixed()+
  theme(panel.background = element_rect(color = &quot;white&quot;))</code></pre>
<pre><code>## Coordinate system already present. Adding new coordinate system, which will replace the existing one.</code></pre>
<pre class="r"><code>gli_fig_sbr = as.data.frame(EX.L4$HUE, xy=TRUE, na.rm =T) %&gt;% 
  ggplot(aes(x, y, fill = HUE))+
  geom_tile()+
  scale_fill_viridis_c(option = &quot;B&quot;,direction = -1)+
  theme_map()+
  coord_fixed()+
  theme(panel.background = element_rect(color = &quot;white&quot;),
        legend.title = element_text(size = 8),
        legend.text = element_text(size = 8))</code></pre>
<pre class="r"><code>rgb_fig_sbr + gli_fig_sbr + hist_sev_sbr #+</code></pre>
<pre><code>## Warning: Removed 2 rows containing missing values (geom_bar).</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-49-1.png" width="672" /></p>
<pre class="r"><code>  # rgb_fig_wlb + gli_fig_wlb + hist_sev_WLB+
  #  plot_layout(widths = c(1, 1, 1),
  #              heights = c(1,1))

# ggsave(&quot;figs/leaf_gli.png&quot;,dpi = 600, height = 6, width =10)</code></pre>
</div>
<div id="relationship-sev-indices-1" class="section level3">
<h3>Relationship sev indices</h3>
<pre class="r"><code>rgb_gg_sbr = all_data_sbr %&gt;% 
  filter(index %in% c(&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;)) %&gt;% 
    ggplot(aes(mean, sev, color = index)) + 
  # geom_text()+
  geom_point(color = &quot;gray&quot;, size  =3)+
  geom_smooth(se = F, size = 2)+
  facet_wrap(~index, scales = &quot;free_x&quot;, nrow =1)+
  scale_color_manual(values = c(&quot;steelblue&quot;,&quot;darkgreen&quot;, &quot;darkred&quot;))+
  theme_minimal_hgrid()+
  labs(x = &quot;Mean value in the image&quot;,
       y = &quot;Disease severity (%)&quot;)+
  theme(panel.border = element_rect(color = &quot;gray&quot;))+
  theme(legend.position = &quot;none&quot;)
rgb_gg_sbr</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-50-1.png" width="672" /></p>
<pre class="r"><code>index_gg_sbr = all_data_sbr %&gt;% 
  filter(!index %in% c(&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;)) %&gt;% 
    ggplot(aes(mean, sev)) + 
  # geom_text()+
  geom_point(color = &quot;gray&quot;, size  =3)+
  geom_smooth(color = &quot;black&quot;, se = F, size = 2)+
  facet_wrap(~index, scales = &quot;free_x&quot;, nrow =2)+
  theme_minimal_hgrid()+
  labs(x = &quot;Mean index value in the image&quot;,
       y = &quot;Disease severity (%)&quot;)+
  theme(panel.border = element_rect(color = &quot;gray&quot;))
index_gg_sbr</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-51-1.png" width="672" /></p>
<pre class="r"><code>plot_grid(
  plot_grid(NULL,rgb_gg_sbr,NULL, rel_widths =c(0.18,1,0.2), nrow = 1),
          index_gg_sbr,
          nrow = 2,
          rel_heights = c(0.5,1))</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;
## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-52-1.png" width="672" /></p>
<pre class="r"><code>ggsave(&quot;figs/index_sev_SBR.png&quot;, dpi = 500, height = 8, width = 10)</code></pre>
<pre class="r"><code>cor_sbr = all_data_sbr %&gt;% 
  group_by(index) %&gt;% 
  dplyr::summarise(cor = round(  cor.test(mean,sev, method = &quot;spearman&quot;)$estimate,3),
                   P_value = cor.test(mean,sev, method = &quot;spearman&quot;)$p.value) %&gt;% 
  arrange(-cor)</code></pre>
<pre><code>## `summarise()` ungrouping output (override with `.groups` argument)</code></pre>
<pre class="r"><code>cor_sbr</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["index"],"name":[1],"type":["chr"],"align":["left"]},{"label":["cor"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["P_value"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"HUE","2":"0.995","3":"0.000000e+00"},{"1":"SCI","2":"0.946","3":"0.000000e+00"},{"1":"HI","2":"0.906","3":"0.000000e+00"},{"1":"Red","2":"0.848","3":"0.000000e+00"},{"1":"SI","2":"0.823","3":"0.000000e+00"},{"1":"BI","2":"0.745","3":"0.000000e+00"},{"1":"gray","2":"0.710","3":"0.000000e+00"},{"1":"Green","2":"0.582","3":"0.000000e+00"},{"1":"Blue","2":"-0.383","3":"2.262575e-08"},{"1":"GLI","2":"-0.462","3":"3.933944e-12"},{"1":"BGI","2":"-0.617","3":"0.000000e+00"},{"1":"VARI","2":"-0.880","3":"0.000000e+00"},{"1":"NGRDI","2":"-0.946","3":"0.000000e+00"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
</div>
<div id="spread-df" class="section level3">
<h3>Spread df</h3>
<pre class="r"><code>all_data_spread_sbr = all_data_sbr %&gt;% 
  pivot_wider(id_col = c(file,sev),
              names_from = index, 
              values_from =  mean)   

head(all_data_spread_sbr)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["file"],"name":[1],"type":["chr"],"align":["left"]},{"label":["sev"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["BGI"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["BI"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["Blue"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["GLI"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["gray"],"name":[7],"type":["dbl"],"align":["right"]},{"label":["Green"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["HI"],"name":[9],"type":["dbl"],"align":["right"]},{"label":["HUE"],"name":[10],"type":["dbl"],"align":["right"]},{"label":["NGRDI"],"name":[11],"type":["dbl"],"align":["right"]},{"label":["Red"],"name":[12],"type":["dbl"],"align":["right"]},{"label":["SCI"],"name":[13],"type":["dbl"],"align":["right"]},{"label":["SI"],"name":[14],"type":["dbl"],"align":["right"]},{"label":["VARI"],"name":[15],"type":["dbl"],"align":["right"]}],"data":[{"1":"Ferrugem 1","2":"39.70","3":"0.3997101","4":"87.84603","5":"41.09379","6":"0.1959277","7":"96.16596","8":"104.43910","9":"0.6625815","10":"-0.2631971","11":"0.03199372","12":"100.92145","13":"-0.03199372","14":"0.4087857","15":"0.06058750"},{"1":"Ferrugem 10","2":"18.65","3":"0.3792543","4":"84.67287","5":"39.67250","6":"0.2309887","7":"93.99306","8":"105.07461","9":"0.5650574","10":"-0.9527573","11":"0.07109084","12":"92.94849","13":"-0.07109084","14":"0.3981594","15":"0.08849056"},{"1":"Ferrugem 100","2":"26.42","3":"0.5029008","4":"90.31850","5":"53.11091","6":"0.1645689","7":"98.71033","8":"106.72750","9":"0.7463635","10":"-0.6678290","11":"0.03718950","12":"100.35668","13":"-0.03718950","14":"0.2997770","15":"0.04482838"},{"1":"Ferrugem 101","2":"2.33","3":"0.5544438","4":"81.18729","5":"55.13729","6":"0.1862898","7":"89.32461","8":"99.69538","9":"0.2040970","10":"-1.5024190","11":"0.10080088","12":"81.99923","13":"-0.10080088","14":"0.1934977","15":"0.14616311"},{"1":"Ferrugem 102","2":"84.66","3":"0.4337219","4":"113.19410","5":"51.81495","6":"0.1155914","7":"120.83483","8":"123.23074","9":"1.6212932","10":"1.2253308","11":"-0.07125433","12":"142.44643","13":"0.07125433","14":"0.4616619","15":"-0.07777495"},{"1":"Ferrugem 103","2":"4.08","3":"0.5046375","4":"89.30674","5":"55.46616","6":"0.1960571","7":"98.73415","8":"110.07443","9":"0.3192319","10":"-1.4277268","11":"0.08764355","12":"92.96763","13":"-0.08764355","14":"0.2507094","15":"0.12807067"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
</div>
<div id="gbm-1" class="section level2">
<h2>GBM</h2>
<pre class="r"><code>train=sample(x = 1:length(all_data_spread_sbr$sev), 
             size = round(0.75*length(all_data_spread_sbr$sev),1))
# length(train)
gbm.fit = gbm(sev ~BGI+BI+GLI+HI+HUE+NGRDI+VARI+gray+ Red+Green+Blue  + SI + SCI,
             data = all_data_spread_sbr[train,],
             distribution = &quot;gaussian&quot;,
              n.trees = 1000,
             interaction.depth = 3,
             shrinkage = 0.1,
             cv.folds = 5,
             n.cores = NULL, # will use all cores by default
             verbose = FALSE)
print(gbm.fit)</code></pre>
<pre><code>## gbm(formula = sev ~ BGI + BI + GLI + HI + HUE + NGRDI + VARI + 
##     gray + Red + Green + Blue + SI + SCI, distribution = &quot;gaussian&quot;, 
##     data = all_data_spread_sbr[train, ], n.trees = 1000, interaction.depth = 3, 
##     shrinkage = 0.1, cv.folds = 5, verbose = FALSE, n.cores = NULL)
## A gradient boosted model with gaussian loss function.
## 1000 iterations were performed.
## The best cross-validation iteration was 942.
## There were 13 predictors of which 13 had non-zero influence.</code></pre>
<pre class="r"><code>sqrt(min(gbm.fit$cv.error))</code></pre>
<pre><code>## [1] 4.02846</code></pre>
<pre class="r"><code>gbm.perf(gbm.fit, method = &quot;cv&quot;)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-56-1.png" width="672" /></p>
<pre><code>## [1] 942</code></pre>
<pre class="r"><code># find index for n trees with minimum CV error</code></pre>
<pre class="r"><code>min_MSE &lt;- which.min(gbm.fit$cv.error)
sqrt(gbm.fit$cv.error[min_MSE])</code></pre>
<pre><code>## [1] 4.02846</code></pre>
<pre class="r"><code># best.iter &lt;- gbm.perf(model1, method = &quot;test&quot;)
# print(best.iter)

pred = predict(gbm.fit, newdata = all_data_spread_sbr[-train,-1], ntrees = 5000 )</code></pre>
<pre><code>## Using 942 trees...</code></pre>
<pre class="r"><code>sqrt(mean(((pred)-all_data_spread_sbr$sev[-train])^2))</code></pre>
<pre><code>## [1] 3.398297</code></pre>
<pre class="r"><code>CCC((pred), all_data_spread_sbr$sev[-train])$rho.c$est</code></pre>
<pre><code>## [1] 0.9897837</code></pre>
<pre class="r"><code>plot((pred), (pred)-all_data_spread_sbr$sev[-train])
abline(a=0,b=0)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-58-1.png" width="672" /></p>
<div id="testing-various-hyperparameters-1" class="section level3">
<h3>Testing various hyperparameters</h3>
<p>Create hyperparameter grid</p>
<pre class="r"><code>hyper_grid &lt;- expand.grid(
  shrinkage = c(.001, .01, .1, .3),
  interaction.depth = c(1, 3, 5, 6),
  n.minobsinnode = c(5, 10, 15),
  bag.fraction = c(.5,.65, .8, 1), 
  optimal_trees = 0,               # a place to dump results
  min_RMSE = 0,
  CCC =0 # a place to dump results
)
# total number of combinations
nrow(hyper_grid)</code></pre>
<pre><code>## [1] 192</code></pre>
<pre class="r"><code># randomize data
set.seed(123)
train=sample(x = 1:length(all_data_spread_sbr$sev), 
             size = round(0.8*length(all_data_spread_sbr$sev),1))

# grid search 
for(i in 1:nrow(hyper_grid)) {

# reproducibility
set.seed(123)


 # train model
gbm.tune &lt;- gbm(
  formula = (sev) ~BGI+BI+GLI+HI+HUE+NGRDI+VARI+gray +Red+Green+Blue + SI + SCI, #&lt;&lt;&lt;&lt;&lt;
  data = all_data_spread_sbr[train,],
  distribution = &quot;gaussian&quot;,
  n.trees = 5000,
  interaction.depth = hyper_grid$interaction.depth[i],
  shrinkage = hyper_grid$shrinkage[i],
  n.minobsinnode = hyper_grid$n.minobsinnode[i],
  bag.fraction = hyper_grid$bag.fraction[i],
  train.fraction = .75,
  n.cores = NULL, # will use all cores by default
  verbose = FALSE)

pred = predict(gbm.tune, newdata = all_data_spread_sbr[-train,-1], ntrees = 5000 )
 # add min training error and trees to grid
  hyper_grid$optimal_trees[i] &lt;- which.min(gbm.tune$valid.error)
  hyper_grid$min_RMSE[i] &lt;- sqrt(min(gbm.tune$valid.error))
  hyper_grid$CCC[i] = CCC(pred, all_data_spread_sbr$sev[-train])$rho.c$est#&lt;&lt;&lt;&lt;&lt;
  
}

best_par = hyper_grid %&gt;% 
  dplyr::arrange(-CCC) %&gt;%
  head(10)
best_par</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["shrinkage"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["interaction.depth"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["n.minobsinnode"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["bag.fraction"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["optimal_trees"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["min_RMSE"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["CCC"],"name":[7],"type":["dbl"],"align":["right"]}],"data":[{"1":"0.010","2":"3","3":"5","4":"0.80","5":"1148","6":"2.270680","7":"0.9958594","_rn_":"1"},{"1":"0.010","2":"5","3":"5","4":"1.00","5":"1109","6":"2.002059","7":"0.9956714","_rn_":"2"},{"1":"0.100","2":"6","3":"5","4":"1.00","5":"97","6":"1.975201","7":"0.9955144","_rn_":"3"},{"1":"0.100","2":"5","3":"5","4":"1.00","5":"93","6":"2.055946","7":"0.9955131","_rn_":"4"},{"1":"0.010","2":"3","3":"5","4":"1.00","5":"4600","6":"2.157053","7":"0.9955040","_rn_":"5"},{"1":"0.010","2":"1","3":"5","4":"0.80","5":"1601","6":"2.266556","7":"0.9954981","_rn_":"6"},{"1":"0.010","2":"1","3":"5","4":"0.65","5":"1650","6":"2.375012","7":"0.9954573","_rn_":"7"},{"1":"0.001","2":"3","3":"5","4":"0.65","5":"4995","6":"2.488595","7":"0.9954234","_rn_":"8"},{"1":"0.010","2":"6","3":"5","4":"0.80","5":"1161","6":"2.073971","7":"0.9953818","_rn_":"9"},{"1":"0.001","2":"3","3":"5","4":"0.80","5":"5000","6":"2.302626","7":"0.9953742","_rn_":"10"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code># gbm.tune$fit</code></pre>
</div>
<div id="best-model-1" class="section level3">
<h3>Best model</h3>
<pre class="r"><code># for reproducibility
set.seed(123)

# train GBM model
gbm.fit.final_sbr &lt;- gbm(
  formula = (sev) ~BGI+BI+GLI+HI+HUE+NGRDI+VARI+Red+Green+Blue+gray+SI+SCI,
  data = all_data_spread_sbr[train,],
  distribution = &quot;gaussian&quot;,
  n.trees = best_par$optimal_trees[1],
  interaction.depth = best_par$interaction.depth[1],
  shrinkage = best_par$shrinkage[1],
  n.minobsinnode = best_par$n.minobsinnode[1],
  bag.fraction = best_par$bag.fraction[1], 
  train.fraction =0.75,
  n.cores = NULL, # will use all cores by default
  verbose = FALSE
  )</code></pre>
</div>
<div id="relative-influence-1" class="section level3">
<h3>Relative influence</h3>
<pre class="r"><code>par(mar = c(5, 8, 1, 1))
summary_gbm_sbr = summary(
  gbm.fit.final_sbr, 
  cBars = 15,
  method = relative.influence, # also can use permutation.test.gbm
  las = 2
  )</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-62-1.png" width="672" /></p>
<pre class="r"><code>rel_sbr = summary_gbm_sbr %&gt;% 
  rownames_to_column(&quot;index&quot;) %&gt;% 
  ggplot(aes(rel.inf, reorder(var, rel.inf)))+
  geom_col(aes(fill =rel.inf&gt;1, color =rel.inf&gt;1 ), width = 0.85)+
  theme_minimal_vgrid()+
  labs(x = &quot;Relative influence (%)&quot;,
       y = &quot;Model predictors&quot;,
       fill = &quot;RI &gt; 1%&quot;,
       color = &quot;RI &gt; 1%&quot;)
rel_sbr</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-62-2.png" width="672" /></p>
<pre class="r"><code># ggsave(&quot;figs/var_influence.png&quot;,dpi = 600, height = 4, width = 6)</code></pre>
<p>Partial dependence plots</p>
<pre class="r"><code>gbm.fit.final_sbr %&gt;%
  pdp::partial(pred.var = &quot;HUE&quot;, n.trees = gbm.fit.final_sbr$n.trees, grid.resolution = 100) %&gt;%
  ggplot(aes( HUE,(yhat)))+
  geom_line()</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-63-1.png" width="672" /></p>
<p>LIME</p>
<pre class="r"><code>library(lime)</code></pre>
<pre class="r"><code>model_type.gbm &lt;- function(x, ...) {
  return(&quot;regression&quot;)
}

predict_model.gbm &lt;- function(x, newdata, ...) {
  pred &lt;- predict(x, newdata, n.trees = x$n.trees)
  return(as.data.frame(pred))
}</code></pre>
<pre class="r"><code># get a few observations to perform local interpretation on
local_obs &lt;- (all_data_spread_sbr[-train,])[1:4, ]

# apply LIME
explainer &lt;- lime(all_data_spread_sbr[train,], gbm.fit.final_sbr)
explanation &lt;- lime::explain(local_obs, explainer, n_features = 7, n.trees =1)
plot_features(explanation)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-66-1.png" width="672" /></p>
</div>
</div>
<div id="prediction-1" class="section level2">
<h2>Prediction</h2>
<pre class="r"><code># predict values for test data
pred &lt;- predict(gbm.fit.final_sbr,
                n.trees = gbm.fit.final_sbr$n.trees,
                all_data_spread_sbr[-train,])

# results
caret::RMSE((pred), all_data_spread_sbr[-train,]$sev)</code></pre>
<pre><code>## [1] 1.926231</code></pre>
<pre class="r"><code>CCC(pred, all_data_spread_sbr$sev[-train])$rho.c$est</code></pre>
<pre><code>## [1] 0.9958621</code></pre>
<pre class="r"><code>cor(pred, all_data_spread_sbr$sev[-train])^2</code></pre>
<pre><code>## [1] 0.9921386</code></pre>
<pre class="r"><code>accuracy_sbr =data.frame(predi=pred, actual = all_data_spread_sbr$sev[-train]) %&gt;% 
  summarise(RMSE = caret::RMSE(pred, actual),
            r = cor(pred, actual),
            s.shift = CCC(pred, actual)$s.shift,
            l.shift = CCC(pred, actual)$l.shift,
            C.b = CCC(pred, actual)$C.b,
            CCC = CCC(pred, actual)$rho.c$est,
            CIS = paste(
  round(CCC(pred, all_data_spread_sbr$sev[-train])$rho.c[2],2),&quot;,&quot;,&quot; &quot;,
  round(CCC(pred, all_data_spread_sbr$sev[-train])$rho.c[3],2),sep = &quot;&quot;
  ))
accuracy_sbr</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["RMSE"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["r"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["s.shift"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["l.shift"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["C.b"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["CCC"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["CIS"],"name":[7],"type":["chr"],"align":["left"]}],"data":[{"1":"1.926231","2":"0.9960615","3":"0.9916907","4":"-0.01819114","5":"0.9997998","6":"0.9958621","7":"0.99, 1"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<div id="plot-1" class="section level4">
<h4>plot</h4>
<pre class="r"><code>conc_sbr = data.frame(predict = pred, actual =all_data_spread_sbr$sev[-train]) %&gt;% 
ggplot(aes(actual, predict ))+
  geom_point(size =2, color = &quot;gray&quot;)+
  geom_abline(intercept = 0, slope= 1, size = .81, color = &quot;black&quot;, linetype = &quot;dashed&quot;)+
  geom_smooth(method = &quot;lm&quot;, 
              color = &quot;red&quot;,
              size =.81, se =F,
              fullrange=T)+
  theme_minimal_grid()+
  labs(x = &quot;Predicted Severity (%)&quot;,
       y = &quot;Actual Severity (%)&quot;)+
  coord_equal(xlim = c(0,100),
              ylim = c(0,100))+
  xlim(0,100)


ggsave(&quot;figs/concordance.png&quot;, dpi = 600, height = 3.5, width = 4)</code></pre>
<pre><code>## `geom_smooth()` using formula &#39;y ~ x&#39;</code></pre>
</div>
</div>
</div>
<div id="xylella" class="section level1">
<h1>Xylella</h1>
<pre class="r"><code>pics&lt;-list.files(&quot;./pics/01-Xylella-tobacco-bg-white&quot;)
# length(pics)
#indices
index = c(&quot;BI&quot;,&quot;SCI&quot;,&quot;GLI&quot;,&quot;HI&quot;,&quot;SI&quot;,&quot;VARI&quot;,&quot;HUE&quot;,&quot;BGI&quot;,&quot;NGRDI&quot;)


box = data.frame()

for(i in 1:length(pics)){

EX.L1&lt;-stack(paste(&quot;./pics/01-Xylella-tobacco-bg-white/&quot;,pics[i],sep = &quot;&quot;))
EX.L1&lt;-aggregate(EX.L1, fact=7)
EX.L.Shape&lt;-fieldPolygon(mosaic=EX.L1, extent=T, plot = F)

EX1.Indices&lt;- fieldIndex(mosaic = EX.L1,
                         index = index, 
                         myIndex = c(&quot;Green&quot;), plot = F)

EX.L2&lt;-fieldMask(mosaic=EX.L1,  myIndex = c(&quot;Blue&quot;), cropValue=200, cropAbove=T, plot = F)

cut = mask(EX.L1, EX.L2$newMosaic)
EX.L4&lt;-fieldIndex(mosaic=cut,
                  index =index,
                  plot =F)


df = as(EX.L4, &quot;SpatialPixelsDataFrame&quot;)
dff = as.data.frame(df) %&gt;% 
  mutate(gray = 0.299*Red+0.587*Green+0.114*Blue) %&gt;% 
  gather(c(1:(3+length(index)),15), key = &quot;index&quot;, value = &quot;value&quot; ) %&gt;%
  filter(!is.na(value),
         !is.infinite(value)) %&gt;% 
  group_by(index) %&gt;% 
  dplyr::summarise(mean = mean(value, na.rm = T),
            std = sd(value),
            Q25 = quantile(value,0.25),
            Q50 = quantile(value,0.50),
            Q75 = quantile(value,0.75)) %&gt;% 
  mutate(leaf = pics[i])


box = box %&gt;% 
  bind_rows(dff)}
length(unique(box$leaf))
write.table(box,&quot;data/indexes_Xylella.txt&quot;)</code></pre>
<pre class="r"><code>box = read.table(&quot;data/indexes_Xylella.txt&quot;)</code></pre>
<div id="load" class="section level2">
<h2>Load</h2>
<pre class="r"><code>data_xy_load = read_csv(&quot;data_pics/01-Xylella-tobacco-severity.csv&quot;) %&gt;% 
  mutate(file = as.character(File)) %&gt;% 
  dplyr::select(-File)</code></pre>
<pre><code>## 
## -- Column specification --------------------------------------------------------
## cols(
##   File = col_double(),
##   ImageJ = col_double(),
##   LeafDoctor = col_double(),
##   APSAssess = col_double()
## )</code></pre>
<pre class="r"><code>data_xy = box %&gt;% 
  separate(leaf, into=c(&quot;file&quot;,&quot;format&quot;), sep =&quot;.jpg&quot;) %&gt;% 
  dplyr::select(-format) %&gt;% 
  full_join(data_xy_load, by=&quot;file&quot;) %&gt;% 
  mutate(sev=ImageJ)
head(data_xy)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["index"],"name":[1],"type":["chr"],"align":["left"]},{"label":["mean"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["std"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["Q25"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["Q50"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["Q75"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["file"],"name":[7],"type":["chr"],"align":["left"]},{"label":["ImageJ"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["LeafDoctor"],"name":[9],"type":["dbl"],"align":["right"]},{"label":["APSAssess"],"name":[10],"type":["dbl"],"align":["right"]},{"label":["sev"],"name":[11],"type":["dbl"],"align":["right"]}],"data":[{"1":"BGI","2":"0.5436164","3":"0.06012171","4":"0.5121507","5":"0.5339519","6":"0.5541888","7":"1","8":"26.78","9":"27.16","10":"26.11","11":"26.78","_rn_":"1"},{"1":"BI","2":"167.1293733","3":"13.09258103","4":"159.0452599","5":"167.3032019","6":"174.4013051","7":"1","8":"26.78","9":"27.16","10":"26.11","11":"26.78","_rn_":"2"},{"1":"Blue","2":"105.5686704","3":"17.59494065","4":"94.8571429","5":"103.7959184","6":"112.1020408","7":"1","8":"26.78","9":"27.16","10":"26.11","11":"26.78","_rn_":"3"},{"1":"GLI","2":"0.1386614","3":"0.02024763","4":"0.1340011","5":"0.1426077","6":"0.1493713","7":"1","8":"26.78","9":"27.16","10":"26.11","11":"26.78","_rn_":"4"},{"1":"gray","2":"181.5699319","3":"13.15076107","4":"173.3458163","5":"182.0882245","6":"189.5007959","7":"1","8":"26.78","9":"27.16","10":"26.11","11":"26.78","_rn_":"5"},{"1":"Green","2":"193.3106785","3":"13.42077360","4":"184.7346939","5":"194.0408163","6":"202.0408163","7":"1","8":"26.78","9":"27.16","10":"26.11","11":"26.78","_rn_":"6"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code># length(unique(data_xy$sev))</code></pre>
<pre class="r"><code>summary(data_xy$sev)</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##    0.42    8.50   19.07   25.20   37.83   83.99</code></pre>
<div id="images-2" class="section level3">
<h3>Images</h3>
<pre class="r"><code>hist_sev_xy =  data_xy %&gt;% 
  pivot_wider(id_col = c(file,sev),
              names_from = index, 
              values_from =  mean) %&gt;%
  ggplot(aes(sev))+
  geom_histogram(color = &quot;white&quot;, fill = &quot;black&quot;, bins = 20)+
  theme_minimal_hgrid(font_size = 10)+
  labs(x = &quot;Severity (%)&quot;,
       y = &quot;Frequency&quot;)+
  scale_x_continuous(limits = c(-5,105), breaks = seq(0,100,25))+
  # theme_void()+
  # coord_fixed()+
  theme(panel.background = element_rect(color = &quot;black&quot;))</code></pre>
<pre class="r"><code>EX.L1&lt;-stack(paste(&quot;./pics/01-Xylella-tobacco-bg-white/&quot;,&quot;75.jpg&quot;,sep = &quot;&quot;))
EX.L1&lt;-aggregate(EX.L1, fact=7)
EX.L.Shape&lt;-fieldPolygon(mosaic=EX.L1, extent=T, plot = F)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;</code></pre>
<pre class="r"><code>EX1.Indices&lt;- fieldIndex(mosaic = EX.L1,
                         index = index, 
                         myIndex = c(&quot;Green&quot;), plot = F)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;</code></pre>
<pre class="r"><code>EX.L2&lt;-fieldMask(mosaic=EX.L1,  myIndex = c(&quot;Blue&quot;), cropValue=200, cropAbove=T, plot = F)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;
## [1] &quot;Mask equation myIndex=Blue&quot;</code></pre>
<pre class="r"><code>cut = mask(EX.L1, EX.L2$newMosaic)
EX.L4&lt;-fieldIndex(mosaic=cut,
                  index =index,
                  plot =F)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;</code></pre>
<pre class="r"><code># plot(EX.L4$HUE)</code></pre>
<pre class="r"><code>rgb_fig_xy = RStoolbox::ggRGB(EX.L2$newMosaic,
                 r = 1,
                 g = 2,
                 b = 3)+
  theme_map()+
  coord_fixed()+
  theme(panel.background = element_rect(color = &quot;white&quot;))</code></pre>
<pre><code>## Coordinate system already present. Adding new coordinate system, which will replace the existing one.</code></pre>
<pre class="r"><code>gli_fig_xy = as.data.frame(EX.L4$HUE, xy=TRUE, na.rm =T) %&gt;% 
  ggplot(aes(x, y, fill = HUE))+
  geom_tile()+
  scale_fill_viridis_c(option = &quot;B&quot;,direction = -1)+
  theme_map()+
  coord_fixed()+
  theme(panel.background = element_rect(color = &quot;white&quot;),
        legend.title = element_text(size = 8),
        legend.text = element_text(size = 8))

# rgb_fig_xy+ gli_fig_xy</code></pre>
<pre class="r"><code># rgb_fig_sbr + gli_fig_sbr + hist_sev_sbr #+
#   rgb_fig_wlb + gli_fig_wlb + hist_sev_WLB+
  rgb_fig_xy + gli_fig_xy +hist_sev_xy</code></pre>
<pre><code>## Warning: Removed 2 rows containing missing values (geom_bar).</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-78-1.png" width="672" /></p>
<pre class="r"><code>#    plot_layout(widths = c(1, 1, 1),
#                heights = c(1,1,1))
# 
# ggsave(&quot;figs/leaf_gli.png&quot;,dpi = 600, height = 7, width =8)</code></pre>
</div>
<div id="relationship-sev-indices-2" class="section level3">
<h3>Relationship sev indices</h3>
<pre class="r"><code>rgb_gg_xy = data_xy %&gt;% 
  filter(index %in% c(&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;)) %&gt;% 
    ggplot(aes(mean, sev, color = index)) + 
  # geom_text()+
  geom_point(color = &quot;gray&quot;, size  =3)+
  geom_smooth(se = F, size = 2)+
  facet_wrap(~index, scales = &quot;free_x&quot;, nrow =1)+
  scale_color_manual(values = c(&quot;steelblue&quot;,&quot;darkgreen&quot;, &quot;darkred&quot;))+
  theme_minimal_hgrid()+
  labs(x = &quot;Mean value in the image&quot;,
       y = &quot;Disease severity (%)&quot;)+
  theme(panel.border = element_rect(color = &quot;gray&quot;))+
  theme(legend.position = &quot;none&quot;)
rgb_gg_xy</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-79-1.png" width="672" /></p>
<pre class="r"><code>index_gg_xy = data_xy %&gt;% 
  filter(!index %in% c(&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;)) %&gt;% 
    ggplot(aes(mean, sev)) + 
  # geom_text()+
  geom_point(color = &quot;gray&quot;, size  =3)+
  geom_smooth(color = &quot;black&quot;, se = F, size = 2)+
  facet_wrap(~index, scales = &quot;free_x&quot;, nrow =2)+
  theme_minimal_hgrid()+
  labs(x = &quot;Mean index value in the image&quot;,
       y = &quot;Disease severity (%)&quot;)+
  theme(panel.border = element_rect(color = &quot;gray&quot;))
index_gg_xy</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-80-1.png" width="672" /></p>
<pre class="r"><code>plot_grid(
  plot_grid(NULL,rgb_gg_xy,NULL, rel_widths =c(0.18,1,0.2), nrow = 1),
          index_gg_xy,
          nrow = 2,
          rel_heights = c(0.5,1))</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;
## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-81-1.png" width="672" /></p>
<pre class="r"><code>ggsave(&quot;figs/index_sev_XY.png&quot;, dpi = 500, height = 8, width = 10)</code></pre>
<pre class="r"><code>cor_xy = data_xy %&gt;% 
  group_by(index) %&gt;% 
  dplyr::summarise(cor = round(  cor.test(mean,sev, method = &quot;spearman&quot;)$estimate,3),
                   P_value = round(cor.test(mean,sev, method = &quot;spearman&quot;)$p.value,4)) %&gt;% 
  arrange(-cor)</code></pre>
<pre><code>## `summarise()` ungrouping output (override with `.groups` argument)</code></pre>
<pre class="r"><code>cor_xy</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["index"],"name":[1],"type":["chr"],"align":["left"]},{"label":["cor"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["P_value"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"HUE","2":"0.694","3":"0.0000"},{"1":"HI","2":"0.627","3":"0.0000"},{"1":"SCI","2":"0.623","3":"0.0000"},{"1":"SI","2":"0.356","3":"0.0002"},{"1":"Red","2":"0.286","3":"0.0032"},{"1":"BI","2":"0.219","3":"0.0252"},{"1":"BGI","2":"0.214","3":"0.0288"},{"1":"Blue","2":"0.195","3":"0.0463"},{"1":"gray","2":"0.194","3":"0.0477"},{"1":"Green","2":"0.121","3":"0.2174"},{"1":"GLI","2":"-0.490","3":"0.0000"},{"1":"NGRDI","2":"-0.623","3":"0.0000"},{"1":"VARI","2":"-0.624","3":"0.0000"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
</div>
<div id="spread-df-1" class="section level3">
<h3>Spread df</h3>
<pre class="r"><code>all_data_spread_xy = data_xy %&gt;% 
  pivot_wider(id_col = c(file,sev),
              names_from = index, 
              values_from =  mean)   

head(all_data_spread_xy)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["file"],"name":[1],"type":["chr"],"align":["left"]},{"label":["sev"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["BGI"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["BI"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["Blue"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["GLI"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["gray"],"name":[7],"type":["dbl"],"align":["right"]},{"label":["Green"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["HI"],"name":[9],"type":["dbl"],"align":["right"]},{"label":["HUE"],"name":[10],"type":["dbl"],"align":["right"]},{"label":["NGRDI"],"name":[11],"type":["dbl"],"align":["right"]},{"label":["Red"],"name":[12],"type":["dbl"],"align":["right"]},{"label":["SCI"],"name":[13],"type":["dbl"],"align":["right"]},{"label":["SI"],"name":[14],"type":["dbl"],"align":["right"]},{"label":["VARI"],"name":[15],"type":["dbl"],"align":["right"]}],"data":[{"1":"1","2":"26.78","3":"0.5436164","4":"167.1294","5":"105.56867","6":"0.13866141","7":"181.5699","8":"193.3107","9":"0.8683842","10":"-1.2312437","11":"0.015137044","12":"187.4974","13":"-0.015137044","14":"0.2835890","15":"0.020974514"},{"1":"10","2":"24.32","3":"0.5232702","4":"161.7949","5":"99.36791","6":"0.14893788","7":"176.3900","8":"188.8874","9":"0.8288865","10":"-1.3059402","11":"0.020765087","12":"181.2212","13":"-0.020765087","14":"0.2962883","15":"0.028340543"},{"1":"11","2":"16.31","3":"0.4770135","4":"134.6668","5":"78.49852","6":"0.18416802","7":"148.3695","8":"162.5577","9":"0.6317971","10":"-1.5660679","11":"0.050797655","12":"147.1550","13":"-0.050797655","14":"0.3130982","15":"0.067298775"},{"1":"12","2":"14.81","3":"0.5471168","4":"162.6126","5":"103.37410","6":"0.13803486","7":"176.5774","8":"187.9669","9":"0.8632352","10":"-1.1780436","11":"0.015827295","12":"182.1276","13":"-0.015827295","14":"0.2803030","15":"0.021911565"},{"1":"126","2":"7.92","3":"0.6397902","4":"188.3111","5":"134.90474","6":"0.09997205","7":"201.3672","8":"210.1206","9":"0.9952901","10":"-0.6338601","11":"0.001230542","12":"209.5227","13":"-0.001230542","14":"0.2199965","15":"0.001781766"},{"1":"127","2":"9.48","3":"0.5820188","4":"177.2043","5":"118.39907","6":"0.12488155","7":"191.4034","8":"202.4200","9":"0.8999821","10":"-1.1214523","11":"0.012366628","12":"197.6099","13":"-0.012366628","14":"0.2550979","15":"0.017096316"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
</div>
</div>
<div id="gbm-2" class="section level2">
<h2>GBM</h2>
<pre class="r"><code>train=sample(x = 1:length(all_data_spread_xy$sev), 
             size = round(0.75*length(all_data_spread_xy$sev),1))
# length(train)
gbm.fit = gbm(sev ~BGI+BI+GLI+HI+HUE+NGRDI+VARI+gray+ Red+Green+Blue  + SI + SCI,
             data = all_data_spread_xy[train,],
             distribution = &quot;gaussian&quot;,
              n.trees = 1000,
             interaction.depth = 3,
             shrinkage = 0.1,
             cv.folds = 5,
             n.cores = NULL, # will use all cores by default
             verbose = FALSE)
print(gbm.fit)</code></pre>
<pre><code>## gbm(formula = sev ~ BGI + BI + GLI + HI + HUE + NGRDI + VARI + 
##     gray + Red + Green + Blue + SI + SCI, distribution = &quot;gaussian&quot;, 
##     data = all_data_spread_xy[train, ], n.trees = 1000, interaction.depth = 3, 
##     shrinkage = 0.1, cv.folds = 5, verbose = FALSE, n.cores = NULL)
## A gradient boosted model with gaussian loss function.
## 1000 iterations were performed.
## The best cross-validation iteration was 231.
## There were 13 predictors of which 13 had non-zero influence.</code></pre>
<pre class="r"><code>sqrt(min(gbm.fit$cv.error))</code></pre>
<pre><code>## [1] 12.43899</code></pre>
<pre class="r"><code>gbm.perf(gbm.fit, method = &quot;cv&quot;)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-85-1.png" width="672" /></p>
<pre><code>## [1] 231</code></pre>
<pre class="r"><code># find index for n trees with minimum CV error</code></pre>
<pre class="r"><code>min_MSE &lt;- which.min(gbm.fit$cv.error)
sqrt(gbm.fit$cv.error[min_MSE])</code></pre>
<pre><code>## [1] 12.43899</code></pre>
<pre class="r"><code># best.iter &lt;- gbm.perf(model1, method = &quot;test&quot;)
# print(best.iter)

pred = predict(gbm.fit, newdata = all_data_spread_xy[-train,-1], ntrees = 5000 )</code></pre>
<pre><code>## Using 231 trees...</code></pre>
<pre class="r"><code>sqrt(mean(((pred)-all_data_spread_xy$sev[-train])^2))</code></pre>
<pre><code>## [1] 11.5175</code></pre>
<pre class="r"><code>CCC((pred), all_data_spread_xy$sev[-train])$rho.c$est</code></pre>
<pre><code>## [1] 0.6909319</code></pre>
<pre class="r"><code>plot((pred), (pred)-all_data_spread_xy$sev[-train])
abline(a=0,b=0)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-87-1.png" width="672" /></p>
<div id="testing-various-hyperparameters-2" class="section level3">
<h3>Testing various hyperparameters</h3>
<p>Create hyperparameter grid</p>
<pre class="r"><code>hyper_grid &lt;- expand.grid(
  shrinkage = c(.001, .01, .1, .3),
  interaction.depth = c(1, 3, 5, 6),
  n.minobsinnode = c(5, 10, 15),
  bag.fraction = c(.5,.65, .8, 1), 
  optimal_trees = 0,               # a place to dump results
  min_RMSE = 0,
  CCC =0 # a place to dump results
)
# total number of combinations
nrow(hyper_grid)</code></pre>
<pre><code>## [1] 192</code></pre>
<pre class="r"><code># randomize data
set.seed(123)
train=sample(x = 1:length(all_data_spread_xy$sev), 
             size = round(0.80*length(all_data_spread_xy$sev),1))

# grid search 
for(i in 1:nrow(hyper_grid)) {

# reproducibility
set.seed(123)


 # train model
gbm.tune &lt;- gbm(
  formula = (sev) ~BGI+BI+GLI+HI+HUE+NGRDI+VARI+gray +Red+Green+Blue + SI + SCI, #&lt;&lt;&lt;&lt;&lt;
  data = all_data_spread_xy[train,],
  distribution = &quot;gaussian&quot;,
  n.trees = 5000,
  interaction.depth = hyper_grid$interaction.depth[i],
  shrinkage = hyper_grid$shrinkage[i],
  n.minobsinnode = hyper_grid$n.minobsinnode[i],
  bag.fraction = hyper_grid$bag.fraction[i],
  train.fraction = .75,
  n.cores = NULL, # will use all cores by default
  verbose = FALSE)

pred = predict(gbm.tune, newdata = all_data_spread_xy[-train,-1], ntrees = 5000 )
 # add min training error and trees to grid
  hyper_grid$optimal_trees[i] &lt;- which.min(gbm.tune$valid.error)
  hyper_grid$min_RMSE[i] &lt;- sqrt(min(gbm.tune$valid.error))
  hyper_grid$CCC[i] = CCC(pred, all_data_spread_xy$sev[-train])$rho.c$est#&lt;&lt;&lt;&lt;&lt;
  
}

best_par = hyper_grid %&gt;% 
  dplyr::arrange(-CCC) %&gt;%
  head(10)
best_par</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["shrinkage"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["interaction.depth"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["n.minobsinnode"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["bag.fraction"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["optimal_trees"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["min_RMSE"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["CCC"],"name":[7],"type":["dbl"],"align":["right"]}],"data":[{"1":"0.30","2":"3","3":"5","4":"0.65","5":"19","6":"11.37018","7":"0.8649715","_rn_":"1"},{"1":"0.30","2":"5","3":"5","4":"0.65","5":"4662","6":"12.21829","7":"0.8407627","_rn_":"2"},{"1":"0.01","2":"1","3":"5","4":"0.65","5":"966","6":"12.00979","7":"0.8362572","_rn_":"3"},{"1":"0.30","2":"6","3":"5","4":"0.65","5":"25","6":"12.57791","7":"0.8356177","_rn_":"4"},{"1":"0.01","2":"1","3":"5","4":"1.00","5":"2091","6":"12.73349","7":"0.8252694","_rn_":"5"},{"1":"0.01","2":"1","3":"5","4":"0.80","5":"928","6":"12.61867","7":"0.8244094","_rn_":"6"},{"1":"0.30","2":"1","3":"5","4":"0.80","5":"23","6":"12.65166","7":"0.8236509","_rn_":"7"},{"1":"0.30","2":"1","3":"5","4":"1.00","5":"59","6":"12.65081","7":"0.8226995","_rn_":"8"},{"1":"0.10","2":"1","3":"5","4":"1.00","5":"218","6":"12.83123","7":"0.8215836","_rn_":"9"},{"1":"0.10","2":"1","3":"5","4":"0.65","5":"64","6":"12.07186","7":"0.8157707","_rn_":"10"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code># gbm.tune$fit</code></pre>
</div>
<div id="best-model-2" class="section level3">
<h3>Best model</h3>
<pre class="r"><code># for reproducibility
set.seed(123)

# train GBM model
gbm.fit.final_xy &lt;- gbm(
  formula = (sev) ~BGI+BI+GLI+HI+HUE+NGRDI+VARI+Red+Green+Blue+gray+SI+SCI,
  data = all_data_spread_xy[train,],
  distribution = &quot;gaussian&quot;,
  n.trees = best_par$optimal_trees[1],
  interaction.depth = best_par$interaction.depth[1],
  shrinkage = best_par$shrinkage[1],
  n.minobsinnode = best_par$n.minobsinnode[1],
  bag.fraction = best_par$bag.fraction[1], 
  train.fraction =0.75,
  n.cores = NULL, # will use all cores by default
  verbose = FALSE
  )</code></pre>
</div>
<div id="relative-influence-2" class="section level3">
<h3>Relative influence</h3>
<pre class="r"><code>par(mar = c(5, 8, 1, 1))
summary_gbm_xy = summary(
  gbm.fit.final_xy, 
  cBars = 15,
  method = relative.influence, # also can use permutation.test.gbm
  las = 2
  )</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-91-1.png" width="672" /></p>
<pre class="r"><code>rel_xy = summary_gbm_xy %&gt;% 
  rownames_to_column(&quot;index&quot;) %&gt;% 
  ggplot(aes(rel.inf, reorder(var, rel.inf)))+
  geom_col(aes(fill =rel.inf&gt;1, color =rel.inf&gt;1 ), width = 0.85)+
  theme_minimal_vgrid()+
  labs(x = &quot;Relative influence (%)&quot;,
       y = &quot;Model predictors&quot;,
       fill = &quot;RI &gt; 1%&quot;,
       color = &quot;RI &gt; 1%&quot;)
rel_xy</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-91-2.png" width="672" /></p>
<pre class="r"><code># ggsave(&quot;figs/var_influence.png&quot;,dpi = 600, height = 4, width = 6)</code></pre>
<p>Partial dependence plots</p>
<pre class="r"><code>gbm.fit.final_xy %&gt;%
  pdp::partial(pred.var = &quot;HUE&quot;, n.trees = gbm.fit.final_xy$n.trees, grid.resolution = 100) %&gt;%
  ggplot(aes( HUE,(yhat)))+
  geom_line()</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-92-1.png" width="672" /></p>
<p>LIME</p>
<pre class="r"><code>library(lime)</code></pre>
<pre class="r"><code>model_type.gbm &lt;- function(x, ...) {
  return(&quot;regression&quot;)
}

predict_model.gbm &lt;- function(x, newdata, ...) {
  pred &lt;- predict(x, newdata, n.trees = x$n.trees)
  return(as.data.frame(pred))
}</code></pre>
<pre class="r"><code># get a few observations to perform local interpretation on
local_obs &lt;- (all_data_spread_xy[-train,])[1:4, ]

# apply LIME
explainer &lt;- lime(all_data_spread_xy[train,], gbm.fit.final_xy)
explanation &lt;- lime::explain(local_obs, explainer, n_features = 7, n.trees =1)
plot_features(explanation)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-95-1.png" width="672" /></p>
</div>
</div>
<div id="prediction-2" class="section level2">
<h2>Prediction</h2>
<pre class="r"><code># predict values for test data
pred &lt;- predict(gbm.fit.final_xy,
                n.trees = gbm.fit.final_xy$n.trees,
                all_data_spread_xy[-train,])

# results
caret::RMSE((pred), all_data_spread_xy[-train,]$sev)</code></pre>
<pre><code>## [1] 10.55157</code></pre>
<pre class="r"><code>CCC((pred), all_data_spread_xy$sev[-train])$rho.c$est</code></pre>
<pre><code>## [1] 0.8649715</code></pre>
<pre class="r"><code>cor((pred), all_data_spread_xy$sev[-train])^2</code></pre>
<pre><code>## [1] 0.757813</code></pre>
<pre class="r"><code>accuracy_xy =data.frame(predi=pred, actual = all_data_spread_xy$sev[-train]) %&gt;% 
  summarise(RMSE = caret::RMSE(pred, actual),
            r = cor(pred, actual),
            s.shift = CCC(pred, actual)$s.shift,
            l.shift = CCC(pred, actual)$l.shift,
            C.b = CCC(pred, actual)$C.b,
            CCC = CCC(pred, actual)$rho.c$est,
            CIS = paste(
  round(CCC(pred, all_data_spread_xy$sev[-train])$rho.c[2],2),&quot;,&quot;,&quot; &quot;,
  round(CCC(pred, all_data_spread_xy$sev[-train])$rho.c[3],2),sep = &quot;&quot;
  ))
accuracy_xy</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["RMSE"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["r"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["s.shift"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["l.shift"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["C.b"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["CCC"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["CIS"],"name":[7],"type":["chr"],"align":["left"]}],"data":[{"1":"10.55157","2":"0.8705245","3":"1.077005","4":"0.08563874","5":"0.9936211","6":"0.8649715","7":"0.7, 0.94"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<div id="plot-2" class="section level4">
<h4>plot</h4>
<pre class="r"><code>conc_xy = data.frame(predict = pred, actual =all_data_spread_xy$sev[-train]) %&gt;% 
ggplot(aes(actual,predict))+
  geom_point(size =2, color = &quot;gray&quot;)+
  geom_abline(intercept = 0, slope= 1, size = .81, color = &quot;black&quot;, linetype = &quot;dashed&quot;)+
  geom_smooth(method = &quot;lm&quot;, 
              color = &quot;red&quot;,
              size =.81, se =F,
              fullrange=T)+
  theme_minimal_grid()+
  labs(x = &quot;Predicted Severity (%)&quot;,
       y = &quot;Actual Severity (%)&quot;)+
  coord_equal(xlim = c(0,100),
              ylim = c(0,100))+
  xlim(0,100)


ggsave(&quot;figs/concordance.png&quot;, dpi = 600, height = 3.5, width = 4)</code></pre>
<pre><code>## `geom_smooth()` using formula &#39;y ~ x&#39;</code></pre>
</div>
</div>
</div>
<div id="late-blight" class="section level1">
<h1>Late blight</h1>
<pre class="r"><code>pics&lt;-list.files(&quot;./pics/01 - PLB&quot;)
# length(pics)
#indices
index = c(&quot;BI&quot;,&quot;SCI&quot;,&quot;GLI&quot;,&quot;HI&quot;,&quot;SI&quot;,&quot;VARI&quot;,&quot;HUE&quot;,&quot;BGI&quot;,&quot;NGRDI&quot;)


box = data.frame()

for(i in 1:length(pics)){

EX.L1&lt;-stack(paste(&quot;./pics/01 - PLB/&quot;,pics[i],sep = &quot;&quot;))
EX.L1&lt;-aggregate(EX.L1, fact=4)
EX.L.Shape&lt;-fieldPolygon(mosaic=EX.L1, extent=T, plot = F)

# EX1.Indices&lt;- fieldIndex(mosaic = EX.L1,
#                          index = c(&quot;NGRDI&quot;,&quot;BGI&quot;,&quot;GLI&quot;, &quot;SCI&quot;,&quot;HI&quot;, &quot;SI&quot;), 
#                          myIndex = c(&quot;(Red-Blue)/Green&quot;), plot = F)

EX.L2&lt;-fieldMask(mosaic=EX.L1, myIndex =&quot;Red&quot;, cropValue=1, cropAbove=F, plot = F)

cut = mask(EX.L1, EX.L2$mask)
EX.L4&lt;-fieldIndex(mosaic=cut,
                  index =index,
                  plot =F)


df = as(EX.L4, &quot;SpatialPixelsDataFrame&quot;)
dff = as.data.frame(df) %&gt;% 
  mutate(gray = 0.299*Red+0.587*Green+0.114*Blue) %&gt;% 
  gather(c(1:(3+length(index)),15), key = &quot;index&quot;, value = &quot;value&quot; ) %&gt;%
  filter(!is.na(value),
         !is.infinite(value)) %&gt;% 
  group_by(index) %&gt;% 
  dplyr::summarise(mean = mean(value, na.rm = T),
            std = sd(value),
            Q25 = quantile(value,0.25),
            Q50 = quantile(value,0.50),
            Q75 = quantile(value,0.75)) %&gt;% 
  mutate(leaf = pics[i])


box = box %&gt;% 
  bind_rows(dff)}
length(unique(box$leaf))
write.table(box,&quot;data/indexes_PLB.txt&quot;)</code></pre>
<pre class="r"><code>box = read.table(&quot;data/indexes_PLB.txt&quot;)</code></pre>
<div id="load-severity-data-1" class="section level2">
<h2>Load severity data</h2>
<pre class="r"><code>library(gsheet)


sev_data_plb2 = gsheet2tbl(&quot;https://docs.google.com/spreadsheets/d/1cnxGPXBYVR9lq0InKhhMMjr-cQ21vCf3q6iw8VEi6pY/edit#gid=445074476&quot;) %&gt;% 
  unite(&quot;file&quot;,1:2, sep = &quot;.&quot;)



length(unique(sev_data_plb2$file))</code></pre>
<pre><code>## [1] 232</code></pre>
<pre class="r"><code>#new evaluation
all_data_PI = box %&gt;% 
  mutate(file = leaf) %&gt;% 
  dplyr::select(-leaf) %&gt;% 
  # separate(file, into = c(&quot;file&quot;, &quot;format&quot;), sep = &quot;.&quot;) %&gt;% 
  # dplyr::select(-format) %&gt;%
  right_join(sev_data_plb2)</code></pre>
<pre><code>## Joining, by = &quot;file&quot;</code></pre>
<pre class="r"><code># all_data_PI = box %&gt;% 
#   mutate(file = leaf) %&gt;% 
#   dplyr::select(-leaf) %&gt;% 
#   right_join(sev_data) #%&gt;% 
#   # filter(sev&gt;0) %&gt;% 
#   # mutate(sev = case_when(sev==0 ~0.001,
#   #                        sev &gt;0 ~sev))</code></pre>
<pre class="r"><code>summary(all_data_PI$sev)</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##    0.00   39.23   52.19   49.96   65.42   88.87</code></pre>
<div id="images-3" class="section level3">
<h3>Images</h3>
<pre class="r"><code>hist_sev_pi =  all_data_PI %&gt;% 
  pivot_wider(id_col = c(file,sev),
              names_from = index, 
              values_from =  mean) %&gt;% 
  ggplot(aes(sev))+
  geom_histogram(color = &quot;white&quot;, fill = &quot;black&quot;, bins =20)+
  theme_minimal_hgrid(font_size = 10)+
  labs(x = &quot;Severity (%)&quot;,
       y = &quot;Frequency&quot;)+
  scale_x_continuous(limits = c(-5,105), breaks = seq(0,100,25))+
  # theme_void()+
  # coord_fixed()+
  theme(panel.background = element_rect(color = &quot;black&quot;),
        axis.title.y = element_text(size=8))</code></pre>
<pre class="r"><code>EX.L1&lt;-stack(paste(&quot;./pics/01-potato_late_bligh/&quot;,&quot;PI21_2D.png&quot;,sep = &quot;&quot;))
EX.L1&lt;-aggregate(EX.L1, fact=10)
EX.L.Shape&lt;-fieldPolygon(mosaic=EX.L1, extent=T, plot = F)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;</code></pre>
<pre class="r"><code>EX1.Indices&lt;- fieldIndex(mosaic = EX.L1,
                         index = index, 
                         myIndex = c(&quot;Green&quot;), plot = F)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;</code></pre>
<pre class="r"><code>EX.L2&lt;-fieldMask(mosaic=EX.L1,  myIndex = c(&quot;Red&quot;), cropValue=1, cropAbove=F, plot = F)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;
## [1] &quot;Mask equation myIndex=Red&quot;</code></pre>
<pre class="r"><code>cut = mask(EX.L1, EX.L2$newMosaic)
EX.L4&lt;-fieldIndex(mosaic=cut,
                  index =index,
                  plot = F)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;</code></pre>
<pre class="r"><code># plot(EX.L4$HUE)</code></pre>
<pre class="r"><code>rgb_fig_pi = RStoolbox::ggRGB(EX.L2$newMosaic,
                 r = 1,
                 g = 2,
                 b = 3)+
  theme_map()+
  coord_fixed()+
  xlim(250,1500)+
  ylim(50,1300)+
  theme(panel.background = element_rect(color = &quot;white&quot;))</code></pre>
<pre><code>## Coordinate system already present. Adding new coordinate system, which will replace the existing one.</code></pre>
<pre class="r"><code>gli_fig_pi = as.data.frame(EX.L4$BGI, xy=TRUE, na.rm =T) %&gt;% 
  ggplot(aes(x, y, fill = BGI))+
  geom_tile()+
  scale_fill_viridis_c(option = &quot;B&quot;,direction = -1)+
  theme_map()+
  coord_fixed()+
  xlim(250,1500)+
  ylim(50,1300)+
  theme(panel.background = element_rect(color = &quot;white&quot;),
        legend.title = element_text(size = 8),
        legend.text = element_text(size = 8))

# rgb_fig_pi + gli_fig_pi</code></pre>
<pre class="r"><code># rgb_fig_sbr + gli_fig_sbr + hist_sev_sbr #+
#   rgb_fig_wlb + gli_fig_wlb + hist_sev_WLB+
#   rgb_fig_xy + gli_fig_xy +hist_sev_xy+
  rgb_fig_pi + gli_fig_pi +hist_sev_pi</code></pre>
<pre><code>## Warning: Removed 2 rows containing missing values (geom_bar).</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-108-1.png" width="672" /></p>
<pre class="r"><code>#    plot_layout(widths = c(1, 1, 1),
#                heights = c(1,1,1,1))+
#   plot_annotation(tag_levels = &#39;A&#39;)

# ggsave(&quot;figs/leaf_gli.png&quot;,dpi = 600, height = 8, width =8)</code></pre>
</div>
<div id="relationship-sev-indices-3" class="section level3">
<h3>Relationship sev indices</h3>
<pre class="r"><code>rgb_gg_pi = all_data_PI %&gt;% 
  filter(index %in% c(&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;)) %&gt;% 
    ggplot(aes(mean, sev, color = index)) + 
  # geom_text()+
  geom_point(color = &quot;gray&quot;, size  =3)+
  geom_smooth(se = F, size = 2)+
  facet_wrap(~index, scales = &quot;free_x&quot;, nrow =1)+
  scale_color_manual(values = c(&quot;steelblue&quot;,&quot;darkgreen&quot;, &quot;darkred&quot;))+
  theme_minimal_hgrid()+
  labs(x = &quot;Mean value in the image&quot;,
       y = &quot;Disease severity (%)&quot;)+
  theme(panel.border = element_rect(color = &quot;gray&quot;))+
  theme(legend.position = &quot;none&quot;)
rgb_gg_pi</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-109-1.png" width="672" /></p>
<pre class="r"><code>index_gg_pi = all_data_PI %&gt;% 
  filter(!index %in% c(&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;)) %&gt;% 
    ggplot(aes(mean, sev)) + 
  # geom_text()+
  geom_point(color = &quot;gray&quot;, size  =3)+
  geom_smooth(color = &quot;black&quot;, se = F, size = 2)+
  facet_wrap(~index, scales = &quot;free_x&quot;, nrow =2)+
  theme_minimal_hgrid()+
  labs(x = &quot;Mean index value in the image&quot;,
       y = &quot;Disease severity (%)&quot;)+
  theme(panel.border = element_rect(color = &quot;gray&quot;))
index_gg_pi</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-110-1.png" width="672" /></p>
<pre class="r"><code>plot_grid(
  plot_grid(NULL,rgb_gg_pi,NULL, rel_widths =c(0.18,1,0.2), nrow = 1),
          index_gg_pi,
          nrow = 2,
          rel_heights = c(0.5,1))</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;
## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-111-1.png" width="672" /></p>
<pre class="r"><code>ggsave(&quot;figs/index_sev_pi.png&quot;, dpi = 500, height = 8, width = 10)</code></pre>
<pre class="r"><code>cor_PI = all_data_PI %&gt;% 
  group_by(index) %&gt;% 
  dplyr::summarise(cor = round(  cor.test(mean,sev, method = &quot;spearman&quot;)$estimate,3),
                   P_value = round(cor.test(mean,sev, method = &quot;spearman&quot;)$p.value,4)) %&gt;% 
  arrange(-cor)</code></pre>
<pre><code>## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties</code></pre>
<pre><code>## `summarise()` ungrouping output (override with `.groups` argument)</code></pre>
<pre class="r"><code>cor_PI</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["index"],"name":[1],"type":["chr"],"align":["left"]},{"label":["cor"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["P_value"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"BGI","2":"0.889","3":"0.0000"},{"1":"Blue","2":"0.854","3":"0.0000"},{"1":"BI","2":"0.609","3":"0.0000"},{"1":"gray","2":"0.572","3":"0.0000"},{"1":"Red","2":"0.501","3":"0.0000"},{"1":"Green","2":"0.492","3":"0.0000"},{"1":"SCI","2":"0.082","3":"0.2142"},{"1":"VARI","2":"0.020","3":"0.7601"},{"1":"HUE","2":"-0.054","3":"0.4138"},{"1":"NGRDI","2":"-0.082","3":"0.2142"},{"1":"HI","2":"-0.327","3":"0.0000"},{"1":"GLI","2":"-0.661","3":"0.0000"},{"1":"SI","2":"-0.855","3":"0.0000"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
</div>
<div id="spread-df-2" class="section level3">
<h3>Spread df</h3>
<pre class="r"><code>all_data_spread_plb = all_data_PI %&gt;% 
  pivot_wider(id_col = c(file,sev),
              names_from = index, 
              values_from =  mean)   

head(all_data_spread_plb)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["file"],"name":[1],"type":["chr"],"align":["left"]},{"label":["sev"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["BGI"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["BI"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["Blue"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["GLI"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["gray"],"name":[7],"type":["dbl"],"align":["right"]},{"label":["Green"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["HI"],"name":[9],"type":["dbl"],"align":["right"]},{"label":["HUE"],"name":[10],"type":["dbl"],"align":["right"]},{"label":["NGRDI"],"name":[11],"type":["dbl"],"align":["right"]},{"label":["Red"],"name":[12],"type":["dbl"],"align":["right"]},{"label":["SCI"],"name":[13],"type":["dbl"],"align":["right"]},{"label":["SI"],"name":[14],"type":["dbl"],"align":["right"]},{"label":["VARI"],"name":[15],"type":["dbl"],"align":["right"]}],"data":[{"1":"foto01.png","2":"9.000000","3":"0.25363365","4":"57.12791","5":"20.651936","6":"0.3042240","7":"64.04993","8":"74.07280","9":"0.5110658","10":"-0.6627991","11":"0.09754001","12":"60.91931","13":"-0.09754001","14":"0.5667016","15":"0.1141011"},{"1":"foto02.png","2":"18.000000","3":"0.22692752","4":"54.33280","5":"17.979925","6":"0.3113957","7":"60.84859","8":"70.34088","9":"0.5497061","10":"-0.6820149","11":"0.09185999","12":"58.55780","13":"-0.09185999","14":"0.6117315","15":"0.1061503"},{"1":"foto03.png","2":"3.106504","3":"0.05612778","4":"45.37976","5":"4.379311","6":"0.4765589","7":"51.59967","8":"64.93425","9":"0.2824614","10":"-0.6584705","11":"0.20944996","12":"43.42484","13":"-0.20944996","14":"0.8700296","15":"0.2161284"},{"1":"foto04.png","2":"3.211166","3":"0.31267603","4":"60.16884","5":"25.972990","6":"0.2737552","7":"67.38537","8":"77.17300","9":"0.4994249","10":"-0.6649015","11":"0.09138491","12":"63.95952","13":"-0.09138491","14":"0.4796293","15":"0.1124940"},{"1":"foto07.png","2":"4.136306","3":"0.28881103","4":"55.09950","5":"25.490871","6":"0.3914085","7":"62.30321","8":"76.53045","9":"-0.1944951","10":"-0.8530637","11":"0.24807269","12":"48.40760","13":"-0.24807269","14":"0.4434008","15":"0.3047156"},{"1":"foto08.png","2":"5.951718","3":"0.36046580","4":"56.27959","5":"28.602833","6":"0.2870583","7":"62.97897","8":"73.48632","9":"0.1828795","10":"-0.7832093","11":"0.13832606","12":"55.45744","13":"-0.13832606","14":"0.3962352","15":"0.1791645"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
</div>
<div id="gbm-3" class="section level3">
<h3>GBM</h3>
<pre class="r"><code>train=sample(x = 1:length(all_data_spread_plb$sev), 
             size = round(0.75*length(all_data_spread_plb$sev),1))
# length(train)
gbm.fit = gbm(sev ~BGI+BI+GLI+HI+HUE+NGRDI+VARI+gray+ Red+Green+Blue  + SI + SCI,
             data = all_data_spread_plb[train,],
             distribution = &quot;gaussian&quot;,
              n.trees = 1000,
             interaction.depth = 3,
             shrinkage = 0.1,
             cv.folds = 5,
             n.cores = NULL, # will use all cores by default
             verbose = FALSE)
print(gbm.fit)</code></pre>
<pre><code>## gbm(formula = sev ~ BGI + BI + GLI + HI + HUE + NGRDI + VARI + 
##     gray + Red + Green + Blue + SI + SCI, distribution = &quot;gaussian&quot;, 
##     data = all_data_spread_plb[train, ], n.trees = 1000, interaction.depth = 3, 
##     shrinkage = 0.1, cv.folds = 5, verbose = FALSE, n.cores = NULL)
## A gradient boosted model with gaussian loss function.
## 1000 iterations were performed.
## The best cross-validation iteration was 69.
## There were 13 predictors of which 13 had non-zero influence.</code></pre>
<pre class="r"><code>sqrt(min(gbm.fit$cv.error))</code></pre>
<pre><code>## [1] 10.52827</code></pre>
<pre class="r"><code>gbm.perf(gbm.fit, method = &quot;cv&quot;)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-115-1.png" width="672" /></p>
<pre><code>## [1] 69</code></pre>
<pre class="r"><code># find index for n trees with minimum CV error</code></pre>
<pre class="r"><code>min_MSE &lt;- which.min(gbm.fit$cv.error)
sqrt(gbm.fit$cv.error[min_MSE])</code></pre>
<pre><code>## [1] 10.52827</code></pre>
<pre class="r"><code># best.iter &lt;- gbm.perf(model1, method = &quot;test&quot;)
# print(best.iter)

pred = predict(gbm.fit, newdata = all_data_spread_plb[-train,-1], ntrees = 5000 )</code></pre>
<pre><code>## Using 69 trees...</code></pre>
<pre class="r"><code>sqrt(mean(((pred)-all_data_spread_plb$sev[-train])^2))</code></pre>
<pre><code>## [1] 10.35476</code></pre>
<pre class="r"><code>CCC((pred), all_data_spread_plb$sev[-train])$rho.c$est</code></pre>
<pre><code>## [1] 0.8523472</code></pre>
<pre class="r"><code>plot((pred), (pred)-all_data_spread_plb$sev[-train])
abline(a=0,b=0)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-117-1.png" width="672" /></p>
</div>
<div id="testing-various-hyperparameters-3" class="section level3">
<h3>Testing various hyperparameters</h3>
<p>Create hyperparameter grid</p>
<pre class="r"><code>hyper_grid &lt;- expand.grid(
  shrinkage = c(.001, .01, .1, .3),
  interaction.depth = c(1, 3, 5, 6),
  n.minobsinnode = c(5, 10, 15),
  bag.fraction = c(.5,.65, .8, 1), 
  optimal_trees = 0,               # a place to dump results
  min_RMSE = 0,
  CCC =0 # a place to dump results
)
# total number of combinations
nrow(hyper_grid)</code></pre>
<pre><code>## [1] 192</code></pre>
<pre class="r"><code># randomize data
set.seed(123)
train=sample(x = 1:length(all_data_spread_plb$sev), 
             size = round(0.80*length(all_data_spread_plb$sev),1))

# grid search 
for(i in 1:nrow(hyper_grid)) {

# reproducibility
set.seed(123)


 # train model
gbm.tune &lt;- gbm(
  formula = sev ~BGI+BI+GLI+HI+HUE+NGRDI+VARI+gray+ Red+Green+Blue  + SI + SCI, 
  data = all_data_spread_plb[train,],
  distribution = &quot;gaussian&quot;,
  n.trees = 5000,
  interaction.depth = hyper_grid$interaction.depth[i],
  shrinkage = hyper_grid$shrinkage[i],
  n.minobsinnode = hyper_grid$n.minobsinnode[i],
  bag.fraction = hyper_grid$bag.fraction[i],
  train.fraction = .75,
  n.cores = NULL, # will use all cores by default
  verbose = FALSE)

pred = predict(gbm.tune, newdata = all_data_spread_plb[-train,-1], ntrees = 5000 )
 # add min training error and trees to grid
  hyper_grid$optimal_trees[i] &lt;- which.min(gbm.tune$valid.error)
  hyper_grid$min_RMSE[i] &lt;- sqrt(min(gbm.tune$valid.error))
  hyper_grid$CCC[i] = CCC((pred), all_data_spread_plb$sev[-train])$rho.c$est
  
}

best_par = hyper_grid %&gt;% 
  dplyr::arrange(-CCC) %&gt;%
  head(10)
best_par</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["shrinkage"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["interaction.depth"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["n.minobsinnode"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["bag.fraction"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["optimal_trees"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["min_RMSE"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["CCC"],"name":[7],"type":["dbl"],"align":["right"]}],"data":[{"1":"0.100","2":"3","3":"5","4":"0.80","5":"32","6":"11.43165","7":"0.8969288","_rn_":"1"},{"1":"0.100","2":"6","3":"5","4":"0.65","5":"32","6":"11.52381","7":"0.8928580","_rn_":"2"},{"1":"0.100","2":"3","3":"5","4":"0.50","5":"32","6":"11.24831","7":"0.8870234","_rn_":"3"},{"1":"0.100","2":"5","3":"5","4":"0.50","5":"31","6":"11.81925","7":"0.8837066","_rn_":"4"},{"1":"0.001","2":"3","3":"5","4":"0.65","5":"3641","6":"12.00226","7":"0.8829091","_rn_":"5"},{"1":"0.010","2":"3","3":"5","4":"0.65","5":"400","6":"11.96944","7":"0.8823258","_rn_":"6"},{"1":"0.100","2":"6","3":"5","4":"0.50","5":"46","6":"11.54810","7":"0.8820699","_rn_":"7"},{"1":"0.100","2":"3","3":"5","4":"0.65","5":"69","6":"11.34887","7":"0.8818385","_rn_":"8"},{"1":"0.001","2":"3","3":"5","4":"0.50","5":"3709","6":"12.00293","7":"0.8815219","_rn_":"9"},{"1":"0.300","2":"5","3":"5","4":"1.00","5":"9","6":"12.74006","7":"0.8813283","_rn_":"10"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code># gbm.tune$fit</code></pre>
</div>
<div id="best-model-3" class="section level3">
<h3>Best model</h3>
<pre class="r"><code># for reproducibility
set.seed(123)

# train GBM model
gbm.fit.final_plb &lt;- gbm(
  formula = sev ~BGI+BI+GLI+HI+HUE+NGRDI+VARI+gray+ Red+Green+Blue  + SI + SCI, 
  data = all_data_spread_plb[train,],
  distribution = &quot;gaussian&quot;,
  n.trees = best_par$optimal_trees[1],
  interaction.depth = best_par$interaction.depth[1],
  shrinkage = best_par$shrinkage[1],
  n.minobsinnode = best_par$n.minobsinnode[1],
  bag.fraction = best_par$bag.fraction[1], 
  train.fraction =0.75,
  n.cores = NULL, # will use all cores by default
  verbose = FALSE
  )</code></pre>
</div>
<div id="relative-influence-3" class="section level3">
<h3>Relative influence</h3>
<pre class="r"><code>par(mar = c(5, 8, 1, 1))
summary_gbm_plb = summary(
  gbm.fit.final_plb, 
  cBars = 13,
  method = relative.influence, # also can use permutation.test.gbm
  las = 2
  )</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-121-1.png" width="672" /></p>
<pre class="r"><code>rel_plb = summary_gbm_plb  %&gt;% 
  rownames_to_column(&quot;index&quot;) %&gt;% 
  ggplot(aes(rel.inf, reorder(var, rel.inf)))+
  geom_col(aes(fill =rel.inf&gt;1, color =rel.inf&gt;1 ), width = 0.85)+
  theme_minimal_vgrid()+
  labs(x = &quot;Relative influence (%)&quot;,
       y = &quot;Model predictors&quot;,
       fill = &quot;RI &gt; 1%&quot;,
       color = &quot;RI &gt; 1%&quot;)
rel_plb</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-121-2.png" width="672" /></p>
<pre class="r"><code># ggsave(&quot;figs/var_influence.png&quot;,dpi = 600, height = 4, width = 6)</code></pre>
<p>Partial dependence plots</p>
<pre class="r"><code>gbm.fit.final_plb %&gt;%
  pdp::partial(pred.var = &quot;BGI&quot;, n.trees = gbm.fit.final_plb$n.trees, grid.resolution = 100) %&gt;%
  ggplot(aes( BGI,(yhat)))+
  geom_line()</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-122-1.png" width="672" /></p>
<p>LIME</p>
<pre class="r"><code>library(lime)</code></pre>
<pre class="r"><code>model_type.gbm &lt;- function(x, ...) {
  return(&quot;regression&quot;)
}

predict_model.gbm &lt;- function(x, newdata, ...) {
  pred &lt;- predict(x, newdata, n.trees = x$n.trees)
  return(as.data.frame(pred))
}</code></pre>
<pre class="r"><code># get a few observations to perform local interpretation on
local_obs &lt;- (all_data_spread_plb[-train,])[1:4, ]

# apply LIME
explainer &lt;- lime(all_data_spread_plb[train,], gbm.fit.final_plb)
explanation &lt;- lime::explain(local_obs, explainer, n_features = 7, n.trees =1)
plot_features(explanation)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-125-1.png" width="672" /></p>
</div>
</div>
<div id="prediction-3" class="section level2">
<h2>Prediction</h2>
<pre class="r"><code># predict values for test data
pred &lt;- predict(gbm.fit.final_plb, n.trees = gbm.fit.final_plb$n.trees, all_data_spread_plb[-train,])

# results
caret::RMSE(pred, all_data_spread_plb[-train,]$sev)</code></pre>
<pre><code>## [1] 8.128485</code></pre>
<pre class="r"><code>CCC(pred, all_data_spread_plb$sev[-train])$rho.c$est</code></pre>
<pre><code>## [1] 0.8969288</code></pre>
<pre class="r"><code>cor(pred, all_data_spread_plb$sev[-train])^2</code></pre>
<pre><code>## [1] 0.8131546</code></pre>
<pre class="r"><code>accuracy_pi =data.frame(predi=pred, actual = all_data_spread_plb$sev[-train]) %&gt;% 
  summarise(RMSE = caret::RMSE(pred, actual),
            r = cor(pred, actual),
            s.shift = CCC(pred, actual)$s.shift,
            l.shift = CCC(pred, actual)$l.shift,
            C.b = CCC(pred, actual)$C.b,
            CCC = CCC(pred, actual)$rho.c$est,
            CIS = paste(
  round(CCC(pred, all_data_spread_plb$sev[-train])$rho.c[2],2),&quot;,&quot;,&quot; &quot;,
  round(CCC(pred, all_data_spread_plb$sev[-train])$rho.c[3],2),sep = &quot;&quot;
  ))
accuracy_pi</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["RMSE"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["r"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["s.shift"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["l.shift"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["C.b"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["CCC"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["CIS"],"name":[7],"type":["chr"],"align":["left"]}],"data":[{"1":"8.128485","2":"0.9017508","3":"1.106488","4":"0.02244766","5":"0.9946526","6":"0.8969288","7":"0.82, 0.94"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<div id="plot-3" class="section level4">
<h4>plot</h4>
<pre class="r"><code>conc_pi = data.frame(predict = pred, actual =all_data_spread_plb$sev[-train]) %&gt;% 
ggplot(aes(actual,predict))+
  geom_point(size =2, color = &quot;gray&quot;)+
  geom_abline(intercept = 0, slope= 1, size = .81, color = &quot;black&quot;, linetype = &quot;dashed&quot;)+
  geom_smooth(method = &quot;lm&quot;, 
              color = &quot;red&quot;,
              size =.81, se =F,
              fullrange=T)+
  theme_minimal_grid()+
  labs(x = &quot;Predicted Severity (%)&quot;,
       y = &quot;Actual Severity (%)&quot;)+
  coord_equal(xlim = c(0,100),
              ylim = c(0,100))+
  xlim(0,100)


# ggsave(&quot;figs/concordance.png&quot;, dpi = 600, height = 3.5, width = 4)</code></pre>
</div>
</div>
</div>
<div id="calonectria-leaf-blight" class="section level1">
<h1>Calonectria leaf blight</h1>
<pre class="r"><code>pics&lt;-list.files(&quot;./pics/01-Calonectria_leaf_bligth&quot;)
# length(pics)
#indices
index = c(&quot;BI&quot;,&quot;SCI&quot;,&quot;GLI&quot;,&quot;HI&quot;,&quot;SI&quot;,&quot;VARI&quot;,&quot;HUE&quot;,&quot;BGI&quot;,&quot;NGRDI&quot;)


box = data.frame()

for(i in 1:length(pics)){

EX.L1&lt;-stack(paste(&quot;./pics/01-Calonectria_leaf_bligth/&quot;,pics[i],sep = &quot;&quot;))
EX.L1&lt;-aggregate(EX.L1, fact=7)
EX.L.Shape&lt;-fieldPolygon(mosaic=EX.L1, extent=T, plot = F)

EX1.Indices&lt;- fieldIndex(mosaic = EX.L1,
                         index = index, 
                         myIndex = c(&quot;Green&quot;), plot = F)

EX.L2&lt;-fieldMask(mosaic=EX.L1,  myIndex = c(&quot;Blue&quot;), cropValue=175, cropAbove=T, plot = F)

cut = mask(EX.L1, EX.L2$newMosaic)
EX.L4&lt;-fieldIndex(mosaic=cut,
                  index =index,
                  plot =F)


df = as(EX.L4, &quot;SpatialPixelsDataFrame&quot;)
dff = as.data.frame(df) %&gt;% 
  mutate(gray = 0.299*Red+0.587*Green+0.114*Blue) %&gt;% 
  gather(c(1:(3+length(index)),15), key = &quot;index&quot;, value = &quot;value&quot; ) %&gt;%
  filter(!is.na(value),
         !is.infinite(value)) %&gt;% 
  group_by(index) %&gt;% 
  dplyr::summarise(mean = mean(value, na.rm = T),
            std = sd(value),
            Q25 = quantile(value,0.25),
            Q50 = quantile(value,0.50),
            Q75 = quantile(value,0.75)) %&gt;% 
  mutate(leaf = pics[i])


box = box %&gt;% 
  bind_rows(dff)}
length(unique(box$leaf))
write.table(box,&quot;data/indexes_calonec.txt&quot;)</code></pre>
<pre class="r"><code>box = read.table(&quot;data/indexes_calonec.txt&quot;)</code></pre>
<div id="load-sev" class="section level3">
<h3>Load sev</h3>
<pre class="r"><code>data_calo_load = gsheet2tbl(&quot;https://docs.google.com/spreadsheets/d/1D5Cn6CND8OjQwdv_AVt_sxJ0H21DjIQnfmB7HKwqYXI/edit?usp=sharing&quot;) %&gt;% 
  mutate(file = as.character(file)) %&gt;% 
  dplyr::select(file,area_total,area_doente_roxa,area_doente,sev_roxa,sev)
head(data_calo_load)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["file"],"name":[1],"type":["chr"],"align":["left"]},{"label":["area_total"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["area_doente_roxa"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["area_doente"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["sev_roxa"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["sev"],"name":[6],"type":["dbl"],"align":["right"]}],"data":[{"1":"1","2":"411776","3":"54374","4":"9384","5":"13.20475","6":"2.278909"},{"1":"2","2":"415627","3":"81757","4":"55557","5":"19.67076","6":"13.367033"},{"1":"3","2":"761523","3":"569173","4":"413002","5":"74.74141","6":"54.233687"},{"1":"4","2":"798787","3":"708346","4":"594451","5":"88.67771","6":"74.419213"},{"1":"5","2":"657200","3":"219361","4":"85449","5":"33.37812","6":"13.001978"},{"1":"6","2":"784817","3":"628389","4":"628389","5":"80.06822","6":"80.068220"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>data_calo = box %&gt;% 
  separate(leaf, into=c(&quot;file&quot;,&quot;format&quot;), sep =&quot;.jpg&quot;) %&gt;% 
  dplyr::select(-format) %&gt;% 
  full_join(data_calo_load, by=&quot;file&quot;) %&gt;% 
  mutate(sev=sev_roxa)
# data_calo

length(unique(data_calo$sev))</code></pre>
<pre><code>## [1] 300</code></pre>
<pre class="r"><code>summary(data_calo$sev)</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##  0.8715  4.4431  9.8264 16.2402 20.1989 95.4470</code></pre>
</div>
<div id="images-4" class="section level3">
<h3>Images</h3>
<pre class="r"><code>hist_sev_calo =  data_calo %&gt;% 
  pivot_wider(id_col = c(file,sev_roxa),
              names_from = index, 
              values_from =  mean) %&gt;%
  ggplot(aes(sev_roxa))+
  geom_histogram(color = &quot;white&quot;, fill = &quot;black&quot;, bins = 20)+
  theme_minimal_hgrid(font_size = 10)+
  labs(x = &quot;Severity (%)&quot;,
       y = &quot;Frequency&quot;)+
  scale_x_continuous(limits = c(-5,105), breaks = seq(0,100,25))+
  # theme_void()+
  # coord_fixed()+
  theme(panel.background = element_rect(color = &quot;black&quot;),
        axis.title.y = element_text(size=8))</code></pre>
<pre class="r"><code>EX.L1&lt;-stack(paste(&quot;./pics/01-Calonectria_leaf_bligth/&quot;,&quot;57.jpg&quot;,sep = &quot;&quot;))
EX.L1&lt;-aggregate(EX.L1, fact=7)
EX.L.Shape&lt;-fieldPolygon(mosaic=EX.L1, extent=T, plot = F)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;</code></pre>
<pre class="r"><code># EX1.Indices&lt;- fieldIndex(mosaic = EX.L1,
#                          index = index, 
#                          myIndex = c(&quot;Green&quot;), plot = F)

EX.L2&lt;-fieldMask(mosaic=EX.L1,  myIndex = c(&quot;Blue&quot;), cropValue=175, cropAbove=T, plot = F)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;
## [1] &quot;Mask equation myIndex=Blue&quot;</code></pre>
<pre class="r"><code>cut = mask(EX.L1, EX.L2$newMosaic)
EX.L4&lt;-fieldIndex(mosaic=cut,
                  index =index,
                  plot =F)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;</code></pre>
<pre class="r"><code># plot(EX.L4$HUE)</code></pre>
<pre class="r"><code>rgb_fig_calo = RStoolbox::ggRGB(EX.L2$newMosaic,
                 r = 1,
                 g = 2,
                 b = 3)+
  theme_map()+
  coord_fixed()+
  theme(panel.background = element_rect(color = &quot;white&quot;))</code></pre>
<pre><code>## Coordinate system already present. Adding new coordinate system, which will replace the existing one.</code></pre>
<pre class="r"><code>gli_fig_calo = as.data.frame(EX.L4$HUE, xy=TRUE, na.rm =T) %&gt;% 
  ggplot(aes(x, y, fill = HUE))+
  geom_tile()+
  scale_fill_viridis_c(option = &quot;B&quot;,direction = -1)+
  theme_map()+
  coord_fixed()+
  theme(panel.background = element_rect(color = &quot;white&quot;),
        legend.title = element_text(size = 8),
        legend.text = element_text(size = 8))

rgb_fig_calo+ gli_fig_calo</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-136-1.png" width="672" /></p>
<pre class="r"><code>rgb_fig_sbr + gli_fig_sbr + hist_sev_sbr +
  rgb_fig_xy + gli_fig_xy +hist_sev_xy+
  rgb_fig_calo + gli_fig_calo + hist_sev_calo+
  rgb_fig_wlb + gli_fig_wlb + hist_sev_WLB+
  rgb_fig_pi + gli_fig_pi + hist_sev_pi+
   plot_layout(widths = c(1, 1, 1),
               heights = c(1,1,1,1,1))+
  plot_annotation(tag_levels = &#39;A&#39;)&amp;
  theme(legend.key.size = unit(3, &#39;mm&#39;),
        legend.text = element_text(size =6))</code></pre>
<pre><code>## Warning: Removed 2 rows containing missing values (geom_bar).

## Warning: Removed 2 rows containing missing values (geom_bar).

## Warning: Removed 2 rows containing missing values (geom_bar).

## Warning: Removed 2 rows containing missing values (geom_bar).

## Warning: Removed 2 rows containing missing values (geom_bar).</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-137-1.png" width="672" /></p>
<pre class="r"><code>ggsave(&quot;figs/leaf_gli.png&quot;,dpi = 600, height = 9, width =7)</code></pre>
<pre><code>## Warning: Removed 2 rows containing missing values (geom_bar).

## Warning: Removed 2 rows containing missing values (geom_bar).

## Warning: Removed 2 rows containing missing values (geom_bar).

## Warning: Removed 2 rows containing missing values (geom_bar).

## Warning: Removed 2 rows containing missing values (geom_bar).</code></pre>
</div>
<div id="relationship-sev-indices-4" class="section level3">
<h3>Relationship sev indices</h3>
<pre class="r"><code> rgb_gg_calo =  data_calo %&gt;% 
  filter(index %in% c(&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;)) %&gt;%
    ggplot(aes(mean, sev_roxa, color = index)) + 
  # geom_text()+
  geom_point(color = &quot;gray&quot;, size  =3)+
  geom_smooth(se = F, size = 2)+
  facet_wrap(~index, scales = &quot;free_x&quot;, nrow =1)+
  scale_color_manual(values = c(&quot;steelblue&quot;,&quot;darkgreen&quot;, &quot;darkred&quot;))+
  theme_minimal_hgrid()+
  labs(x = &quot;Mean value in the image&quot;,
       y = &quot;Disease severity (%)&quot;)+
  theme(panel.border = element_rect(color = &quot;gray&quot;))+
  theme(legend.position = &quot;none&quot;)
rgb_gg_calo</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-138-1.png" width="672" /></p>
<pre class="r"><code>index_gg_calo = data_calo %&gt;% 
  filter(!index %in% c(&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;)) %&gt;% 
    ggplot(aes(mean, sev_roxa, label = file)) + 
  # geom_text()+
  geom_point(color = &quot;gray&quot;, size  =3)+
  geom_smooth(color = &quot;black&quot;, se = F, size = 2)+
  facet_wrap(~index, scales = &quot;free_x&quot;, nrow =2)+
  theme_minimal_hgrid()+
  labs(x = &quot;Mean index value in the image&quot;,
       y = &quot;Disease severity (%)&quot;)+
  theme(panel.border = element_rect(color = &quot;gray&quot;))
index_gg_calo</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-139-1.png" width="672" /></p>
<pre class="r"><code>plot_grid(
  plot_grid(NULL,rgb_gg_calo,NULL, rel_widths =c(0.18,1,0.2), nrow = 1),
          index_gg_calo,
          nrow = 2,
          rel_heights = c(0.5,1))</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;
## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-140-1.png" width="672" /></p>
<pre class="r"><code>ggsave(&quot;figs/index_sev_calo.png&quot;, dpi = 500, height = 8, width = 10)</code></pre>
<pre class="r"><code>cor_calo = data_calo %&gt;% 
  group_by(index) %&gt;% 
  dplyr::summarise(cor = round(  cor.test(mean,sev_roxa, method = &quot;spearman&quot;)$estimate,3),
                   P_value = round(cor.test(mean,sev_roxa, method = &quot;spearman&quot;)$p.value,4)) %&gt;% 
  arrange(-cor)</code></pre>
<pre><code>## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties</code></pre>
<pre><code>## `summarise()` ungrouping output (override with `.groups` argument)</code></pre>
<pre class="r"><code>cor_calo</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["index"],"name":[1],"type":["chr"],"align":["left"]},{"label":["cor"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["P_value"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"HUE","2":"0.982","3":"0.0000"},{"1":"SCI","2":"0.773","3":"0.0000"},{"1":"Red","2":"0.754","3":"0.0000"},{"1":"SI","2":"0.678","3":"0.0000"},{"1":"HI","2":"0.621","3":"0.0000"},{"1":"BI","2":"0.568","3":"0.0000"},{"1":"gray","2":"0.479","3":"0.0000"},{"1":"BGI","2":"0.405","3":"0.0000"},{"1":"Blue","2":"0.360","3":"0.0000"},{"1":"Green","2":"0.065","3":"0.2643"},{"1":"GLI","2":"-0.736","3":"0.0000"},{"1":"VARI","2":"-0.743","3":"0.0000"},{"1":"NGRDI","2":"-0.773","3":"0.0000"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
</div>
<div id="spread-df-3" class="section level3">
<h3>Spread df</h3>
<pre class="r"><code>all_data_spread_calo = data_calo %&gt;% 
  pivot_wider(id_col = c(file,sev_roxa),
              names_from = index, 
              values_from =  mean) %&gt;% 
  mutate(sev = sev_roxa) %&gt;% 
  dplyr::select(-sev_roxa)

head(all_data_spread_calo)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["file"],"name":[1],"type":["chr"],"align":["left"]},{"label":["BGI"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["BI"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["Blue"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["GLI"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["gray"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["Green"],"name":[7],"type":["dbl"],"align":["right"]},{"label":["HI"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["HUE"],"name":[9],"type":["dbl"],"align":["right"]},{"label":["NGRDI"],"name":[10],"type":["dbl"],"align":["right"]},{"label":["Red"],"name":[11],"type":["dbl"],"align":["right"]},{"label":["SCI"],"name":[12],"type":["dbl"],"align":["right"]},{"label":["SI"],"name":[13],"type":["dbl"],"align":["right"]},{"label":["VARI"],"name":[14],"type":["dbl"],"align":["right"]},{"label":["sev"],"name":[15],"type":["dbl"],"align":["right"]}],"data":[{"1":"1","2":"0.6882197","3":"87.79606","4":"75.18746","5":"0.224798612","6":"93.79712","7":"111.2791","8":"-0.9847117","9":"-1.205552","10":"0.2649870","11":"66.57161","12":"-0.2649870","13":"-0.079926311","14":"0.4723708","15":"13.204752"},{"1":"10","2":"0.7326462","3":"151.64523","4":"109.29395","5":"0.009936558","6":"155.41167","7":"149.2397","8":"2.7492952","9":"1.303940","10":"-0.1012609","11":"185.11183","12":"0.1012609","13":"0.254983627","14":"-0.1452390","15":"90.115078"},{"1":"100","2":"0.6775662","3":"95.31257","4":"82.53846","5":"0.230691558","6":"102.41756","7":"122.0173","8":"-1.0425429","9":"-1.362278","10":"0.2736601","11":"71.51841","12":"-0.2736601","13":"-0.084985140","14":"0.5005331","15":"5.935931"},{"1":"101","2":"0.6607986","3":"97.47074","4":"79.85178","5":"0.203593527","6":"105.15663","7":"121.5156","8":"-0.4899614","9":"-1.266092","10":"0.2026749","11":"82.68859","12":"-0.2026749","13":"0.004990806","14":"0.3418387","15":"7.430647"},{"1":"102","2":"0.6307378","3":"87.31118","4":"71.86025","5":"0.257009366","6":"94.58699","7":"114.0222","8":"-1.0501503","9":"-1.347605","10":"0.2905345","11":"65.09655","12":"-0.2905345","13":"-0.067849610","14":"0.4992782","15":"6.274879"},{"1":"103","2":"0.5985339","3":"90.35100","4":"69.09128","5":"0.242727713","6":"98.69131","7":"116.9304","8":"-0.5163754","9":"-1.232165","10":"0.2332942","11":"74.16980","12":"-0.2332942","13":"0.024057502","14":"0.3770632","15":"16.696985"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
</div>
<div id="gbm-4" class="section level3">
<h3>GBM</h3>
<pre class="r"><code>train=sample(x = 1:length(all_data_spread_calo$sev), 
             size = round(0.75*length(all_data_spread_calo$sev),1))
# length(train)
gbm.fit = gbm(sev ~BGI+BI+GLI+HI+HUE+NGRDI+VARI+gray+ Red+Green+Blue  + SI + SCI,
             data = all_data_spread_calo[train,],
             distribution = &quot;gaussian&quot;,
              n.trees = 1000,
             interaction.depth = 3,
             shrinkage = 0.1,
             cv.folds = 5,
             n.cores = NULL, # will use all cores by default
             verbose = FALSE)
print(gbm.fit)</code></pre>
<pre><code>## gbm(formula = sev ~ BGI + BI + GLI + HI + HUE + NGRDI + VARI + 
##     gray + Red + Green + Blue + SI + SCI, distribution = &quot;gaussian&quot;, 
##     data = all_data_spread_calo[train, ], n.trees = 1000, interaction.depth = 3, 
##     shrinkage = 0.1, cv.folds = 5, verbose = FALSE, n.cores = NULL)
## A gradient boosted model with gaussian loss function.
## 1000 iterations were performed.
## The best cross-validation iteration was 188.
## There were 13 predictors of which 13 had non-zero influence.</code></pre>
<pre class="r"><code>sqrt(min(gbm.fit$cv.error))</code></pre>
<pre><code>## [1] 4.383517</code></pre>
<pre class="r"><code>gbm.perf(gbm.fit, method = &quot;cv&quot;)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-144-1.png" width="672" /></p>
<pre><code>## [1] 188</code></pre>
<pre class="r"><code># find index for n trees with minimum CV error</code></pre>
<pre class="r"><code>min_MSE &lt;- which.min(gbm.fit$cv.error)
sqrt(gbm.fit$cv.error[min_MSE])</code></pre>
<pre><code>## [1] 4.383517</code></pre>
<pre class="r"><code># best.iter &lt;- gbm.perf(model1, method = &quot;test&quot;)
# print(best.iter)

pred = predict(gbm.fit, newdata = all_data_spread_calo[-train,-1], ntrees = 5000 )</code></pre>
<pre><code>## Using 188 trees...</code></pre>
<pre class="r"><code>sqrt(mean(((pred)-all_data_spread_calo$sev[-train])^2))</code></pre>
<pre><code>## [1] 3.630006</code></pre>
<pre class="r"><code>CCC((pred), all_data_spread_calo$sev[-train])$rho.c$est</code></pre>
<pre><code>## [1] 0.9637904</code></pre>
<pre class="r"><code>plot((pred), (pred)-all_data_spread_calo$sev[-train])
abline(a=0,b=0)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-146-1.png" width="672" /></p>
</div>
<div id="testing-various-hyperparameters-4" class="section level3">
<h3>Testing various hyperparameters</h3>
<p>Create hyperparameter grid</p>
<pre class="r"><code>hyper_grid &lt;- expand.grid(
  shrinkage = c(.001, .01, .1, .3),
  interaction.depth = c(1, 3, 5, 6),
  n.minobsinnode = c(5, 10, 15),
  bag.fraction = c(.5,.65, .8, 1), 
  optimal_trees = 0,               # a place to dump results
  min_RMSE = 0,
  CCC =0 # a place to dump results
)
# total number of combinations
nrow(hyper_grid)</code></pre>
<pre><code>## [1] 192</code></pre>
<pre class="r"><code># randomize data
set.seed(1234)
train=sample(x = 1:length(all_data_spread_calo$sev), 
             size = round(0.80*length(all_data_spread_calo$sev),1))

# grid search 
for(i in 1:nrow(hyper_grid)) {

# reproducibility
set.seed(123)


 # train model
gbm.tune &lt;- gbm(
  formula = sev ~BGI+BI+GLI+HI+HUE+NGRDI+VARI+gray+ Red+Green+Blue  + SI + SCI, 
  data = all_data_spread_calo[train,],
  distribution = &quot;gaussian&quot;,
  n.trees = 5000,
  interaction.depth = hyper_grid$interaction.depth[i],
  shrinkage = hyper_grid$shrinkage[i],
  n.minobsinnode = hyper_grid$n.minobsinnode[i],
  bag.fraction = hyper_grid$bag.fraction[i],
  train.fraction = .75,
  n.cores = NULL, # will use all cores by default
  verbose = FALSE)

pred = predict(gbm.tune, newdata = all_data_spread_calo[-train,-1], ntrees = 5000 )
 # add min training error and trees to grid
  hyper_grid$optimal_trees[i] &lt;- which.min(gbm.tune$valid.error)
  hyper_grid$min_RMSE[i] &lt;- sqrt(min(gbm.tune$valid.error))
  hyper_grid$CCC[i] = CCC((pred), all_data_spread_calo$sev[-train])$rho.c$est
  
}

best_par = hyper_grid %&gt;% 
  dplyr::arrange(-CCC) %&gt;%
  head(10)
best_par</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["shrinkage"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["interaction.depth"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["n.minobsinnode"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["bag.fraction"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["optimal_trees"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["min_RMSE"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["CCC"],"name":[7],"type":["dbl"],"align":["right"]}],"data":[{"1":"0.300","2":"3","3":"5","4":"1","5":"53","6":"3.188960","7":"0.9921566","_rn_":"1"},{"1":"0.100","2":"1","3":"5","4":"1","5":"843","6":"2.913543","7":"0.9917062","_rn_":"2"},{"1":"0.010","2":"1","3":"5","4":"1","5":"4991","6":"3.008064","7":"0.9912300","_rn_":"3"},{"1":"0.300","2":"1","3":"5","4":"1","5":"262","6":"3.429057","7":"0.9907054","_rn_":"4"},{"1":"0.100","2":"3","3":"5","4":"1","5":"213","6":"2.960664","7":"0.9906812","_rn_":"5"},{"1":"0.001","2":"5","3":"5","4":"1","5":"5000","6":"3.378191","7":"0.9904229","_rn_":"6"},{"1":"0.001","2":"6","3":"5","4":"1","5":"5000","6":"3.403406","7":"0.9903718","_rn_":"7"},{"1":"0.300","2":"6","3":"5","4":"1","5":"44","6":"3.064615","7":"0.9901287","_rn_":"8"},{"1":"0.300","2":"5","3":"5","4":"1","5":"51","6":"3.177959","7":"0.9900388","_rn_":"9"},{"1":"0.001","2":"3","3":"5","4":"1","5":"5000","6":"3.297901","7":"0.9900336","_rn_":"10"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code># gbm.tune$fit</code></pre>
</div>
<div id="best-model-4" class="section level3">
<h3>Best model</h3>
<pre class="r"><code># for reproducibility
set.seed(123)

# train GBM model
gbm.fit.final_calo &lt;- gbm(
  formula = sev ~BGI+BI+GLI+HI+HUE+NGRDI+VARI+gray+ Red+Green+Blue  + SI + SCI, 
  data = all_data_spread_calo[train,],
  distribution = &quot;gaussian&quot;,
  n.trees = best_par$optimal_trees[1],
  interaction.depth = best_par$interaction.depth[1],
  shrinkage = best_par$shrinkage[1],
  n.minobsinnode = best_par$n.minobsinnode[1],
  bag.fraction = best_par$bag.fraction[1], 
  train.fraction =0.75,
  n.cores = NULL, # will use all cores by default
  verbose = FALSE
  )</code></pre>
</div>
<div id="relative-influence-4" class="section level3">
<h3>Relative influence</h3>
<pre class="r"><code>par(mar = c(5, 8, 1, 1))
summary_gbm_calo = summary(
  gbm.fit.final_calo, 
  cBars = 13,
  method = relative.influence, # also can use permutation.test.gbm
  las = 2
  )</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-150-1.png" width="672" /></p>
<pre class="r"><code>rel_calo = summary_gbm_calo %&gt;% 
  rownames_to_column(&quot;index&quot;) %&gt;% 
  ggplot(aes(rel.inf, reorder(var, rel.inf)))+
  geom_col(aes(fill =rel.inf&gt;1, color =rel.inf&gt;1 ), width = 0.85)+
  theme_minimal_vgrid()+
  labs(x = &quot;Relative influence (%)&quot;,
       y = &quot;Model predictors&quot;,
       fill = &quot;RI &gt; 1%&quot;,
       color = &quot;RI &gt; 1%&quot;)
rel_calo</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-150-2.png" width="672" /></p>
<pre class="r"><code># ggsave(&quot;figs/var_influence.png&quot;,dpi = 600, height = 4, width = 6)</code></pre>
<p>Partial dependence plots</p>
<pre class="r"><code>gbm.fit.final_calo %&gt;%
  pdp::partial(pred.var = &quot;HUE&quot;, n.trees = gbm.fit.final_calo$n.trees, grid.resolution = 100) %&gt;%
  ggplot(aes( HUE,(yhat)))+
  geom_line()</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-151-1.png" width="672" /></p>
<p>LIME</p>
<pre class="r"><code>library(lime)</code></pre>
<pre class="r"><code>model_type.gbm &lt;- function(x, ...) {
  return(&quot;regression&quot;)
}

predict_model.gbm &lt;- function(x, newdata, ...) {
  pred &lt;- predict(x, newdata, n.trees = x$n.trees)
  return(as.data.frame(pred))
}</code></pre>
<pre class="r"><code># get a few observations to perform local interpretation on
local_obs &lt;- (all_data_spread_calo[-train,])[1:4, ]

# apply LIME
explainer &lt;- lime(all_data_spread_calo[train,], gbm.fit.final_calo)
explanation &lt;- lime::explain(local_obs, explainer, n_features = 7, n.trees =1)
plot_features(explanation)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-154-1.png" width="672" /></p>
</div>
<div id="prediction-4" class="section level2">
<h2>Prediction</h2>
<pre class="r"><code># predict values for test data
pred &lt;- predict(gbm.fit.final_calo, n.trees = gbm.fit.final_calo$n.trees, all_data_spread_calo[-train,])

# results
caret::RMSE(pred, all_data_spread_calo[-train,]$sev)</code></pre>
<pre><code>## [1] 2.358233</code></pre>
<pre class="r"><code>CCC(pred, all_data_spread_calo$sev[-train])$rho.c$est</code></pre>
<pre><code>## [1] 0.9921566</code></pre>
<pre class="r"><code>cor(pred, all_data_spread_calo$sev[-train])^2</code></pre>
<pre><code>## [1] 0.9872815</code></pre>
<pre class="r"><code>accuracy_calo = data.frame(predi=pred, actual = all_data_spread_calo$sev[-train]) %&gt;% 
  summarise(RMSE = caret::RMSE(pred, actual),
            r = cor(pred, actual),
            s.shift = CCC(pred, actual)$s.shift,
            l.shift = CCC(pred, actual)$l.shift,
            C.b = CCC(pred, actual)$C.b,
            CCC = CCC(pred, actual)$rho.c$est,
            CIS = paste(
  round(CCC(pred, all_data_spread_calo$sev[-train])$rho.c[2],2),&quot;,&quot;,&quot; &quot;,
  round(CCC(pred, all_data_spread_calo$sev[-train])$rho.c[3],2),sep = &quot;&quot;
  ))
accuracy_calo</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["RMSE"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["r"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["s.shift"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["l.shift"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["C.b"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["CCC"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["CIS"],"name":[7],"type":["chr"],"align":["left"]}],"data":[{"1":"2.358233","2":"0.9936204","3":"1.047502","4":"0.02822577","5":"0.9985268","6":"0.9921566","7":"0.99, 1"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<div id="plot-4" class="section level4">
<h4>plot</h4>
<pre class="r"><code>conc_calo = data.frame(predict = pred, actual =all_data_spread_calo$sev[-train]) %&gt;% 
ggplot(aes(actual,predict))+
  geom_point(size =2, color = &quot;gray&quot;)+
  geom_abline(intercept = 0, slope= 1, size = .81, color = &quot;black&quot;, linetype = &quot;dashed&quot;)+
  geom_smooth(method = &quot;lm&quot;, 
              color = &quot;red&quot;,
              size =.81, se =F,
              fullrange=T)+
  theme_minimal_grid()+
  labs(x = &quot;Predicted Severity (%)&quot;,
       y = &quot;Actual Severity (%)&quot;)+
  coord_equal(xlim = c(0,100),
              ylim = c(0,100))+
  xlim(0,100)


# ggsave(&quot;figs/concordance.png&quot;, dpi = 600, height = 3.5, width = 4)</code></pre>
</div>
</div>
</div>
<div id="correlation" class="section level1">
<h1>Correlation</h1>
<pre class="r"><code>ind_order = c(&quot;Red&quot;,&quot;Green&quot;,&quot;Blue&quot;,&quot;BI&quot;,&quot;SCI&quot;,&quot;GLI&quot;,&quot;HI&quot;,&quot;NGRDI&quot;,&quot;SI&quot;,&quot;VARI&quot;,&quot;HUE&quot;,&quot;BGI&quot;,&quot;gray&quot;)
bind_rows(
cor_sbr %&gt;% mutate(disease=&quot;SBR&quot;),
cor_calo %&gt;% mutate(disease=&quot;CLB&quot;),
cor_xy %&gt;% mutate(disease=&quot;NtXf&quot;),
cor_wlb %&gt;% mutate(disease=&quot;WLB&quot;),
cor_PI %&gt;% mutate(disease=&quot;PLB&quot;)) %&gt;% 
  mutate(sig = case_when(P_value &lt;0.05 ~ &quot; &quot;,
                         P_value &gt;0.05 ~ &quot;P&gt;0.05&quot;)) %&gt;% 
  mutate(disease = factor(disease, levels = c(&quot;PLB&quot;, &quot;WLB&quot;,&quot;NtXf&quot;,&quot;CLB&quot;, &quot;SBR&quot;)),
         index = factor(index, levels = ind_order)) %&gt;% 
  ggplot(aes(index,disease, fill = cor, label = round(cor,3)))+
  geom_tile()+
  geom_text(size =3.5)+
  geom_point(aes(index,disease, color = sig), shape = &quot;X&quot;, size =8, alpha = 0.6)+
  # scale_fill_gradient2(low = &quot;darkred&quot;, mid = NA, high = &quot;darkgreen&quot;)+
  scale_fill_distiller(palette = &quot;RdBu&quot;, direction = 1)+
  scale_color_manual(values = c(NA,&quot;black&quot;))+
  theme_half_open()+
  labs(x = &quot;&quot;,
       y = &quot;&quot;, 
       fill = &quot;  r&quot;,
       color =&quot;&quot;)</code></pre>
<pre><code>## Warning: Removed 59 rows containing missing values (geom_point).</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-158-1.png" width="672" /></p>
<pre class="r"><code>ggsave(&quot;figs/corr.png&quot;,dpi = 600, height = 3.5, width =10)</code></pre>
<pre><code>## Warning: Removed 59 rows containing missing values (geom_point).</code></pre>
</div>
<div id="relative-influence-combo" class="section level1">
<h1>Relative influence combo</h1>
<pre class="r"><code># summary_gbm_sbr
# summary_gbm_calo
# summary_gbm_xy
# summary_gbm_wlb
# summary_gbm_plb</code></pre>
<pre class="r"><code>rel_sbr + labs(title = paste(&quot;Soybean rust&quot;))+
  rel_calo +labs(title = paste(&quot;Calonectria leaf blight&quot;))+
  rel_wlb +labs(title = paste(&quot;Wheat leaf blast&quot;))+
  rel_plb +labs(title = paste(&quot;Potato late blight&quot;))+
  rel_xy +labs(title = expression(bolditalic(&quot;N. tabacum-X. fastidiosa&quot;)))+guide_area()+
  plot_layout(ncol =3, guides = &quot;collect&quot;)+
  plot_annotation(tag_levels = &#39;A&#39;)&amp;
  theme_minimal_grid(font_size = 9)&amp;
  theme(plot.title = element_text(size =8))&amp;
  xlim(0,100)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-160-1.png" width="672" /></p>
<pre class="r"><code>ggsave(&quot;figs/relative_influence_combo.png&quot;, dpi = 300, height = 5, width = 6)</code></pre>
<pre class="r"><code>biplot_ri = function(data_cor, data_ri, title, face=&quot;plain&quot;){

data_ri %&gt;% 
  rename(index = var) %&gt;% 
  full_join(data_cor) %&gt;% 
  ggplot(aes(rel.inf,abs(cor),label = index, color = index))+
  # geom_smooth(color = &quot;gray90&quot;,se = F)+
  geom_point(size = 3)+
  ggrepel::geom_text_repel(size=3)+
  coord_cartesian(xlim = c(0,100),
                  ylim = c(0,1))+
  theme_minimal()+
  theme(legend.position = &quot;none&quot;,
        panel.grid = element_blank(),
        plot.title = element_text(size = 10, face = face),
        axis.ticks = element_line(color = &quot;gray&quot;),
        axis.line = element_line(color = &quot;gray&quot;))+
  labs(y = &quot;Absolute Spearman&#39;s r&quot;,
       x = &quot;Relative Influence (%)&quot;,
       title  = paste(title))
}</code></pre>
<pre class="r"><code>biplot_ri(data_cor = cor_sbr, data_ri = summary_gbm_sbr, title = &quot;Soybean rust&quot;)+
biplot_ri(data_cor = cor_calo, data_ri = summary_gbm_calo, title = &quot;Calonectria leaf blight&quot;)+
  biplot_ri(data_cor = cor_xy, data_ri = summary_gbm_xy, title = &quot;N. tabacum-X. fastidiosa&quot;,face = &quot;italic&quot;)+
  biplot_ri(data_cor = cor_wlb, data_ri = summary_gbm_wlb, title = &quot;Wheat leaf blast&quot;)+
  biplot_ri(data_cor = cor_PI, data_ri = summary_gbm_plb, title = &quot;Potato late blight&quot;)+
  plot_layout(nrow = 3,
              ncol = 2)+
  plot_annotation(tag_levels = &quot;A&quot;)+
ggsave(&quot;figs/ri_cor.png&quot;,dpi = 300, height = 8, width =6)</code></pre>
<pre><code>## Joining, by = &quot;index&quot;
## Joining, by = &quot;index&quot;
## Joining, by = &quot;index&quot;
## Joining, by = &quot;index&quot;
## Joining, by = &quot;index&quot;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-162-1.png" width="672" /></p>
<div id="agreement" class="section level3">
<h3>Agreement</h3>
<pre class="r"><code> conc_sbr+labs(title = paste(&quot;Soybean rust&quot;),
               subtitle = paste(&quot;RMSE = &quot;,round(accuracy_sbr$RMSE,2),&quot;, &quot;,
                                &quot;CCC = &quot;,round(accuracy_sbr$CCC,3)))+
  conc_calo+labs(title = paste(&quot;Calonectria leaf blight&quot;),
               subtitle = paste(&quot;RMSE = &quot;,round(accuracy_calo$RMSE,2),&quot;, &quot;,
                                &quot;CCC = &quot;,round(accuracy_calo$CCC,3)))+
  conc_wlb+labs(title = paste(&quot;Wheat leaf blast&quot;),
               subtitle = paste(&quot;RMSE = &quot;,round(accuracy_wlb$RMSE,2),&quot;, &quot;,
                                &quot;CCC = &quot;,round(accuracy_wlb$CCC,3)))+
  conc_pi+labs(title = paste(&quot;Potato late blight&quot;),
               subtitle = paste(&quot;RMSE = &quot;,round(accuracy_pi$RMSE,2),&quot;, &quot;,
                                &quot;CCC = &quot;,round(accuracy_pi$CCC,3)))+
  conc_xy+labs(title = expression(bolditalic(&quot;N. tabacum-X. fastidiosa&quot;)),
               subtitle = paste(&quot;RMSE = &quot;,round(accuracy_xy$RMSE,2),&quot;, &quot;,
                                &quot;CCC = &quot;,round(accuracy_xy$CCC,3)))+
  
  
   plot_layout(ncol = 3,
               widths = c(1, 1,1),
               heights = c(1,1))+

  plot_annotation(tag_levels = &#39;A&#39;)&amp;
    theme_minimal_grid(font_size = 10)&amp;
  theme(plot.title = element_text(size =10, face =&quot;bold&quot;),
      plot.subtitle = element_text(size =10, face = &quot;plain&quot;))</code></pre>
<pre><code>## `geom_smooth()` using formula &#39;y ~ x&#39;
## `geom_smooth()` using formula &#39;y ~ x&#39;
## `geom_smooth()` using formula &#39;y ~ x&#39;
## `geom_smooth()` using formula &#39;y ~ x&#39;
## `geom_smooth()` using formula &#39;y ~ x&#39;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-163-1.png" width="672" /></p>
<pre class="r"><code>ggsave(&quot;figs/concordance.png&quot;, dpi = 600, height = 6, width = 8)</code></pre>
<pre><code>## `geom_smooth()` using formula &#39;y ~ x&#39;
## `geom_smooth()` using formula &#39;y ~ x&#39;
## `geom_smooth()` using formula &#39;y ~ x&#39;
## `geom_smooth()` using formula &#39;y ~ x&#39;
## `geom_smooth()` using formula &#39;y ~ x&#39;</code></pre>
</div>
</div>
<div id="rgb-bands-by-leaf" class="section level1">
<h1>RGB bands by leaf</h1>
<div id="function" class="section level4">
<h4>Function</h4>
<pre class="r"><code>density_rgb2 = function(
file_low = &quot;./pics/01-soybean-rust-bg-blue/Ferrugem 52_Median.jpg&quot;,
file_high = &quot;./pics/01-soybean-rust-bg-blue/Ferrugem 49_Median.jpg&quot;,
limiar = 100,
index_cut = &quot;Blue&quot;,
cropAbove=T,
title = &quot;Soybean Rust&quot;,face = &quot;plain&quot;){

#-------------------------------------------------------------------------------------------------
SBR_low_EX.L1&lt;-stack(paste(file_low ))
SBR_low_EX.L1&lt;-aggregate(SBR_low_EX.L1, fact=5)

SBR_low_EX.L2&lt;-fieldMask(mosaic=SBR_low_EX.L1, myIndex = c(index_cut), cropValue=limiar, cropAbove=cropAbove, plot = F)

cut = mask(SBR_low_EX.L1, SBR_low_EX.L2$newMosaic)
SBR_low_EX.L4&lt;-fieldIndex(mosaic=cut,
                  # index =index,
                  plot =F)

SBR_low = RStoolbox::ggRGB(SBR_low_EX.L2$newMosaic,r = 1,g = 2,b = 3)+
  theme_map()+coord_fixed()+
  theme(panel.background = element_rect(color = NA, fill = NA),
        plot.title = element_text(size=8, face = &quot;plain&quot;))+
  labs(title = &quot;Low&quot;)

SBR_low_comb = data.frame(R = as.data.frame(SBR_low_EX.L4$Red),
           G = as.data.frame(SBR_low_EX.L4$Blue),
           B = as.data.frame(SBR_low_EX.L4$Green)) %&gt;%
  na.omit() %&gt;% 
  pivot_longer(1:3,names_to = &quot;band&quot;, values_to = &quot;value&quot;) %&gt;%
  mutate(sev=&quot;Low&quot;)
#-------------------------------------------------------------------------------------------------

SBR_high_EX.L1&lt;-stack(paste(file_high))
SBR_high_EX.L1&lt;-aggregate(SBR_high_EX.L1, fact=5)

SBR_high_EX.L2&lt;-fieldMask(mosaic=SBR_high_EX.L1,  myIndex = c(index_cut), cropValue=limiar, cropAbove=cropAbove, plot = F)

cut = mask(SBR_high_EX.L1, SBR_high_EX.L2$newMosaic)
SBR_high_EX.L4&lt;-fieldIndex(mosaic=cut,
                  # index =index,
                  plot =F)

SBR_high = RStoolbox::ggRGB(SBR_high_EX.L2$newMosaic,r = 1,g = 2,b = 3)+
  theme_map()+coord_fixed()+
  theme(panel.background = element_rect(color = NA, fill = NA),
        plot.title = element_text(size=8, face = &quot;plain&quot;))+
  labs(title = &quot;High&quot;)

SBR_high_comb = data.frame(R = as.data.frame(SBR_high_EX.L4$Red),
           G = as.data.frame(SBR_high_EX.L4$Blue),
           B = as.data.frame(SBR_high_EX.L4$Green)) %&gt;%
  na.omit() %&gt;% 
  pivot_longer(1:3,names_to = &quot;band&quot;, values_to = &quot;value&quot;) %&gt;%
  mutate(sev=&quot;High&quot;)

#-------------------------------------------------------------------------------------------------
all_comb = bind_rows(SBR_low_comb,SBR_high_comb) %&gt;% 
  mutate(sev =factor(sev, levels =c(&quot;Low&quot;,&quot;High&quot;)))
#-------------------------------------------------------------------------------------------------

all_comb %&gt;% 
  ggplot(aes(value,sev))+
  stat_slab(aes(fill = band), alpha = 0.7)+
   stat_pointinterval(aes(color = band),
                      position = position_dodge(width = .5, preserve = &quot;single&quot;),
                     # color = &quot;gray40&quot;,
                     .width = c(0,0.95))+
  
  scale_fill_manual(values = c(&quot;blue&quot;, &quot;green&quot;,&quot;red&quot; ))+
  scale_color_manual(values = c(&quot;blue&quot;, &quot;green&quot;,&quot;red&quot; ))+
  theme_minimal()+
  xlim(0,255)+
  theme(panel.grid = element_blank(),
        plot.title = element_text(size = 10, face = face),
        axis.ticks = element_line(color = &quot;gray&quot;),
        axis.line = element_line(color = &quot;gray&quot;))+
  labs(x = &quot;Pixel intensity&quot;,
       y = &quot;Severity&quot;,
       fill =&quot;&quot;,
       title = paste(title))+  
  guides(color =F)#+
  #SBR_low+SBR_high+
  #plot_layout(widths = c(1, .2,.2))
}</code></pre>
</div>
<div id="plots" class="section level3">
<h3>plots</h3>
<div id="combo" class="section level4">
<h4>combo</h4>
<pre class="r"><code>(SBR_dist+calo_dist+xy_dist+wlb_dist+plb_dist+guide_area())+
  plot_layout(nrow = 3,
              ncol = 2,
              tag_level = &quot;keep&quot;,
              # widths = c(1,1,1,1,1),
              guides = &#39;collect&#39;)+
  plot_annotation(tag_levels = &quot;A&quot;)+
  # plot_annotation(tag_levels = list(tags2))&amp;
  theme(legend.key.size = unit(5, &#39;mm&#39;),
        legend.position = &quot;none&quot;,
        legend.text = element_text(size =10))</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-166-1.png" width="576" /></p>
<pre class="r"><code>ggsave(&quot;figs/RGB_dens2.png&quot;,dpi = 600, height = 7, width =6)</code></pre>
<pre class="r"><code>density_rgb_images = function(
file_low = &quot;./pics/01-soybean-rust-bg-blue/Ferrugem 52_Median.jpg&quot;,
file_high = &quot;./pics/01-soybean-rust-bg-blue/Ferrugem 49_Median.jpg&quot;,
limiar = 100,
index_cut = &quot;Blue&quot;,
cropAbove=T,
title = &quot;Soybean Rust&quot;,face = &quot;plain&quot;){

#-------------------------------------------------------------------------------------------------
SBR_low_EX.L1&lt;-stack(paste(file_low ))
SBR_low_EX.L1&lt;-aggregate(SBR_low_EX.L1, fact=5)

SBR_low_EX.L2&lt;-fieldMask(mosaic=SBR_low_EX.L1, myIndex = c(index_cut), cropValue=limiar, cropAbove=cropAbove, plot = F)

cut = mask(SBR_low_EX.L1, SBR_low_EX.L2$newMosaic)
SBR_low_EX.L4&lt;-fieldIndex(mosaic=cut,
                  # index =index,
                  plot =F)

SBR_low = RStoolbox::ggRGB(SBR_low_EX.L2$newMosaic,r = 1,g = 2,b = 3)+
  theme_map()+coord_fixed()+
  theme(panel.background = element_rect(color = NA, fill = NA),
        plot.title = element_text(size=8, face = &quot;plain&quot;))#+
  # labs(title = &quot;Low&quot;)

SBR_low_comb = data.frame(R = as.data.frame(SBR_low_EX.L4$Red),
           G = as.data.frame(SBR_low_EX.L4$Blue),
           B = as.data.frame(SBR_low_EX.L4$Green)) %&gt;%
  na.omit() %&gt;% 
  pivot_longer(1:3,names_to = &quot;band&quot;, values_to = &quot;value&quot;) %&gt;%
  mutate(sev=&quot;Low&quot;)
#-------------------------------------------------------------------------------------------------

SBR_high_EX.L1&lt;-stack(paste(file_high))
SBR_high_EX.L1&lt;-aggregate(SBR_high_EX.L1, fact=5)

SBR_high_EX.L2&lt;-fieldMask(mosaic=SBR_high_EX.L1,  myIndex = c(index_cut), cropValue=limiar, cropAbove=cropAbove, plot = F)

cut = mask(SBR_high_EX.L1, SBR_high_EX.L2$newMosaic)
SBR_high_EX.L4&lt;-fieldIndex(mosaic=cut,
                  # index =index,
                  plot =F)

SBR_high = RStoolbox::ggRGB(SBR_high_EX.L2$newMosaic,r = 1,g = 2,b = 3)+
  theme_map()+coord_fixed()+
  theme(panel.background = element_rect(color = NA, fill = NA),
        plot.title = element_text(size=8, face = &quot;plain&quot;))#+
  # labs(title = &quot;High&quot;)

SBR_high_comb = data.frame(R = as.data.frame(SBR_high_EX.L4$Red),
           G = as.data.frame(SBR_high_EX.L4$Blue),
           B = as.data.frame(SBR_high_EX.L4$Green)) %&gt;%
  na.omit() %&gt;% 
  pivot_longer(1:3,names_to = &quot;band&quot;, values_to = &quot;value&quot;) %&gt;%
  mutate(sev=&quot;High&quot;)

#-------------------------------------------------------------------------------------------------
all_comb = bind_rows(SBR_low_comb,SBR_high_comb) %&gt;% 
  mutate(sev =factor(sev, levels =c(&quot;Low&quot;,&quot;High&quot;)))
#-------------------------------------------------------------------------------------------------

# all_comb %&gt;% 
#   ggplot(aes(value,sev))+
#   stat_slab(aes(fill = band), alpha = 0.7)+
#    stat_pointinterval(aes(color = band),
#                       position = position_dodge(width = .5, preserve = &quot;single&quot;),
#                      # color = &quot;gray40&quot;,
#                      .width = c(0,0.95))+
#   
#   scale_fill_manual(values = c(&quot;blue&quot;, &quot;green&quot;,&quot;red&quot; ))+
#   scale_color_manual(values = c(&quot;blue&quot;, &quot;green&quot;,&quot;red&quot; ))+
#   theme_minimal()+
#   xlim(0,255)+
#   theme(panel.grid = element_blank(),
#         plot.title = element_text(size = 10, face = face),
#         axis.ticks = element_line(color = &quot;gray&quot;),
#         axis.line = element_line(color = &quot;gray&quot;))+
#   labs(x = &quot;Pixel intensity&quot;,
#        y = &quot;Severity&quot;,
#        fill =&quot;&quot;,
#        title = paste(title))+  
#   guides(color =F)#+
  SBR_low|SBR_high
  #plot_layout(widths = c(1, .2,.2))
}</code></pre>
</div>
</div>
<div id="plots-1" class="section level3">
<h3>plots</h3>
<div id="combo-1" class="section level4">
<h4>combo</h4>
<pre class="r"><code>SBR_dist_img/calo_dist_img/xy_dist_img/wlb_dist_img/plb_dist_img+
  plot_layout(ncol = 1,
              nrow =5)+
  plot_annotation(tag_levels = &quot;A&quot;)&amp;
  theme(legend.text = element_text(size =10))</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-169-1.png" width="576" /></p>
<pre class="r"><code>ggsave(&quot;figs/RGB_dens_img.png&quot;,dpi = 900, height = 6, width =3)</code></pre>
</div>
</div>
<div id="principal-component-analysis" class="section level2">
<h2>Principal component analysis</h2>
<div id="sbr" class="section level3">
<h3>SBR</h3>
<pre class="r"><code>pca_sbr = PCA(all_data_spread_sbr[2:15], graph = F)
biplot_sbr = fviz_pca_biplot(pca_sbr, geom = &quot;point&quot;,
                geom.var = c(&quot;text&quot;,&quot;arrow&quot;),
                col.ind = all_data_spread_sbr$sev, 
                col.var = &quot;black&quot;,
                repel = T,
                labelsize = 2)+
  labs(title = &quot;Soybean rust&quot;)+
  scale_color_gradient(low = &quot;gray90&quot;, high = &quot;gray40&quot;, name = &quot;Severity (%)&quot;, limits =c(0,100))</code></pre>
<pre><code>## Registered S3 methods overwritten by &#39;car&#39;:
##   method                          from
##   influence.merMod                lme4
##   cooks.distance.influence.merMod lme4
##   dfbeta.influence.merMod         lme4
##   dfbetas.influence.merMod        lme4</code></pre>
</div>
<div id="calonectria" class="section level3">
<h3>Calonectria</h3>
<pre class="r"><code>pca_calo = PCA(all_data_spread_calo[2:15], graph = F)
biplot_calo = fviz_pca_biplot(pca_calo, geom = &quot;point&quot;,
                geom.var = c(&quot;text&quot;,&quot;arrow&quot;),
                col.ind = all_data_spread_calo$sev, 
                col.var = &quot;black&quot;,
                repel = T,
                labelsize = 2)+
  labs(title = &quot;Calonectria leaf blight&quot;)+
  scale_color_gradient(low = &quot;gray90&quot;, high = &quot;gray40&quot;, name = &quot;Severity (%)&quot;, limits =c(0,100))</code></pre>
</div>
<div id="ntxf" class="section level3">
<h3>NtXf</h3>
<pre class="r"><code>pca_xy = PCA(all_data_spread_xy[2:15], graph = F)
biplot_xy = fviz_pca_biplot(pca_xy,  geom = &quot;point&quot;,
                geom.var = c(&quot;text&quot;,&quot;arrow&quot;),
                col.ind = all_data_spread_xy$sev, 
                col.var = &quot;black&quot;,
                repel = T,
                labelsize = 2)+
  labs(title = expression(italic(&quot;N. tabacum-X.fastidiosa&quot;)))+
  scale_color_gradient(low = &quot;gray90&quot;, high = &quot;gray40&quot;, name = &quot;Severity (%)&quot;, limits =c(0,100))</code></pre>
</div>
<div id="wlb" class="section level3">
<h3>WLB</h3>
<pre class="r"><code>pca_wlb = PCA(all_data_spread_wlb[2:15], graph = F)

biplot_wlb = fviz_pca_biplot(pca_wlb, geom = &quot;point&quot;,
                geom.var = c(&quot;text&quot;,&quot;arrow&quot;),
                col.ind = all_data_spread_wlb$sev, 
                col.var = &quot;black&quot;,
                repel = T,
                labelsize = 2)+
  labs(title = &quot;Wheat leaf blast&quot;)+
  scale_color_gradient(low = &quot;gray90&quot;, high = &quot;gray40&quot;, name = &quot;Severity (%)&quot;, limits =c(0,100))</code></pre>
<p>###PLB</p>
<pre class="r"><code>pca_plb = PCA(all_data_spread_plb[2:15], graph = F)
biplot_plb = fviz_pca_biplot(pca_plb, geom = &quot;point&quot;,
                geom.var = c(&quot;text&quot;,&quot;arrow&quot;),
                col.ind = all_data_spread_plb$sev, 
                col.var = &quot;black&quot;,
                repel = T,
                labelsize = 2)+
  labs(title = &quot;Potato late blight&quot;)+
  scale_color_gradient(low = &quot;gray90&quot;, high = &quot;gray40&quot;, name = &quot;Severity (%)&quot;, limits =c(0,100))</code></pre>
</div>
<div id="section" class="section level3">
<h3></h3>
<pre class="r"><code>biplot_sbr+biplot_calo+biplot_xy+biplot_wlb+biplot_plb+guide_area()+
  plot_layout(ncol = 2,
              guides = &quot;collect&quot;)+
  plot_annotation(tag_levels = &quot;A&quot;)&amp;
  theme_minimal()+
  theme(#legend.position = &quot;none&quot;,
        axis.text = element_text(size=8),
        axis.title = element_text(size=8),
        plot.title = element_text(size=10),
        panel.grid = element_blank(),
        axis.ticks = element_line(color = &quot;gray&quot;),
        axis.line = element_line(color = &quot;gray&quot;))</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-175-1.png" width="576" /></p>
<pre class="r"><code>ggsave(&quot;figs/biplots.png&quot;,dpi = 600, height = 8, width =6)</code></pre>
</div>
</div>
</div>

<div id="rmd-source-code">LS0tDQp0aXRsZTogIlVudGl0bGVkIg0KYXV0aG9yOiAiS2FpcXVlIg0KZGF0ZTogIjI1LzEwLzIwMjAiDQpvdXRwdXQ6IGh0bWxfZG9jdW1lbnQNCi0tLQ0KDQojIE5lY2Vzc2FyeSBwYWNrYWdlcw0KDQpgYGB7ciBtZXNzYWdlPUZBTFNFLCB3YXJuaW5nPUZBTFNFfQ0KbGlicmFyeSh0aWR5dmVyc2UpDQpsaWJyYXJ5KEZJRUxEaW1hZ2VSKQ0KbGlicmFyeShyYXN0ZXIpDQpsaWJyYXJ5KHJlYWR4bCkNCmxpYnJhcnkoZ3NoZWV0KQ0KbGlicmFyeShmb3JlYWNoKQ0KbGlicmFyeShhZ3JpY29sYWUpDQpsaWJyYXJ5KHJlc2hhcGUyKQ0KbGlicmFyeShjb3dwbG90KQ0KbGlicmFyeShnYm0pDQpsaWJyYXJ5KGxpbWUpDQpsaWJyYXJ5KGxtZTQpDQpsaWJyYXJ5KERlc2NUb29scykNCmxpYnJhcnkoZmFjdG9leHRyYSkNCmxpYnJhcnkoRmFjdG9NaW5lUikNCmxpYnJhcnkoY29ycnBsb3QpDQpsaWJyYXJ5KG1hZ2ljaykNCmxpYnJhcnkocGF0Y2h3b3JrKQ0KbGlicmFyeShmb3JjYXRzKQ0KbGlicmFyeShnZ2Rpc3QpDQpgYGANCg0KIyBFeGFtcGxlIG9mIFJHQiBpbmRpY2VzIGZvciBvbmUgaW1hZ2UNCg0KTG9hZCBwaWN0dXJlcyBuYW1lcw0KDQpgYGB7cn0NCnBpY3M8LWxpc3QuZmlsZXMoIi4vcGljcy8wMS1zb3liZWFuLXJ1c3QtYmctYmx1ZSIpDQpsZW5ndGgocGljcykNCiMgd3JpdGUocGljcywgInBpY3NfbmFtZXMudHh0IikNCg0KYGBgDQoNCkxpc3Qgb2YgUkdCLWJhc2VkIHNwZWN0cmFsIGluZGljZXMgdG8gYmUgY2FsY3VsYXRlZCBpbiB0aGUgaW1hZ2UNCg0KYGBge3J9DQojIFZlZ2V0YXRpb24gaW5kaWNlcw0KaW5kZXggPSBjKCJCSSIsIlNDSSIsIkdMSSIsIkhJIiwiU0kiLCJWQVJJIiwiSFVFIiwiQkdJIiwiTkdSREkiKQ0KYGBgDQoNCkxvYWQgYSBzaW5nbGUgaW1hZ2UNCg0KYGBge3J9DQojQ2hvb3NlIG9uZSBpbWFnZSB0byBwcmVwYXJlIHRoZSBwaXBlbGluZQ0KRVguTDE8LXN0YWNrKHBhc3RlKCIuL3BpY3MvMDEtc295YmVhbi1ydXN0LWJnLWJsdWUvIixwaWNzWzExMF0sc2VwID0gIiIpKQ0KRVguTDE8LWFnZ3JlZ2F0ZShFWC5MMSwgZmFjdD03KQ0KRVguTC5TaGFwZTwtZmllbGRQb2x5Z29uKG1vc2FpYz1FWC5MMSwgZXh0ZW50PVQsIHBsb3QgPVQpDQojIHBsb3RSR0IoRVguTC5TaGFwZSkNCmBgYA0KDQpgYGB7cn0NCkVYMS5JbmRpY2VzPC0gZmllbGRJbmRleChtb3NhaWMgPSBFWC5MMSwNCiAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGluZGV4LCANCiAgICAgICAgICAgICAgICAgICAgICAgICBteUluZGV4ID0gYygiQmx1ZSIpLCBwbG90ID0gVCkNCmBgYA0KDQpgYGB7cn0NCnBsb3QoRVgxLkluZGljZXMkQmx1ZSkNCmhpc3QoRVgxLkluZGljZXMkQmx1ZSkNCmBgYA0KDQojIyMgbWFzaw0KDQpgYGB7cn0NCiMgRVguTDI8LWZpZWxkTWFzayhtb3NhaWM9RVguTDEsIG15SW5kZXggPSAiUmVkIiwgY3JvcFZhbHVlPTIwMCwgY3JvcEFib3ZlPVQsIHBsb3QgPSBUKQ0KIyBFWC5MMjwtZmllbGRNYXNrKG1vc2FpYz1FWC5MMSwgaW5kZXggPSAiQkkiLCBjcm9wVmFsdWU9MSwgY3JvcEFib3ZlPUYsIHBsb3QgPSBUKQ0KRVguTDI8LWZpZWxkTWFzayhtb3NhaWM9RVguTDEsIG15SW5kZXggPSBjKCJCbHVlIiksIGNyb3BWYWx1ZT05MCwgY3JvcEFib3ZlPVQsIHBsb3QgPSBUKQ0KIyBwbG90UkdCKEVYLkwyJG5ld01vc2FpYykNCnBsb3RSR0IoRVguTDIkbmV3TW9zYWljKQ0KDQoNCmNsYXNzKEVYLkwyJG1hc2spDQpgYGANCg0KYGBge3J9DQpyZ2JfZmlnID0gUlN0b29sYm94OjpnZ1JHQihFWC5MMiRuZXdNb3NhaWMsDQogICAgICAgICAgICAgICAgIHIgPSAxLA0KICAgICAgICAgICAgICAgICBnID0gMiwNCiAgICAgICAgICAgICAgICAgYiA9IDMpKw0KICB0aGVtZV92b2lkKCkrDQogIGNvb3JkX2ZpeGVkKCkNCmBgYA0KDQpgYGB7cn0NCmN1dCA9IG1hc2soRVguTDEsIEVYLkwyJG5ld01vc2FpYykNCnBsb3QoY3V0KQ0KDQpFWC5MNDwtZmllbGRJbmRleChtb3NhaWM9Y3V0LA0KICAgICAgICAgICAgICAgICAgaW5kZXggPSBpbmRleCkNCg0KDQoNCnBsb3QoRVguTDQkQkdJKQ0KYGBgDQoNCmBgYHtyfQ0KZ2xpX2ZpZyA9IGFzLmRhdGEuZnJhbWUoRVguTDQkTkdSREksIHh5PVRSVUUsIG5hLnJtID1UKSAlPiUgDQogIGdncGxvdChhZXMoeCwgeSwgZmlsbCA9IE5HUkRJKSkrDQogIGdlb21fdGlsZSgpKw0KICAjIHNjYWxlX2ZpbGxfZGlzdGlsbGVyKHBhbGV0dGUgPSAiU3BlY3RyYWwiLCBkaXJlY3Rpb24gPSAxKSsNCiAgc2NhbGVfZmlsbF9ncmFkaWVudDIobG93ID0gInJlZCIsIG1pZCA9ImdyZWVuIiwgaGlnaCA9ICJncmVlbiIsIG1pZHBvaW50ID0gMC4yKSsNCiAgIyBzY2FsZV9maWxsX3ZpcmlkaXNfYyhvcHRpb24gPSAiQiIsZGlyZWN0aW9uID0gLTEpKw0KICB0aGVtZV92b2lkKCkrDQogIGNvb3JkX2ZpeGVkKCkNCmBgYA0KDQpgYGB7cn0NCnBsb3RfZ3JpZChyZ2JfZmlnLCBnbGlfZmlnLCBheGlzID0gImIiLA0KICAgICAgICAgIHJlbF93aWR0aHMgPSBjKDAuOSwxKSwNCiAgICAgICAgICBsYWJlbHMgPSBjKCJSR0IiLCAiTkdSREkiKSwNCiAgICAgICAgICBzY2FsZSA9IDAuOTApDQojIGdnc2F2ZSgiZmlncy9sZWFmX2dsaS5wbmciLGRwaSA9IDYwMCwgaGVpZ2h0ID0gMywgd2lkdGggPTEwICkNCmBgYA0KDQpgYGB7cn0NCg0KZGYgPSBhcyhFWC5MNCwgIlNwYXRpYWxQaXhlbHNEYXRhRnJhbWUiKQ0KZGZmID0gYXMuZGF0YS5mcmFtZShkZikgJT4lIA0KICBnYXRoZXIoMTooMytsZW5ndGgoaW5kZXgpKSwga2V5ID0gImluZGV4IiwgdmFsdWUgPSAidmFsdWUiICkgJT4lDQogIGZpbHRlcighaXMubmEodmFsdWUpLA0KICAgICAgICAgIWlzLmluZmluaXRlKHZhbHVlKSkgJT4lIA0KICBncm91cF9ieShpbmRleCkgJT4lIA0KICBzdW1tYXJpc2UobWVhbiA9IG1lYW4odmFsdWUsIG5hLnJtID0gVCksDQogICAgICAgICAgICBzdGQgPSBzZCh2YWx1ZSksDQogICAgICAgICAgICBRMjUgPSBxdWFudGlsZSh2YWx1ZSwwLjI1KSwNCiAgICAgICAgICAgIFE1MCA9IHF1YW50aWxlKHZhbHVlLDAuNTApLA0KICAgICAgICAgICAgUTc1ID0gcXVhbnRpbGUodmFsdWUsMC43NSkpICU+JSANCiAgbXV0YXRlKGxlYWYgPSBwaWNzWzMwXSkNCmBgYA0KDQojIFdoZWF0IGxlYWYgYmxhc3QNCg0KYGBge3IgZXZhbD1GQUxTRSwgaW5jbHVkZT1UUlVFfQ0KcGljczwtbGlzdC5maWxlcygiLi9waWNzLzAxLVdoZWF0X2xlYWZfYmxhc3QiKQ0KIyBsZW5ndGgocGljcykNCiNpbmRpY2VzDQppbmRleCA9IGMoIkJJIiwiU0NJIiwiR0xJIiwiSEkiLCJTSSIsIlZBUkkiLCJIVUUiLCJCR0kiLCJOR1JESSIpDQoNCg0KYm94ID0gZGF0YS5mcmFtZSgpDQoNCmZvcihpIGluIDE6bGVuZ3RoKHBpY3MpKXsNCg0KRVguTDE8LXN0YWNrKHBhc3RlKCIuL3BpY3MvMDEtV2hlYXRfbGVhZl9ibGFzdC8iLHBpY3NbaV0sc2VwID0gIiIpKQ0KRVguTDE8LWFnZ3JlZ2F0ZShFWC5MMSwgZmFjdD0xMCkNCkVYLkwuU2hhcGU8LWZpZWxkUG9seWdvbihtb3NhaWM9RVguTDEsIGV4dGVudD1ULCBwbG90ID0gRikNCg0KRVgxLkluZGljZXM8LSBmaWVsZEluZGV4KG1vc2FpYyA9IEVYLkwxLA0KICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaW5kZXgsIA0KICAgICAgICAgICAgICAgICAgICAgICAgIG15SW5kZXggPSBjKCJHcmVlbiIpLCBwbG90ID0gRikNCg0KRVguTDI8LWZpZWxkTWFzayhtb3NhaWM9RVguTDEsICBteUluZGV4ID0gYygiQmx1ZSIpLCBjcm9wVmFsdWU9MTgwLCBjcm9wQWJvdmU9VCwgcGxvdCA9IEYpDQoNCmN1dCA9IG1hc2soRVguTDEsIEVYLkwyJG5ld01vc2FpYykNCkVYLkw0PC1maWVsZEluZGV4KG1vc2FpYz1jdXQsDQogICAgICAgICAgICAgICAgICBpbmRleCA9aW5kZXgsDQogICAgICAgICAgICAgICAgICBwbG90ID1GKQ0KDQoNCmRmID0gYXMoRVguTDQsICJTcGF0aWFsUGl4ZWxzRGF0YUZyYW1lIikNCmRmZiA9IGFzLmRhdGEuZnJhbWUoZGYpICU+JSANCiAgbXV0YXRlKGdyYXkgPSAwLjI5OSpSZWQrMC41ODcqR3JlZW4rMC4xMTQqQmx1ZSkgJT4lIA0KICBnYXRoZXIoYygxOigzK2xlbmd0aChpbmRleCkpLDE1KSwga2V5ID0gImluZGV4IiwgdmFsdWUgPSAidmFsdWUiICkgJT4lDQogIGZpbHRlcighaXMubmEodmFsdWUpLA0KICAgICAgICAgIWlzLmluZmluaXRlKHZhbHVlKSkgJT4lIA0KICBncm91cF9ieShpbmRleCkgJT4lIA0KICBkcGx5cjo6c3VtbWFyaXNlKG1lYW4gPSBtZWFuKHZhbHVlLCBuYS5ybSA9IFQpLA0KICAgICAgICAgICAgc3RkID0gc2QodmFsdWUpLA0KICAgICAgICAgICAgUTI1ID0gcXVhbnRpbGUodmFsdWUsMC4yNSksDQogICAgICAgICAgICBRNTAgPSBxdWFudGlsZSh2YWx1ZSwwLjUwKSwNCiAgICAgICAgICAgIFE3NSA9IHF1YW50aWxlKHZhbHVlLDAuNzUpKSAlPiUgDQogIG11dGF0ZShsZWFmID0gcGljc1tpXSkNCg0KDQpib3ggPSBib3ggJT4lIA0KICBiaW5kX3Jvd3MoZGZmKX0NCmxlbmd0aCh1bmlxdWUoYm94JGxlYWYpKQ0Kd3JpdGUudGFibGUoYm94LCJkYXRhL2luZGV4ZXNfV0xCLnR4dCIpDQpgYGANCg0KYGBge3J9DQpib3ggPSByZWFkLnRhYmxlKCJkYXRhL2luZGV4ZXNfV0xCLnR4dCIpDQpgYGANCg0KIyBMb2FkIHNldmVyaXR5IGRhdGENCg0KYGBge3J9DQojIHNldl9kYXRhID0gZ3NoZWV0MnRibCgiaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vc3ByZWFkc2hlZXRzL2QvMTA2c2dfTzhEZUFMWnBXbnhFUlFOZ2s4VUtnc0ZiaG9iV3dybDRKWE96Ym8vZWRpdCNnaWQ9MCIpDQoNCg0Kc2V2ID0gZ3NoZWV0MnRibCgiaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vc3ByZWFkc2hlZXRzL2QvMTA2c2dfTzhEZUFMWnBXbnhFUlFOZ2s4VUtnc0ZiaG9iV3dybDRKWE96Ym8vZWRpdCNnaWQ9MCIpDQojIHNldg0KDQoNCmJsYXN0X2RhdGEgPSBnc2hlZXQydGJsKCJodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9zcHJlYWRzaGVldHMvZC8xS25KOU44anFLUE1qQ3Q4akNMdjdPcVlMOWhMeVllSzh3a0dFQm1sR1NWSS9lZGl0P3VzcD1zaGFyaW5nIikgJT4lIA0KICBkcGx5cjo6c2VsZWN0KGNvZGUsIGNpdHksIHJlZ2lvbiwgcG9zaXRpb25fd2hlYXQsIGhvc3Qsc3BlY2llcykNCiMgYmxhc3RfZGF0YQ0KDQpzZXZfZGF0YSA9IGZ1bGxfam9pbihzZXYsIGJsYXN0X2RhdGEsIGJ5ID0gImNvZGUiKSAlPiUgDQogIG11dGF0ZShuID0gc2VxKDE6MTEyMykpICU+JSANCiAgZmlsdGVyKG48MjAxKSAlPiUgDQogIGRwbHlyOjpzZWxlY3QoLW4pICU+JSANCiAgDQogIGRwbHlyOjpzZWxlY3QocGljX25hbWUsIHNldikNCiMgc2V2X2RhdGENCg0KDQpsZW5ndGgodW5pcXVlKHNldiRwaWNfbmFtZSkpDQpgYGANCg0KYGBge3J9DQphbGxfZGF0YSA9IGJveCAlPiUNCiAgc2VwYXJhdGUobGVhZiwgaW50byA9IGMoInBpY19uYW1lIiwgImpwZyIpLCBzZXAgPSAiLmpwZyIpICU+JQ0KICAjIHNlcGFyYXRlKHBpY19uYW1lLCBpbnRvID0gYygiaGgiLCAiaXNvbGF0ZSIsInJlcHAiKSwgc2VwID0gIl8iLCByZW1vdmUgPSBGKSAlPiUNCiAgZHBseXI6OnNlbGVjdCgtanBnKSAlPiUgDQogIGZ1bGxfam9pbihzZXZfZGF0YSkgJT4lIA0KICAjIGZpbHRlcihzZXY+MCkgJT4lIA0KICBtdXRhdGUoc2V2ID0gY2FzZV93aGVuKHNldj09MCB+MC4wMSwNCiAgICAgICAgICAgICAgICAgICAgICAgICBzZXYgPjAgfnNldikpICU+JSANCiAgZmlsdGVyKCFpcy5uYShpbmRleCkpICU+JSANCiAgbXV0YXRlKHNldiA9IHNldikNCmxlbmd0aCh1bmlxdWUoYWxsX2RhdGEkcGljX25hbWUpKQ0KIyBsZW5ndGgodW5pcXVlKGJveCRsZWFmKSkNCmBgYA0KYGBge3J9DQpzdW1tYXJ5KHNldiRzZXYpDQpgYGANCg0KIyMjIEltYWdlcw0KDQpgYGB7cn0NCmhpc3Rfc2V2X1dMQiA9ICBzZXYgJT4lIA0KICBnZ3Bsb3QoYWVzKHNldikpKw0KICBnZW9tX2hpc3RvZ3JhbShjb2xvciA9ICJ3aGl0ZSIsIGZpbGwgPSAiYmxhY2siLCBiaW5zID0gMjApKw0KICB0aGVtZV9taW5pbWFsX2hncmlkKGZvbnRfc2l6ZSA9IDEwKSsNCiAgbGFicyh4ID0gIlNldmVyaXR5ICglKSIsDQogICAgICAgeSA9ICJGcmVxdWVuY3kiKSsNCiAgc2NhbGVfeF9jb250aW51b3VzKGxpbWl0cyA9IGMoLTUsMTA1KSwgYnJlYWtzID0gc2VxKDAsMTAwLDI1KSkrDQogICMgdGhlbWVfdm9pZCgpKw0KICAjIGNvb3JkX2ZpeGVkKCkrDQogIHRoZW1lKHBhbmVsLmJhY2tncm91bmQgPSBlbGVtZW50X3JlY3QoY29sb3IgPSAiYmxhY2siKSwNCiAgICAgICAgYXhpcy50aXRsZS55ID0gZWxlbWVudF90ZXh0KHNpemU9OCkpDQpoaXN0X3Nldl9XTEINCg0KDQpgYGANCg0KYGBge3J9DQpFWC5MMTwtc3RhY2socGFzdGUoIi4vcGljcy8wMS1XaGVhdF9sZWFmX2JsYXN0LyIsIkdfNzU4X1IyLmpwZyIsc2VwID0gIiIpKQ0KRVguTDE8LWFnZ3JlZ2F0ZShFWC5MMSwgZmFjdD0xMCkNCkVYLkwuU2hhcGU8LWZpZWxkUG9seWdvbihtb3NhaWM9RVguTDEsIGV4dGVudD1ULCBwbG90ID0gRikNCg0KRVgxLkluZGljZXM8LSBmaWVsZEluZGV4KG1vc2FpYyA9IEVYLkwxLA0KICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaW5kZXgsIA0KICAgICAgICAgICAgICAgICAgICAgICAgIG15SW5kZXggPSBjKCJHcmVlbiIpLCBwbG90ID0gRikNCg0KRVguTDI8LWZpZWxkTWFzayhtb3NhaWM9RVguTDEsICBteUluZGV4ID0gYygiQmx1ZSIpLCBjcm9wVmFsdWU9MTgwLCBjcm9wQWJvdmU9VCwgcGxvdCA9IEYpDQoNCmN1dCA9IG1hc2soRVguTDEsIEVYLkwyJG5ld01vc2FpYykNCkVYLkw0PC1maWVsZEluZGV4KG1vc2FpYz1jdXQsDQogICAgICAgICAgICAgICAgICBpbmRleCA9aW5kZXgsDQogICAgICAgICAgICAgICAgICBwbG90ID1GKQ0KIyBwbG90KEVYLkw0JE5HUkRJKQ0KDQpgYGANCg0KYGBge3J9DQpyZ2JfZmlnX3dsYiA9IFJTdG9vbGJveDo6Z2dSR0IoRVguTDIkbmV3TW9zYWljLA0KICAgICAgICAgICAgICAgICByID0gMSwNCiAgICAgICAgICAgICAgICAgZyA9IDIsDQogICAgICAgICAgICAgICAgIGIgPSAzKSsNCiAgdGhlbWVfbWFwKCkrDQogIGNvb3JkX2ZpeGVkKCkrDQogIHRoZW1lKHBhbmVsLmJhY2tncm91bmQgPSBlbGVtZW50X3JlY3QoY29sb3IgPSAid2hpdGUiKSkNCg0KDQpnbGlfZmlnX3dsYiA9IGFzLmRhdGEuZnJhbWUoRVguTDQkVkFSSSwgeHk9VFJVRSwgbmEucm0gPVQpICU+JSANCiAgZ2dwbG90KGFlcyh4LCB5LCBmaWxsID0gVkFSSSkpKw0KICBnZW9tX3RpbGUoKSsNCiAgc2NhbGVfZmlsbF92aXJpZGlzX2Mob3B0aW9uID0gIkIiLGRpcmVjdGlvbiA9IC0xKSsNCiAgdGhlbWVfbWFwKCkrDQogIGNvb3JkX2ZpeGVkKCkrDQogIHRoZW1lKHBhbmVsLmJhY2tncm91bmQgPSBlbGVtZW50X3JlY3QoY29sb3IgPSAid2hpdGUiKSwNCiAgICAgICAgbGVnZW5kLnRpdGxlID0gZWxlbWVudF90ZXh0KHNpemUgPSA4KSwNCiAgICAgICAgbGVnZW5kLnRleHQgPSBlbGVtZW50X3RleHQoc2l6ZSA9IDgpKQ0KYGBgDQoNCmBgYHtyfQ0KIyBwbG90X2dyaWQocmdiX2ZpZywgZ2xpX2ZpZywgYXhpcyA9ICJiIiwNCiMgICAgICAgICAgIHJlbF93aWR0aHMgPSBjKDAuOSwxKSwNCiMgICAgICAgICAgIGxhYmVscyA9IGMoIlJHQiIsICJOR1JESSIpLA0KIyAgICAgICAgICAgc2NhbGUgPSAwLjkwKQ0KDQpyZ2JfZmlnX3dsYiArIGdsaV9maWdfd2xiICsgaGlzdF9zZXZfV0xCDQoNCiMgZ2dzYXZlKCJmaWdzL2xlYWZfZ2xpX3dsYi5wbmciLGRwaSA9IDYwMCwgaGVpZ2h0ID0gNCwgd2lkdGggPTEyKQ0KYGBgDQoNCiMjIyBSZWxhdGlvbnNoaXAgc2V2IGluZGljZXMNCg0KYGBge3J9DQpyZ2JfZ2cgPSBhbGxfZGF0YSAlPiUgDQogIGZpbHRlcihpbmRleCAlaW4lIGMoIlJlZCIsICJCbHVlIiwgIkdyZWVuIikpICU+JSANCiAgICBnZ3Bsb3QoYWVzKG1lYW4sIHNldiwgY29sb3IgPSBpbmRleCkpICsgDQogICMgZ2VvbV90ZXh0KCkrDQogIGdlb21fcG9pbnQoY29sb3IgPSAiZ3JheSIsIHNpemUgID0zKSsNCiAgZ2VvbV9zbW9vdGgoc2UgPSBGLCBzaXplID0gMikrDQogIGZhY2V0X3dyYXAofmluZGV4LCBzY2FsZXMgPSAiZnJlZV94IiwgbnJvdyA9MSkrDQogIHNjYWxlX2NvbG9yX21hbnVhbCh2YWx1ZXMgPSBjKCJzdGVlbGJsdWUiLCJkYXJrZ3JlZW4iLCAiZGFya3JlZCIpKSsNCiAgdGhlbWVfbWluaW1hbF9oZ3JpZCgpKw0KICBsYWJzKHggPSAiTWVhbiB2YWx1ZSBpbiB0aGUgaW1hZ2UiLA0KICAgICAgIHkgPSAiRGlzZWFzZSBzZXZlcml0eSAoJSkiKSsNCiAgdGhlbWUocGFuZWwuYm9yZGVyID0gZWxlbWVudF9yZWN0KGNvbG9yID0gImdyYXkiKSkrDQogIHRoZW1lKGxlZ2VuZC5wb3NpdGlvbiA9ICJub25lIikNCnJnYl9nZw0KYGBgDQoNCmBgYHtyfQ0KaW5kZXhfZ2cgPSBhbGxfZGF0YSAlPiUgDQogIGZpbHRlcighaW5kZXggJWluJSBjKCJSZWQiLCAiQmx1ZSIsICJHcmVlbiIpKSAlPiUgDQogICAgZ2dwbG90KGFlcyhtZWFuLCBzZXYpKSArIA0KICAjIGdlb21fdGV4dCgpKw0KICBnZW9tX3BvaW50KGNvbG9yID0gImdyYXkiLCBzaXplICA9MykrDQogIGdlb21fc21vb3RoKGNvbG9yID0gImJsYWNrIiwgc2UgPSBGLCBzaXplID0gMikrDQogIGZhY2V0X3dyYXAofmluZGV4LCBzY2FsZXMgPSAiZnJlZV94IiwgbnJvdyA9MikrDQogIHRoZW1lX21pbmltYWxfaGdyaWQoKSsNCiAgbGFicyh4ID0gIk1lYW4gaW5kZXggdmFsdWUgaW4gdGhlIGltYWdlIiwNCiAgICAgICB5ID0gIkRpc2Vhc2Ugc2V2ZXJpdHkgKCUpIikrDQogIHRoZW1lKHBhbmVsLmJvcmRlciA9IGVsZW1lbnRfcmVjdChjb2xvciA9ICJncmF5IikpDQppbmRleF9nZw0KYGBgDQoNCmBgYHtyfQ0KcGxvdF9ncmlkKA0KICBwbG90X2dyaWQoTlVMTCxyZ2JfZ2csTlVMTCwgcmVsX3dpZHRocyA9YygwLjE4LDEsMC4yKSwgbnJvdyA9IDEpLA0KICAgICAgICAgIGluZGV4X2dnLA0KICAgICAgICAgIG5yb3cgPSAyLA0KICAgICAgICAgIHJlbF9oZWlnaHRzID0gYygwLjUsMSkpDQpnZ3NhdmUoImZpZ3MvaW5kZXhfc2V2X1dMQi5wbmciLCBkcGkgPSA1MDAsIGhlaWdodCA9IDgsIHdpZHRoID0gMTApDQpgYGANCg0KYGBge3J9DQpjb3Jfd2xiID0gYWxsX2RhdGEgJT4lIA0KICBncm91cF9ieShpbmRleCkgJT4lIA0KICBkcGx5cjo6c3VtbWFyaXNlKGNvciA9IHJvdW5kKCAgY29yLnRlc3QobWVhbixzZXYsIG1ldGhvZCA9ICJzcGVhcm1hbiIpJGVzdGltYXRlLDMpLA0KICAgICAgICAgICAgICAgICAgIFBfdmFsdWUgPSBjb3IudGVzdChtZWFuLHNldiwgbWV0aG9kID0gInNwZWFybWFuIikkcC52YWx1ZSkgJT4lIA0KICBhcnJhbmdlKC1jb3IpDQpjb3Jfd2xiDQpgYGANCg0KIyMjIFNwcmVhZA0KDQpgYGB7cn0NCmFsbF9kYXRhX3NwcmVhZF93bGIgPSBhbGxfZGF0YSAlPiUgDQogICMgbXV0YXRlKG5uPTE6bGVuZ3RoKGFsbF9kYXRhJHBpY19uYW1lKSkgJT4lIA0KICBwaXZvdF93aWRlcihpZF9jb2wgPSBjKHBpY19uYW1lLHNldiksDQogICAgICAgICAgICAgIG5hbWVzX2Zyb20gPSBpbmRleCwgDQogICAgICAgICAgICAgIHZhbHVlc19mcm9tID0gIG1lYW4pICAgDQpoZWFkKGFsbF9kYXRhX3NwcmVhZF93bGIpDQpgYGANCg0KIyMgR0JNDQoNCmBgYHtyfQ0KdHJhaW49c2FtcGxlKHggPSAxOmxlbmd0aChhbGxfZGF0YV9zcHJlYWRfd2xiJHNldiksIA0KICAgICAgICAgICAgIHNpemUgPSByb3VuZCgwLjc1Kmxlbmd0aChhbGxfZGF0YV9zcHJlYWRfd2xiJHNldiksMSkpDQojIGxlbmd0aCh0cmFpbikNCmdibS5maXQgPSBnYm0oc2V2IH5CR0krQkkrR0xJK0hJK0hVRStOR1JESStWQVJJK2dyYXkrIFJlZCtHcmVlbitCbHVlICArIFNJICsgU0NJLA0KICAgICAgICAgICAgIGRhdGEgPSBhbGxfZGF0YV9zcHJlYWRfd2xiW3RyYWluLF0sDQogICAgICAgICAgICAgZGlzdHJpYnV0aW9uID0gImdhdXNzaWFuIiwNCiAgICAgICAgICAgICAgbi50cmVlcyA9IDEwMDAsDQogICAgICAgICAgICAgaW50ZXJhY3Rpb24uZGVwdGggPSAzLA0KICAgICAgICAgICAgIHNocmlua2FnZSA9IDAuMSwNCiAgICAgICAgICAgICBjdi5mb2xkcyA9IDUsDQogICAgICAgICAgICAgbi5jb3JlcyA9IE5VTEwsICMgd2lsbCB1c2UgYWxsIGNvcmVzIGJ5IGRlZmF1bHQNCiAgICAgICAgICAgICB2ZXJib3NlID0gRkFMU0UpDQpwcmludChnYm0uZml0KQ0Kc3FydChtaW4oZ2JtLmZpdCRjdi5lcnJvcikpDQpgYGANCg0KYGBge3J9DQpnYm0ucGVyZihnYm0uZml0LCBtZXRob2QgPSAiY3YiKQ0KIyBmaW5kIGluZGV4IGZvciBuIHRyZWVzIHdpdGggbWluaW11bSBDViBlcnJvcg0KYGBgDQoNCmBgYHtyfQ0KbWluX01TRSA8LSB3aGljaC5taW4oZ2JtLmZpdCRjdi5lcnJvcikNCnNxcnQoZ2JtLmZpdCRjdi5lcnJvclttaW5fTVNFXSkNCg0KYGBgDQoNCmBgYHtyfQ0KIyBiZXN0Lml0ZXIgPC0gZ2JtLnBlcmYobW9kZWwxLCBtZXRob2QgPSAidGVzdCIpDQojIHByaW50KGJlc3QuaXRlcikNCg0KcHJlZCA9IHByZWRpY3QoZ2JtLmZpdCwgbmV3ZGF0YSA9IGFsbF9kYXRhX3NwcmVhZF93bGJbLXRyYWluLC0xXSwgbnRyZWVzID0gNTAwMCApDQoNCnNxcnQobWVhbigoKHByZWQpLWFsbF9kYXRhX3NwcmVhZF93bGIkc2V2Wy10cmFpbl0pXjIpKQ0KQ0NDKChwcmVkKSwgYWxsX2RhdGFfc3ByZWFkX3dsYiRzZXZbLXRyYWluXSkkcmhvLmMkZXN0DQoNCnBsb3QoKHByZWQpLCAocHJlZCktYWxsX2RhdGFfc3ByZWFkX3dsYiRzZXZbLXRyYWluXSkNCmFibGluZShhPTAsYj0wKQ0KYGBgDQoNCiMjIyBUZXN0aW5nIHZhcmlvdXMgaHlwZXJwYXJhbWV0ZXJzDQoNCkNyZWF0ZSBoeXBlcnBhcmFtZXRlciBncmlkDQoNCmBgYHtyfQ0KDQpoeXBlcl9ncmlkIDwtIGV4cGFuZC5ncmlkKA0KICBzaHJpbmthZ2UgPSBjKC4wMDEsIC4wMSwgLjEsIC4zKSwNCiAgaW50ZXJhY3Rpb24uZGVwdGggPSBjKDEsIDMsIDUsIDYpLA0KICBuLm1pbm9ic2lubm9kZSA9IGMoNSwgMTAsIDE1KSwNCiAgYmFnLmZyYWN0aW9uID0gYyguNSwuNjUsIC44LCAxKSwgDQogIG9wdGltYWxfdHJlZXMgPSAwLCAgICAgICAgICAgICAgICMgYSBwbGFjZSB0byBkdW1wIHJlc3VsdHMNCiAgbWluX1JNU0UgPSAwLA0KICBDQ0MgPTAgIyBhIHBsYWNlIHRvIGR1bXAgcmVzdWx0cw0KKQ0KIyB0b3RhbCBudW1iZXIgb2YgY29tYmluYXRpb25zDQpucm93KGh5cGVyX2dyaWQpDQpgYGANCg0KYGBge3IgbWVzc2FnZT1GQUxTRSwgd2FybmluZz1GQUxTRX0NCiMgcmFuZG9taXplIGRhdGENCnNldC5zZWVkKDEyMzQpDQp0cmFpbj1zYW1wbGUoeCA9IDE6bGVuZ3RoKGFsbF9kYXRhX3NwcmVhZF93bGIkc2V2KSwgDQogICAgICAgICAgICAgc2l6ZSA9IHJvdW5kKDAuODAqbGVuZ3RoKGFsbF9kYXRhX3NwcmVhZF93bGIkc2V2KSwxKSkNCg0KIyBncmlkIHNlYXJjaCANCmZvcihpIGluIDE6bnJvdyhoeXBlcl9ncmlkKSkgew0KDQojIHJlcHJvZHVjaWJpbGl0eQ0Kc2V0LnNlZWQoMTIzKQ0KDQoNCiAjIHRyYWluIG1vZGVsDQpnYm0udHVuZSA8LSBnYm0oDQogIGZvcm11bGEgPSAoc2V2KSB+QkdJK0JJK0dMSStISStIVUUrTkdSREkrVkFSSStncmF5ICtSZWQrR3JlZW4rQmx1ZSArIFNJICsgU0NJLCAjPDw8PDwNCiAgZGF0YSA9IGFsbF9kYXRhX3NwcmVhZF93bGJbdHJhaW4sXSwNCiAgZGlzdHJpYnV0aW9uID0gImdhdXNzaWFuIiwNCiAgbi50cmVlcyA9IDUwMDAsDQogIGludGVyYWN0aW9uLmRlcHRoID0gaHlwZXJfZ3JpZCRpbnRlcmFjdGlvbi5kZXB0aFtpXSwNCiAgc2hyaW5rYWdlID0gaHlwZXJfZ3JpZCRzaHJpbmthZ2VbaV0sDQogIG4ubWlub2JzaW5ub2RlID0gaHlwZXJfZ3JpZCRuLm1pbm9ic2lubm9kZVtpXSwNCiAgYmFnLmZyYWN0aW9uID0gaHlwZXJfZ3JpZCRiYWcuZnJhY3Rpb25baV0sDQogIHRyYWluLmZyYWN0aW9uID0gLjc1LA0KICBuLmNvcmVzID0gTlVMTCwgIyB3aWxsIHVzZSBhbGwgY29yZXMgYnkgZGVmYXVsdA0KICB2ZXJib3NlID0gRkFMU0UpDQoNCnByZWQgPSBwcmVkaWN0KGdibS50dW5lLCBuZXdkYXRhID0gYWxsX2RhdGFfc3ByZWFkX3dsYlstdHJhaW4sLTFdLCBudHJlZXMgPSA1MDAwICkNCiAjIGFkZCBtaW4gdHJhaW5pbmcgZXJyb3IgYW5kIHRyZWVzIHRvIGdyaWQNCiAgaHlwZXJfZ3JpZCRvcHRpbWFsX3RyZWVzW2ldIDwtIHdoaWNoLm1pbihnYm0udHVuZSR2YWxpZC5lcnJvcikNCiAgaHlwZXJfZ3JpZCRtaW5fUk1TRVtpXSA8LSBzcXJ0KG1pbihnYm0udHVuZSR2YWxpZC5lcnJvcikpDQogIGh5cGVyX2dyaWQkQ0NDW2ldID0gQ0NDKHByZWQsIGFsbF9kYXRhX3NwcmVhZF93bGIkc2V2Wy10cmFpbl0pJHJoby5jJGVzdCM8PDw8PA0KICANCn0NCg0KYmVzdF9wYXIgPSBoeXBlcl9ncmlkICU+JSANCiAgZHBseXI6OmFycmFuZ2UoLUNDQykgJT4lDQogIGhlYWQoMTApDQpiZXN0X3Bhcg0KDQoNCg0KIyBnYm0udHVuZSRmaXQNCmBgYA0KDQojIyMgQmVzdCBtb2RlbA0KDQpgYGB7cn0NCiMgZm9yIHJlcHJvZHVjaWJpbGl0eQ0Kc2V0LnNlZWQoMTIzKQ0KDQojIHRyYWluIEdCTSBtb2RlbA0KZ2JtLmZpdC5maW5hbF93bGIgPC0gZ2JtKA0KICBmb3JtdWxhID0gKHNldikgfkJHSStCSStHTEkrSEkrSFVFK05HUkRJK1ZBUkkrUmVkK0dyZWVuK0JsdWUrZ3JheStTSStTQ0ksDQogIGRhdGEgPSBhbGxfZGF0YV9zcHJlYWRfd2xiW3RyYWluLF0sDQogIGRpc3RyaWJ1dGlvbiA9ICJnYXVzc2lhbiIsDQogIG4udHJlZXMgPSBiZXN0X3BhciRvcHRpbWFsX3RyZWVzWzFdLA0KICBpbnRlcmFjdGlvbi5kZXB0aCA9IGJlc3RfcGFyJGludGVyYWN0aW9uLmRlcHRoWzFdLA0KICBzaHJpbmthZ2UgPSBiZXN0X3BhciRzaHJpbmthZ2VbMV0sDQogIG4ubWlub2JzaW5ub2RlID0gYmVzdF9wYXIkbi5taW5vYnNpbm5vZGVbMV0sDQogIGJhZy5mcmFjdGlvbiA9IGJlc3RfcGFyJGJhZy5mcmFjdGlvblsxXSwgDQogIHRyYWluLmZyYWN0aW9uID0wLjc1LA0KICBuLmNvcmVzID0gTlVMTCwgIyB3aWxsIHVzZSBhbGwgY29yZXMgYnkgZGVmYXVsdA0KICB2ZXJib3NlID0gRkFMU0UNCiAgKQ0KDQoNCmBgYA0KDQojIyMgUmVsYXRpdmUgaW5mbHVlbmNlDQoNCmBgYHtyfQ0KcGFyKG1hciA9IGMoNSwgOCwgMSwgMSkpDQpzdW1tYXJ5X2dibV93bGIgPSBzdW1tYXJ5KA0KICBnYm0uZml0LmZpbmFsX3dsYiwgDQogIGNCYXJzID0gMTUsDQogIG1ldGhvZCA9IHJlbGF0aXZlLmluZmx1ZW5jZSwgIyBhbHNvIGNhbiB1c2UgcGVybXV0YXRpb24udGVzdC5nYm0NCiAgbGFzID0gMg0KICApDQoNCnJlbF93bGIgPSBzdW1tYXJ5X2dibV93bGIgJT4lIA0KICByb3duYW1lc190b19jb2x1bW4oImluZGV4IikgJT4lIA0KICBnZ3Bsb3QoYWVzKHJlbC5pbmYsIHJlb3JkZXIodmFyLCByZWwuaW5mKSkpKw0KICBnZW9tX2NvbChhZXMoZmlsbCA9cmVsLmluZj4xLCBjb2xvciA9cmVsLmluZj4xICksIHdpZHRoID0gMC44NSkrDQogIHRoZW1lX21pbmltYWxfdmdyaWQoKSsNCiAgbGFicyh4ID0gIlJlbGF0aXZlIGluZmx1ZW5jZSAoJSkiLA0KICAgICAgIHkgPSAiTW9kZWwgcHJlZGljdG9ycyIsDQogICAgICAgZmlsbCA9ICJSSSA+IDElIiwNCiAgICAgICBjb2xvciA9ICJSSSA+IDElIikNCnJlbF93bGINCiMgZ2dzYXZlKCJmaWdzL3Zhcl9pbmZsdWVuY2UucG5nIixkcGkgPSA2MDAsIGhlaWdodCA9IDQsIHdpZHRoID0gNikNCmBgYA0KDQpQYXJ0aWFsIGRlcGVuZGVuY2UgcGxvdHMNCg0KYGBge3J9DQpnYm0uZml0LmZpbmFsX3dsYiAlPiUNCiAgcGRwOjpwYXJ0aWFsKHByZWQudmFyID0gIk5HUkRJIiwgbi50cmVlcyA9IGdibS5maXQuZmluYWxfd2xiJG4udHJlZXMsIGdyaWQucmVzb2x1dGlvbiA9IDEwMCkgJT4lDQogIGdncGxvdChhZXMoIE5HUkRJLCh5aGF0KSkpKw0KICBnZW9tX2xpbmUoKQ0KYGBgDQoNCkxJTUUNCg0KYGBge3J9DQptb2RlbF90eXBlLmdibSA8LSBmdW5jdGlvbih4LCAuLi4pIHsNCiAgcmV0dXJuKCJyZWdyZXNzaW9uIikNCn0NCg0KcHJlZGljdF9tb2RlbC5nYm0gPC0gZnVuY3Rpb24oeCwgbmV3ZGF0YSwgLi4uKSB7DQogIHByZWQgPC0gcHJlZGljdCh4LCBuZXdkYXRhLCBuLnRyZWVzID0geCRuLnRyZWVzKQ0KICByZXR1cm4oYXMuZGF0YS5mcmFtZShwcmVkKSkNCn0NCmBgYA0KDQpgYGB7cn0NCiMgZ2V0IGEgZmV3IG9ic2VydmF0aW9ucyB0byBwZXJmb3JtIGxvY2FsIGludGVycHJldGF0aW9uIG9uDQpsb2NhbF9vYnMgPC0gKGFsbF9kYXRhX3NwcmVhZF93bGJbLXRyYWluLF0pWzE6NCwgXQ0KDQojIGFwcGx5IExJTUUNCmV4cGxhaW5lciA8LSBsaW1lKGFsbF9kYXRhX3NwcmVhZF93bGJbdHJhaW4sXSwgZ2JtLmZpdC5maW5hbF93bGIpDQpleHBsYW5hdGlvbiA8LSBsaW1lOjpleHBsYWluKGxvY2FsX29icywgZXhwbGFpbmVyLCBuX2ZlYXR1cmVzID0gNywgbi50cmVlcyA9MSkNCnBsb3RfZmVhdHVyZXMoZXhwbGFuYXRpb24pDQoNCg0KYGBgDQoNCiMjIFByZWRpY3Rpb24NCg0KYGBge3J9DQojIHByZWRpY3QgdmFsdWVzIGZvciB0ZXN0IGRhdGENCnByZWQgPC0gcHJlZGljdChnYm0uZml0LmZpbmFsX3dsYiwNCiAgICAgICAgICAgICAgICBuLnRyZWVzID0gZ2JtLmZpdC5maW5hbF93bGIkbi50cmVlcywNCiAgICAgICAgICAgICAgICBhbGxfZGF0YV9zcHJlYWRfd2xiWy10cmFpbixdKQ0KDQojIHJlc3VsdHMNCmNhcmV0OjpSTVNFKChwcmVkKSwgYWxsX2RhdGFfc3ByZWFkX3dsYlstdHJhaW4sXSRzZXYpDQpDQ0MoKHByZWQpLCBhbGxfZGF0YV9zcHJlYWRfd2xiJHNldlstdHJhaW5dKSRyaG8uYyRlc3QNCmNvcigocHJlZCksIGFsbF9kYXRhX3NwcmVhZF93bGIkc2V2Wy10cmFpbl0pXjINCg0KYGBgDQoNCmBgYHtyfQ0KYWNjdXJhY3lfd2xiID1kYXRhLmZyYW1lKHByZWRpPXByZWQsIGFjdHVhbCA9IGFsbF9kYXRhX3NwcmVhZF93bGIkc2V2Wy10cmFpbl0pICU+JSANCiAgc3VtbWFyaXNlKFJNU0UgPSBjYXJldDo6Uk1TRShwcmVkLCBhY3R1YWwpLA0KICAgICAgICAgICAgciA9IGNvcihwcmVkLCBhY3R1YWwpLA0KICAgICAgICAgICAgcy5zaGlmdCA9IENDQyhwcmVkLCBhY3R1YWwpJHMuc2hpZnQsDQogICAgICAgICAgICBsLnNoaWZ0ID0gQ0NDKHByZWQsIGFjdHVhbCkkbC5zaGlmdCwNCiAgICAgICAgICAgIEMuYiA9IENDQyhwcmVkLCBhY3R1YWwpJEMuYiwNCiAgICAgICAgICAgIENDQyA9IENDQyhwcmVkLCBhY3R1YWwpJHJoby5jJGVzdCwNCiAgICAgICAgICAgIENJUyA9IHBhc3RlKA0KICByb3VuZChDQ0MocHJlZCwgYWxsX2RhdGFfc3ByZWFkX3dsYiRzZXZbLXRyYWluXSkkcmhvLmNbMl0sMiksIiwiLCIgIiwNCiAgcm91bmQoQ0NDKHByZWQsIGFsbF9kYXRhX3NwcmVhZF93bGIkc2V2Wy10cmFpbl0pJHJoby5jWzNdLDIpLHNlcCA9ICIiDQogICkpDQphY2N1cmFjeV93bGINCmBgYA0KDQojIyMjIHBsb3QNCmBgYHtyfQ0KDQojIHBsb3RfZ3JpZCgNCmNvbmNfd2xiID0gZGF0YS5mcmFtZShwcmVkaWN0ID0gcHJlZCwgYWN0dWFsID1hbGxfZGF0YV9zcHJlYWRfd2xiJHNldlstdHJhaW5dKSAlPiUgDQpnZ3Bsb3QoYWVzKGFjdHVhbCxwcmVkaWN0KSkrDQogIGdlb21fcG9pbnQoc2l6ZSA9MiwgY29sb3IgPSAiZ3JheSIpKw0KICBnZW9tX2FibGluZShpbnRlcmNlcHQgPSAwLCBzbG9wZT0gMSwgc2l6ZSA9IC44MSwgY29sb3IgPSAiYmxhY2siLCBsaW5ldHlwZSA9ICJkYXNoZWQiKSsNCiAgZ2VvbV9zbW9vdGgobWV0aG9kID0gImxtIiwgDQogICAgICAgICAgICAgIGNvbG9yID0gInJlZCIsDQogICAgICAgICAgICAgIHNpemUgPS44MSwgc2UgPUYsDQogICAgICAgICAgICAgIGZ1bGxyYW5nZT1UKSsNCiAgdGhlbWVfbWluaW1hbF9ncmlkKCkrDQogIGxhYnMoeCA9ICJQcmVkaWN0ZWQgU2V2ZXJpdHkgKCUpIiwNCiAgICAgICB5ID0gIkFjdHVhbCBTZXZlcml0eSAoJSkiKSsNCiAgY29vcmRfZXF1YWwoeGxpbSA9IGMoMCwxMDApLA0KICAgICAgICAgICAgICB5bGltID0gYygwLDEwMCkpKw0KICB4bGltKDAsMTAwKQ0KDQpnZ3NhdmUoImZpZ3MvY29uY29yZGFuY2UucG5nIiwgZHBpID0gNjAwLCBoZWlnaHQgPSAzLjUsIHdpZHRoID0gNCkNCg0KYGBgDQoNCiMgU295YmVhbiBSdXN0DQoNCmBgYHtyIGV2YWw9RkFMU0UsIGluY2x1ZGU9VFJVRX0NCnBpY3M8LWxpc3QuZmlsZXMoIi4vcGljcy8wMS1zb3liZWFuLXJ1c3QtYmctYmx1ZSIpDQojIGxlbmd0aChwaWNzKQ0KI2luZGljZXMNCmluZGV4ID0gYygiQkkiLCJTQ0kiLCJHTEkiLCJISSIsIlNJIiwiVkFSSSIsIkhVRSIsIkJHSSIsIk5HUkRJIikNCg0KDQpib3ggPSBkYXRhLmZyYW1lKCkNCg0KZm9yKGkgaW4gMTpsZW5ndGgocGljcykpew0KDQpFWC5MMTwtc3RhY2socGFzdGUoIi4vcGljcy8wMS1zb3liZWFuLXJ1c3QtYmctYmx1ZS8iLHBpY3NbaV0sc2VwID0gIiIpKQ0KRVguTDE8LWFnZ3JlZ2F0ZShFWC5MMSwgZmFjdD03KQ0KRVguTC5TaGFwZTwtZmllbGRQb2x5Z29uKG1vc2FpYz1FWC5MMSwgZXh0ZW50PVQsIHBsb3QgPSBGKQ0KDQpFWDEuSW5kaWNlczwtIGZpZWxkSW5kZXgobW9zYWljID0gRVguTDEsDQogICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpbmRleCwgDQogICAgICAgICAgICAgICAgICAgICAgICAgbXlJbmRleCA9IGMoIkdyZWVuIiksIHBsb3QgPSBGKQ0KDQpFWC5MMjwtZmllbGRNYXNrKG1vc2FpYz1FWC5MMSwgIG15SW5kZXggPSBjKCJCbHVlIiksIGNyb3BWYWx1ZT0xMDAsIGNyb3BBYm92ZT1ULCBwbG90ID0gRikNCg0KY3V0ID0gbWFzayhFWC5MMSwgRVguTDIkbmV3TW9zYWljKQ0KRVguTDQ8LWZpZWxkSW5kZXgobW9zYWljPWN1dCwNCiAgICAgICAgICAgICAgICAgIGluZGV4ID1pbmRleCwNCiAgICAgICAgICAgICAgICAgIHBsb3QgPUYpDQoNCg0KZGYgPSBhcyhFWC5MNCwgIlNwYXRpYWxQaXhlbHNEYXRhRnJhbWUiKQ0KZGZmID0gYXMuZGF0YS5mcmFtZShkZikgJT4lIA0KICBtdXRhdGUoZ3JheSA9IDAuMjk5KlJlZCswLjU4NypHcmVlbiswLjExNCpCbHVlKSAlPiUgDQogIGdhdGhlcihjKDE6KDMrbGVuZ3RoKGluZGV4KSksMTUpLCBrZXkgPSAiaW5kZXgiLCB2YWx1ZSA9ICJ2YWx1ZSIgKSAlPiUNCiAgZmlsdGVyKCFpcy5uYSh2YWx1ZSksDQogICAgICAgICAhaXMuaW5maW5pdGUodmFsdWUpKSAlPiUgDQogIGdyb3VwX2J5KGluZGV4KSAlPiUgDQogIGRwbHlyOjpzdW1tYXJpc2UobWVhbiA9IG1lYW4odmFsdWUsIG5hLnJtID0gVCksDQogICAgICAgICAgICBzdGQgPSBzZCh2YWx1ZSksDQogICAgICAgICAgICBRMjUgPSBxdWFudGlsZSh2YWx1ZSwwLjI1KSwNCiAgICAgICAgICAgIFE1MCA9IHF1YW50aWxlKHZhbHVlLDAuNTApLA0KICAgICAgICAgICAgUTc1ID0gcXVhbnRpbGUodmFsdWUsMC43NSkpICU+JSANCiAgbXV0YXRlKGxlYWYgPSBwaWNzW2ldKQ0KDQoNCmJveCA9IGJveCAlPiUgDQogIGJpbmRfcm93cyhkZmYpfQ0KbGVuZ3RoKHVuaXF1ZShib3gkbGVhZikpDQp3cml0ZS50YWJsZShib3gsImRhdGEvaW5kZXhlc19TQlIudHh0IikNCmBgYA0KDQpgYGB7cn0NCmJveCA9IHJlYWQudGFibGUoImRhdGEvaW5kZXhlc19TQlIudHh0IikNCmBgYA0KDQojIyMgbG9hZCBTQlIgc2V2ZXJpdHkNCg0KYGBge3J9DQpzYnJfbG9hZCA9IGdzaGVldDJ0YmwoImh0dHBzOi8vZG9jcy5nb29nbGUuY29tL3NwcmVhZHNoZWV0cy9kLzEzVFZLQlFnZkNBcjdVR2llX0xIVEZfa3dQSEMxWElfQWtMS29SWXRqUHJRL2VkaXQ/dXNwPXNoYXJpbmciKQ0KYGBgDQoNCmBgYHtyfQ0KYWxsX2RhdGFfc2JyID0gYm94ICU+JSANCiAgc2VwYXJhdGUobGVhZiwgaW50bz1jKCJmaWxlIiwiZm9ybWF0IiksIHNlcCA9Il8iKSAlPiUgDQogIGRwbHlyOjpzZWxlY3QoLWZvcm1hdCkgJT4lIA0KICBmdWxsX2pvaW4oc2JyX2xvYWQpICU+JSANCiAgbmEub21pdCgpDQoNCmxlbmd0aCh1bmlxdWUoYWxsX2RhdGFfc2JyJGZpbGUpKQ0KDQoNCmhlYWQoYWxsX2RhdGFfc2JyKQ0KYGBgDQoNCmBgYHtyfQ0Kc3VtbWFyeShhbGxfZGF0YV9zYnIkc2V2KQ0KYGBgDQoNCg0KIyMjIEltYWdlcw0KDQpgYGB7cn0NCmhpc3Rfc2V2X3NiciA9ICBhbGxfZGF0YV9zYnIgJT4lDQogIHBpdm90X3dpZGVyKGlkX2NvbCA9IGMoZmlsZSxzZXYpLA0KICAgICAgICAgICAgICBuYW1lc19mcm9tID0gaW5kZXgsIA0KICAgICAgICAgICAgICB2YWx1ZXNfZnJvbSA9ICBtZWFuKSAlPiUNCiAgZ2dwbG90KGFlcyhzZXYpKSsNCiAgZ2VvbV9oaXN0b2dyYW0oY29sb3IgPSAid2hpdGUiLCBmaWxsID0gImJsYWNrIiwgYmlucyA9IDIwKSsNCiAgdGhlbWVfbWluaW1hbF9oZ3JpZChmb250X3NpemUgPSAxMCkrDQogIGxhYnMoeCA9ICJTZXZlcml0eSAoJSkiLA0KICAgICAgIHkgPSAiRnJlcXVlbmN5IikrDQogIHNjYWxlX3hfY29udGludW91cyhsaW1pdHMgPSBjKC01LDEwNSksIGJyZWFrcyA9IHNlcSgwLDEwMCwyNSkpKw0KICAjIHRoZW1lX3ZvaWQoKSsNCiAgIyBjb29yZF9maXhlZCgpKw0KICB0aGVtZShwYW5lbC5iYWNrZ3JvdW5kID0gZWxlbWVudF9yZWN0KGNvbG9yID0gImJsYWNrIiksDQogICAgICAgIGF4aXMudGl0bGUueSA9IGVsZW1lbnRfdGV4dChzaXplPTgpKQ0KDQpgYGANCg0KYGBge3J9DQpFWC5MMTwtc3RhY2socGFzdGUoIi4vcGljcy8wMS1zb3liZWFuLXJ1c3QtYmctYmx1ZS8iLCJGZXJydWdlbSAyX01lZGlhbi5qcGciLHNlcCA9ICIiKSkNCkVYLkwxPC1hZ2dyZWdhdGUoRVguTDEsIGZhY3Q9NykNCkVYLkwuU2hhcGU8LWZpZWxkUG9seWdvbihtb3NhaWM9RVguTDEsIGV4dGVudD1ULCBwbG90ID0gRikNCg0KRVgxLkluZGljZXM8LSBmaWVsZEluZGV4KG1vc2FpYyA9IEVYLkwxLA0KICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaW5kZXgsIA0KICAgICAgICAgICAgICAgICAgICAgICAgIG15SW5kZXggPSBjKCJHcmVlbiIpLCBwbG90ID0gRikNCg0KRVguTDI8LWZpZWxkTWFzayhtb3NhaWM9RVguTDEsICBteUluZGV4ID0gYygiQmx1ZSIpLCBjcm9wVmFsdWU9MTAwLCBjcm9wQWJvdmU9VCwgcGxvdCA9IEYpDQoNCmN1dCA9IG1hc2soRVguTDEsIEVYLkwyJG5ld01vc2FpYykNCkVYLkw0PC1maWVsZEluZGV4KG1vc2FpYz1jdXQsDQogICAgICAgICAgICAgICAgICBpbmRleCA9aW5kZXgsDQogICAgICAgICAgICAgICAgICBwbG90ID1GKQ0KIyBwbG90KEVYLkw0JEhVRSkNCmBgYA0KDQpgYGB7cn0NCnJnYl9maWdfc2JyID0gUlN0b29sYm94OjpnZ1JHQihFWC5MMiRuZXdNb3NhaWMsDQogICAgICAgICAgICAgICAgIHIgPSAxLA0KICAgICAgICAgICAgICAgICBnID0gMiwNCiAgICAgICAgICAgICAgICAgYiA9IDMpKw0KICB0aGVtZV9tYXAoKSsNCiAgY29vcmRfZml4ZWQoKSsNCiAgdGhlbWUocGFuZWwuYmFja2dyb3VuZCA9IGVsZW1lbnRfcmVjdChjb2xvciA9ICJ3aGl0ZSIpKQ0KDQoNCmdsaV9maWdfc2JyID0gYXMuZGF0YS5mcmFtZShFWC5MNCRIVUUsIHh5PVRSVUUsIG5hLnJtID1UKSAlPiUgDQogIGdncGxvdChhZXMoeCwgeSwgZmlsbCA9IEhVRSkpKw0KICBnZW9tX3RpbGUoKSsNCiAgc2NhbGVfZmlsbF92aXJpZGlzX2Mob3B0aW9uID0gIkIiLGRpcmVjdGlvbiA9IC0xKSsNCiAgdGhlbWVfbWFwKCkrDQogIGNvb3JkX2ZpeGVkKCkrDQogIHRoZW1lKHBhbmVsLmJhY2tncm91bmQgPSBlbGVtZW50X3JlY3QoY29sb3IgPSAid2hpdGUiKSwNCiAgICAgICAgbGVnZW5kLnRpdGxlID0gZWxlbWVudF90ZXh0KHNpemUgPSA4KSwNCiAgICAgICAgbGVnZW5kLnRleHQgPSBlbGVtZW50X3RleHQoc2l6ZSA9IDgpKQ0KDQpgYGANCg0KYGBge3J9DQpyZ2JfZmlnX3NiciArIGdsaV9maWdfc2JyICsgaGlzdF9zZXZfc2JyICMrDQogICMgcmdiX2ZpZ193bGIgKyBnbGlfZmlnX3dsYiArIGhpc3Rfc2V2X1dMQisNCiAgIyAgcGxvdF9sYXlvdXQod2lkdGhzID0gYygxLCAxLCAxKSwNCiAgIyAgICAgICAgICAgICAgaGVpZ2h0cyA9IGMoMSwxKSkNCg0KIyBnZ3NhdmUoImZpZ3MvbGVhZl9nbGkucG5nIixkcGkgPSA2MDAsIGhlaWdodCA9IDYsIHdpZHRoID0xMCkNCmBgYA0KDQojIyMgUmVsYXRpb25zaGlwIHNldiBpbmRpY2VzDQoNCmBgYHtyfQ0KcmdiX2dnX3NiciA9IGFsbF9kYXRhX3NiciAlPiUgDQogIGZpbHRlcihpbmRleCAlaW4lIGMoIlJlZCIsICJCbHVlIiwgIkdyZWVuIikpICU+JSANCiAgICBnZ3Bsb3QoYWVzKG1lYW4sIHNldiwgY29sb3IgPSBpbmRleCkpICsgDQogICMgZ2VvbV90ZXh0KCkrDQogIGdlb21fcG9pbnQoY29sb3IgPSAiZ3JheSIsIHNpemUgID0zKSsNCiAgZ2VvbV9zbW9vdGgoc2UgPSBGLCBzaXplID0gMikrDQogIGZhY2V0X3dyYXAofmluZGV4LCBzY2FsZXMgPSAiZnJlZV94IiwgbnJvdyA9MSkrDQogIHNjYWxlX2NvbG9yX21hbnVhbCh2YWx1ZXMgPSBjKCJzdGVlbGJsdWUiLCJkYXJrZ3JlZW4iLCAiZGFya3JlZCIpKSsNCiAgdGhlbWVfbWluaW1hbF9oZ3JpZCgpKw0KICBsYWJzKHggPSAiTWVhbiB2YWx1ZSBpbiB0aGUgaW1hZ2UiLA0KICAgICAgIHkgPSAiRGlzZWFzZSBzZXZlcml0eSAoJSkiKSsNCiAgdGhlbWUocGFuZWwuYm9yZGVyID0gZWxlbWVudF9yZWN0KGNvbG9yID0gImdyYXkiKSkrDQogIHRoZW1lKGxlZ2VuZC5wb3NpdGlvbiA9ICJub25lIikNCnJnYl9nZ19zYnINCmBgYA0KDQpgYGB7cn0NCmluZGV4X2dnX3NiciA9IGFsbF9kYXRhX3NiciAlPiUgDQogIGZpbHRlcighaW5kZXggJWluJSBjKCJSZWQiLCAiQmx1ZSIsICJHcmVlbiIpKSAlPiUgDQogICAgZ2dwbG90KGFlcyhtZWFuLCBzZXYpKSArIA0KICAjIGdlb21fdGV4dCgpKw0KICBnZW9tX3BvaW50KGNvbG9yID0gImdyYXkiLCBzaXplICA9MykrDQogIGdlb21fc21vb3RoKGNvbG9yID0gImJsYWNrIiwgc2UgPSBGLCBzaXplID0gMikrDQogIGZhY2V0X3dyYXAofmluZGV4LCBzY2FsZXMgPSAiZnJlZV94IiwgbnJvdyA9MikrDQogIHRoZW1lX21pbmltYWxfaGdyaWQoKSsNCiAgbGFicyh4ID0gIk1lYW4gaW5kZXggdmFsdWUgaW4gdGhlIGltYWdlIiwNCiAgICAgICB5ID0gIkRpc2Vhc2Ugc2V2ZXJpdHkgKCUpIikrDQogIHRoZW1lKHBhbmVsLmJvcmRlciA9IGVsZW1lbnRfcmVjdChjb2xvciA9ICJncmF5IikpDQppbmRleF9nZ19zYnINCmBgYA0KDQpgYGB7cn0NCnBsb3RfZ3JpZCgNCiAgcGxvdF9ncmlkKE5VTEwscmdiX2dnX3NicixOVUxMLCByZWxfd2lkdGhzID1jKDAuMTgsMSwwLjIpLCBucm93ID0gMSksDQogICAgICAgICAgaW5kZXhfZ2dfc2JyLA0KICAgICAgICAgIG5yb3cgPSAyLA0KICAgICAgICAgIHJlbF9oZWlnaHRzID0gYygwLjUsMSkpDQpnZ3NhdmUoImZpZ3MvaW5kZXhfc2V2X1NCUi5wbmciLCBkcGkgPSA1MDAsIGhlaWdodCA9IDgsIHdpZHRoID0gMTApDQpgYGANCg0KYGBge3J9DQpjb3Jfc2JyID0gYWxsX2RhdGFfc2JyICU+JSANCiAgZ3JvdXBfYnkoaW5kZXgpICU+JSANCiAgZHBseXI6OnN1bW1hcmlzZShjb3IgPSByb3VuZCggIGNvci50ZXN0KG1lYW4sc2V2LCBtZXRob2QgPSAic3BlYXJtYW4iKSRlc3RpbWF0ZSwzKSwNCiAgICAgICAgICAgICAgICAgICBQX3ZhbHVlID0gY29yLnRlc3QobWVhbixzZXYsIG1ldGhvZCA9ICJzcGVhcm1hbiIpJHAudmFsdWUpICU+JSANCiAgYXJyYW5nZSgtY29yKQ0KY29yX3Nicg0KYGBgDQoNCiMjIyBTcHJlYWQgZGYNCg0KYGBge3J9DQphbGxfZGF0YV9zcHJlYWRfc2JyID0gYWxsX2RhdGFfc2JyICU+JSANCiAgcGl2b3Rfd2lkZXIoaWRfY29sID0gYyhmaWxlLHNldiksDQogICAgICAgICAgICAgIG5hbWVzX2Zyb20gPSBpbmRleCwgDQogICAgICAgICAgICAgIHZhbHVlc19mcm9tID0gIG1lYW4pICAgDQoNCmhlYWQoYWxsX2RhdGFfc3ByZWFkX3NicikNCmBgYA0KDQojIyBHQk0NCg0KYGBge3J9DQp0cmFpbj1zYW1wbGUoeCA9IDE6bGVuZ3RoKGFsbF9kYXRhX3NwcmVhZF9zYnIkc2V2KSwgDQogICAgICAgICAgICAgc2l6ZSA9IHJvdW5kKDAuNzUqbGVuZ3RoKGFsbF9kYXRhX3NwcmVhZF9zYnIkc2V2KSwxKSkNCiMgbGVuZ3RoKHRyYWluKQ0KZ2JtLmZpdCA9IGdibShzZXYgfkJHSStCSStHTEkrSEkrSFVFK05HUkRJK1ZBUkkrZ3JheSsgUmVkK0dyZWVuK0JsdWUgICsgU0kgKyBTQ0ksDQogICAgICAgICAgICAgZGF0YSA9IGFsbF9kYXRhX3NwcmVhZF9zYnJbdHJhaW4sXSwNCiAgICAgICAgICAgICBkaXN0cmlidXRpb24gPSAiZ2F1c3NpYW4iLA0KICAgICAgICAgICAgICBuLnRyZWVzID0gMTAwMCwNCiAgICAgICAgICAgICBpbnRlcmFjdGlvbi5kZXB0aCA9IDMsDQogICAgICAgICAgICAgc2hyaW5rYWdlID0gMC4xLA0KICAgICAgICAgICAgIGN2LmZvbGRzID0gNSwNCiAgICAgICAgICAgICBuLmNvcmVzID0gTlVMTCwgIyB3aWxsIHVzZSBhbGwgY29yZXMgYnkgZGVmYXVsdA0KICAgICAgICAgICAgIHZlcmJvc2UgPSBGQUxTRSkNCnByaW50KGdibS5maXQpDQpzcXJ0KG1pbihnYm0uZml0JGN2LmVycm9yKSkNCmBgYA0KDQpgYGB7cn0NCmdibS5wZXJmKGdibS5maXQsIG1ldGhvZCA9ICJjdiIpDQojIGZpbmQgaW5kZXggZm9yIG4gdHJlZXMgd2l0aCBtaW5pbXVtIENWIGVycm9yDQpgYGANCg0KYGBge3J9DQptaW5fTVNFIDwtIHdoaWNoLm1pbihnYm0uZml0JGN2LmVycm9yKQ0Kc3FydChnYm0uZml0JGN2LmVycm9yW21pbl9NU0VdKQ0KDQpgYGANCg0KYGBge3J9DQojIGJlc3QuaXRlciA8LSBnYm0ucGVyZihtb2RlbDEsIG1ldGhvZCA9ICJ0ZXN0IikNCiMgcHJpbnQoYmVzdC5pdGVyKQ0KDQpwcmVkID0gcHJlZGljdChnYm0uZml0LCBuZXdkYXRhID0gYWxsX2RhdGFfc3ByZWFkX3NiclstdHJhaW4sLTFdLCBudHJlZXMgPSA1MDAwICkNCg0Kc3FydChtZWFuKCgocHJlZCktYWxsX2RhdGFfc3ByZWFkX3NiciRzZXZbLXRyYWluXSleMikpDQpDQ0MoKHByZWQpLCBhbGxfZGF0YV9zcHJlYWRfc2JyJHNldlstdHJhaW5dKSRyaG8uYyRlc3QNCg0KcGxvdCgocHJlZCksIChwcmVkKS1hbGxfZGF0YV9zcHJlYWRfc2JyJHNldlstdHJhaW5dKQ0KYWJsaW5lKGE9MCxiPTApDQpgYGANCg0KIyMjIFRlc3RpbmcgdmFyaW91cyBoeXBlcnBhcmFtZXRlcnMNCg0KQ3JlYXRlIGh5cGVycGFyYW1ldGVyIGdyaWQNCg0KYGBge3J9DQoNCmh5cGVyX2dyaWQgPC0gZXhwYW5kLmdyaWQoDQogIHNocmlua2FnZSA9IGMoLjAwMSwgLjAxLCAuMSwgLjMpLA0KICBpbnRlcmFjdGlvbi5kZXB0aCA9IGMoMSwgMywgNSwgNiksDQogIG4ubWlub2JzaW5ub2RlID0gYyg1LCAxMCwgMTUpLA0KICBiYWcuZnJhY3Rpb24gPSBjKC41LC42NSwgLjgsIDEpLCANCiAgb3B0aW1hbF90cmVlcyA9IDAsICAgICAgICAgICAgICAgIyBhIHBsYWNlIHRvIGR1bXAgcmVzdWx0cw0KICBtaW5fUk1TRSA9IDAsDQogIENDQyA9MCAjIGEgcGxhY2UgdG8gZHVtcCByZXN1bHRzDQopDQojIHRvdGFsIG51bWJlciBvZiBjb21iaW5hdGlvbnMNCm5yb3coaHlwZXJfZ3JpZCkNCmBgYA0KDQpgYGB7ciBtZXNzYWdlPUZBTFNFLCB3YXJuaW5nPUZBTFNFfQ0KIyByYW5kb21pemUgZGF0YQ0Kc2V0LnNlZWQoMTIzKQ0KdHJhaW49c2FtcGxlKHggPSAxOmxlbmd0aChhbGxfZGF0YV9zcHJlYWRfc2JyJHNldiksIA0KICAgICAgICAgICAgIHNpemUgPSByb3VuZCgwLjgqbGVuZ3RoKGFsbF9kYXRhX3NwcmVhZF9zYnIkc2V2KSwxKSkNCg0KIyBncmlkIHNlYXJjaCANCmZvcihpIGluIDE6bnJvdyhoeXBlcl9ncmlkKSkgew0KDQojIHJlcHJvZHVjaWJpbGl0eQ0Kc2V0LnNlZWQoMTIzKQ0KDQoNCiAjIHRyYWluIG1vZGVsDQpnYm0udHVuZSA8LSBnYm0oDQogIGZvcm11bGEgPSAoc2V2KSB+QkdJK0JJK0dMSStISStIVUUrTkdSREkrVkFSSStncmF5ICtSZWQrR3JlZW4rQmx1ZSArIFNJICsgU0NJLCAjPDw8PDwNCiAgZGF0YSA9IGFsbF9kYXRhX3NwcmVhZF9zYnJbdHJhaW4sXSwNCiAgZGlzdHJpYnV0aW9uID0gImdhdXNzaWFuIiwNCiAgbi50cmVlcyA9IDUwMDAsDQogIGludGVyYWN0aW9uLmRlcHRoID0gaHlwZXJfZ3JpZCRpbnRlcmFjdGlvbi5kZXB0aFtpXSwNCiAgc2hyaW5rYWdlID0gaHlwZXJfZ3JpZCRzaHJpbmthZ2VbaV0sDQogIG4ubWlub2JzaW5ub2RlID0gaHlwZXJfZ3JpZCRuLm1pbm9ic2lubm9kZVtpXSwNCiAgYmFnLmZyYWN0aW9uID0gaHlwZXJfZ3JpZCRiYWcuZnJhY3Rpb25baV0sDQogIHRyYWluLmZyYWN0aW9uID0gLjc1LA0KICBuLmNvcmVzID0gTlVMTCwgIyB3aWxsIHVzZSBhbGwgY29yZXMgYnkgZGVmYXVsdA0KICB2ZXJib3NlID0gRkFMU0UpDQoNCnByZWQgPSBwcmVkaWN0KGdibS50dW5lLCBuZXdkYXRhID0gYWxsX2RhdGFfc3ByZWFkX3NiclstdHJhaW4sLTFdLCBudHJlZXMgPSA1MDAwICkNCiAjIGFkZCBtaW4gdHJhaW5pbmcgZXJyb3IgYW5kIHRyZWVzIHRvIGdyaWQNCiAgaHlwZXJfZ3JpZCRvcHRpbWFsX3RyZWVzW2ldIDwtIHdoaWNoLm1pbihnYm0udHVuZSR2YWxpZC5lcnJvcikNCiAgaHlwZXJfZ3JpZCRtaW5fUk1TRVtpXSA8LSBzcXJ0KG1pbihnYm0udHVuZSR2YWxpZC5lcnJvcikpDQogIGh5cGVyX2dyaWQkQ0NDW2ldID0gQ0NDKHByZWQsIGFsbF9kYXRhX3NwcmVhZF9zYnIkc2V2Wy10cmFpbl0pJHJoby5jJGVzdCM8PDw8PA0KICANCn0NCg0KYmVzdF9wYXIgPSBoeXBlcl9ncmlkICU+JSANCiAgZHBseXI6OmFycmFuZ2UoLUNDQykgJT4lDQogIGhlYWQoMTApDQpiZXN0X3Bhcg0KDQoNCg0KIyBnYm0udHVuZSRmaXQNCmBgYA0KDQojIyMgQmVzdCBtb2RlbA0KDQpgYGB7cn0NCiMgZm9yIHJlcHJvZHVjaWJpbGl0eQ0Kc2V0LnNlZWQoMTIzKQ0KDQojIHRyYWluIEdCTSBtb2RlbA0KZ2JtLmZpdC5maW5hbF9zYnIgPC0gZ2JtKA0KICBmb3JtdWxhID0gKHNldikgfkJHSStCSStHTEkrSEkrSFVFK05HUkRJK1ZBUkkrUmVkK0dyZWVuK0JsdWUrZ3JheStTSStTQ0ksDQogIGRhdGEgPSBhbGxfZGF0YV9zcHJlYWRfc2JyW3RyYWluLF0sDQogIGRpc3RyaWJ1dGlvbiA9ICJnYXVzc2lhbiIsDQogIG4udHJlZXMgPSBiZXN0X3BhciRvcHRpbWFsX3RyZWVzWzFdLA0KICBpbnRlcmFjdGlvbi5kZXB0aCA9IGJlc3RfcGFyJGludGVyYWN0aW9uLmRlcHRoWzFdLA0KICBzaHJpbmthZ2UgPSBiZXN0X3BhciRzaHJpbmthZ2VbMV0sDQogIG4ubWlub2JzaW5ub2RlID0gYmVzdF9wYXIkbi5taW5vYnNpbm5vZGVbMV0sDQogIGJhZy5mcmFjdGlvbiA9IGJlc3RfcGFyJGJhZy5mcmFjdGlvblsxXSwgDQogIHRyYWluLmZyYWN0aW9uID0wLjc1LA0KICBuLmNvcmVzID0gTlVMTCwgIyB3aWxsIHVzZSBhbGwgY29yZXMgYnkgZGVmYXVsdA0KICB2ZXJib3NlID0gRkFMU0UNCiAgKQ0KDQoNCmBgYA0KDQojIyMgUmVsYXRpdmUgaW5mbHVlbmNlDQoNCmBgYHtyfQ0KcGFyKG1hciA9IGMoNSwgOCwgMSwgMSkpDQpzdW1tYXJ5X2dibV9zYnIgPSBzdW1tYXJ5KA0KICBnYm0uZml0LmZpbmFsX3NiciwgDQogIGNCYXJzID0gMTUsDQogIG1ldGhvZCA9IHJlbGF0aXZlLmluZmx1ZW5jZSwgIyBhbHNvIGNhbiB1c2UgcGVybXV0YXRpb24udGVzdC5nYm0NCiAgbGFzID0gMg0KICApDQoNCnJlbF9zYnIgPSBzdW1tYXJ5X2dibV9zYnIgJT4lIA0KICByb3duYW1lc190b19jb2x1bW4oImluZGV4IikgJT4lIA0KICBnZ3Bsb3QoYWVzKHJlbC5pbmYsIHJlb3JkZXIodmFyLCByZWwuaW5mKSkpKw0KICBnZW9tX2NvbChhZXMoZmlsbCA9cmVsLmluZj4xLCBjb2xvciA9cmVsLmluZj4xICksIHdpZHRoID0gMC44NSkrDQogIHRoZW1lX21pbmltYWxfdmdyaWQoKSsNCiAgbGFicyh4ID0gIlJlbGF0aXZlIGluZmx1ZW5jZSAoJSkiLA0KICAgICAgIHkgPSAiTW9kZWwgcHJlZGljdG9ycyIsDQogICAgICAgZmlsbCA9ICJSSSA+IDElIiwNCiAgICAgICBjb2xvciA9ICJSSSA+IDElIikNCnJlbF9zYnINCiMgZ2dzYXZlKCJmaWdzL3Zhcl9pbmZsdWVuY2UucG5nIixkcGkgPSA2MDAsIGhlaWdodCA9IDQsIHdpZHRoID0gNikNCmBgYA0KDQpQYXJ0aWFsIGRlcGVuZGVuY2UgcGxvdHMNCg0KYGBge3J9DQpnYm0uZml0LmZpbmFsX3NiciAlPiUNCiAgcGRwOjpwYXJ0aWFsKHByZWQudmFyID0gIkhVRSIsIG4udHJlZXMgPSBnYm0uZml0LmZpbmFsX3NiciRuLnRyZWVzLCBncmlkLnJlc29sdXRpb24gPSAxMDApICU+JQ0KICBnZ3Bsb3QoYWVzKCBIVUUsKHloYXQpKSkrDQogIGdlb21fbGluZSgpDQpgYGANCg0KTElNRQ0KDQpgYGB7cn0NCmxpYnJhcnkobGltZSkNCmBgYA0KDQpgYGB7cn0NCm1vZGVsX3R5cGUuZ2JtIDwtIGZ1bmN0aW9uKHgsIC4uLikgew0KICByZXR1cm4oInJlZ3Jlc3Npb24iKQ0KfQ0KDQpwcmVkaWN0X21vZGVsLmdibSA8LSBmdW5jdGlvbih4LCBuZXdkYXRhLCAuLi4pIHsNCiAgcHJlZCA8LSBwcmVkaWN0KHgsIG5ld2RhdGEsIG4udHJlZXMgPSB4JG4udHJlZXMpDQogIHJldHVybihhcy5kYXRhLmZyYW1lKHByZWQpKQ0KfQ0KYGBgDQoNCmBgYHtyfQ0KIyBnZXQgYSBmZXcgb2JzZXJ2YXRpb25zIHRvIHBlcmZvcm0gbG9jYWwgaW50ZXJwcmV0YXRpb24gb24NCmxvY2FsX29icyA8LSAoYWxsX2RhdGFfc3ByZWFkX3NiclstdHJhaW4sXSlbMTo0LCBdDQoNCiMgYXBwbHkgTElNRQ0KZXhwbGFpbmVyIDwtIGxpbWUoYWxsX2RhdGFfc3ByZWFkX3Niclt0cmFpbixdLCBnYm0uZml0LmZpbmFsX3NicikNCmV4cGxhbmF0aW9uIDwtIGxpbWU6OmV4cGxhaW4obG9jYWxfb2JzLCBleHBsYWluZXIsIG5fZmVhdHVyZXMgPSA3LCBuLnRyZWVzID0xKQ0KcGxvdF9mZWF0dXJlcyhleHBsYW5hdGlvbikNCg0KDQpgYGANCg0KIyMgUHJlZGljdGlvbg0KDQpgYGB7cn0NCiMgcHJlZGljdCB2YWx1ZXMgZm9yIHRlc3QgZGF0YQ0KcHJlZCA8LSBwcmVkaWN0KGdibS5maXQuZmluYWxfc2JyLA0KICAgICAgICAgICAgICAgIG4udHJlZXMgPSBnYm0uZml0LmZpbmFsX3NiciRuLnRyZWVzLA0KICAgICAgICAgICAgICAgIGFsbF9kYXRhX3NwcmVhZF9zYnJbLXRyYWluLF0pDQoNCiMgcmVzdWx0cw0KY2FyZXQ6OlJNU0UoKHByZWQpLCBhbGxfZGF0YV9zcHJlYWRfc2JyWy10cmFpbixdJHNldikNCkNDQyhwcmVkLCBhbGxfZGF0YV9zcHJlYWRfc2JyJHNldlstdHJhaW5dKSRyaG8uYyRlc3QNCmNvcihwcmVkLCBhbGxfZGF0YV9zcHJlYWRfc2JyJHNldlstdHJhaW5dKV4yDQoNCmBgYA0KDQpgYGB7cn0NCmFjY3VyYWN5X3NiciA9ZGF0YS5mcmFtZShwcmVkaT1wcmVkLCBhY3R1YWwgPSBhbGxfZGF0YV9zcHJlYWRfc2JyJHNldlstdHJhaW5dKSAlPiUgDQogIHN1bW1hcmlzZShSTVNFID0gY2FyZXQ6OlJNU0UocHJlZCwgYWN0dWFsKSwNCiAgICAgICAgICAgIHIgPSBjb3IocHJlZCwgYWN0dWFsKSwNCiAgICAgICAgICAgIHMuc2hpZnQgPSBDQ0MocHJlZCwgYWN0dWFsKSRzLnNoaWZ0LA0KICAgICAgICAgICAgbC5zaGlmdCA9IENDQyhwcmVkLCBhY3R1YWwpJGwuc2hpZnQsDQogICAgICAgICAgICBDLmIgPSBDQ0MocHJlZCwgYWN0dWFsKSRDLmIsDQogICAgICAgICAgICBDQ0MgPSBDQ0MocHJlZCwgYWN0dWFsKSRyaG8uYyRlc3QsDQogICAgICAgICAgICBDSVMgPSBwYXN0ZSgNCiAgcm91bmQoQ0NDKHByZWQsIGFsbF9kYXRhX3NwcmVhZF9zYnIkc2V2Wy10cmFpbl0pJHJoby5jWzJdLDIpLCIsIiwiICIsDQogIHJvdW5kKENDQyhwcmVkLCBhbGxfZGF0YV9zcHJlYWRfc2JyJHNldlstdHJhaW5dKSRyaG8uY1szXSwyKSxzZXAgPSAiIg0KICApKQ0KYWNjdXJhY3lfc2JyDQpgYGANCg0KDQojIyMjIHBsb3QNCmBgYHtyfQ0KDQpjb25jX3NiciA9IGRhdGEuZnJhbWUocHJlZGljdCA9IHByZWQsIGFjdHVhbCA9YWxsX2RhdGFfc3ByZWFkX3NiciRzZXZbLXRyYWluXSkgJT4lIA0KZ2dwbG90KGFlcyhhY3R1YWwsIHByZWRpY3QgKSkrDQogIGdlb21fcG9pbnQoc2l6ZSA9MiwgY29sb3IgPSAiZ3JheSIpKw0KICBnZW9tX2FibGluZShpbnRlcmNlcHQgPSAwLCBzbG9wZT0gMSwgc2l6ZSA9IC44MSwgY29sb3IgPSAiYmxhY2siLCBsaW5ldHlwZSA9ICJkYXNoZWQiKSsNCiAgZ2VvbV9zbW9vdGgobWV0aG9kID0gImxtIiwgDQogICAgICAgICAgICAgIGNvbG9yID0gInJlZCIsDQogICAgICAgICAgICAgIHNpemUgPS44MSwgc2UgPUYsDQogICAgICAgICAgICAgIGZ1bGxyYW5nZT1UKSsNCiAgdGhlbWVfbWluaW1hbF9ncmlkKCkrDQogIGxhYnMoeCA9ICJQcmVkaWN0ZWQgU2V2ZXJpdHkgKCUpIiwNCiAgICAgICB5ID0gIkFjdHVhbCBTZXZlcml0eSAoJSkiKSsNCiAgY29vcmRfZXF1YWwoeGxpbSA9IGMoMCwxMDApLA0KICAgICAgICAgICAgICB5bGltID0gYygwLDEwMCkpKw0KICB4bGltKDAsMTAwKQ0KDQoNCmdnc2F2ZSgiZmlncy9jb25jb3JkYW5jZS5wbmciLCBkcGkgPSA2MDAsIGhlaWdodCA9IDMuNSwgd2lkdGggPSA0KQ0KDQpgYGANCg0KIyBYeWxlbGxhDQoNCmBgYHtyIGV2YWw9RkFMU0UsIGluY2x1ZGU9VFJVRX0NCnBpY3M8LWxpc3QuZmlsZXMoIi4vcGljcy8wMS1YeWxlbGxhLXRvYmFjY28tYmctd2hpdGUiKQ0KIyBsZW5ndGgocGljcykNCiNpbmRpY2VzDQppbmRleCA9IGMoIkJJIiwiU0NJIiwiR0xJIiwiSEkiLCJTSSIsIlZBUkkiLCJIVUUiLCJCR0kiLCJOR1JESSIpDQoNCg0KYm94ID0gZGF0YS5mcmFtZSgpDQoNCmZvcihpIGluIDE6bGVuZ3RoKHBpY3MpKXsNCg0KRVguTDE8LXN0YWNrKHBhc3RlKCIuL3BpY3MvMDEtWHlsZWxsYS10b2JhY2NvLWJnLXdoaXRlLyIscGljc1tpXSxzZXAgPSAiIikpDQpFWC5MMTwtYWdncmVnYXRlKEVYLkwxLCBmYWN0PTcpDQpFWC5MLlNoYXBlPC1maWVsZFBvbHlnb24obW9zYWljPUVYLkwxLCBleHRlbnQ9VCwgcGxvdCA9IEYpDQoNCkVYMS5JbmRpY2VzPC0gZmllbGRJbmRleChtb3NhaWMgPSBFWC5MMSwNCiAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGluZGV4LCANCiAgICAgICAgICAgICAgICAgICAgICAgICBteUluZGV4ID0gYygiR3JlZW4iKSwgcGxvdCA9IEYpDQoNCkVYLkwyPC1maWVsZE1hc2sobW9zYWljPUVYLkwxLCAgbXlJbmRleCA9IGMoIkJsdWUiKSwgY3JvcFZhbHVlPTIwMCwgY3JvcEFib3ZlPVQsIHBsb3QgPSBGKQ0KDQpjdXQgPSBtYXNrKEVYLkwxLCBFWC5MMiRuZXdNb3NhaWMpDQpFWC5MNDwtZmllbGRJbmRleChtb3NhaWM9Y3V0LA0KICAgICAgICAgICAgICAgICAgaW5kZXggPWluZGV4LA0KICAgICAgICAgICAgICAgICAgcGxvdCA9RikNCg0KDQpkZiA9IGFzKEVYLkw0LCAiU3BhdGlhbFBpeGVsc0RhdGFGcmFtZSIpDQpkZmYgPSBhcy5kYXRhLmZyYW1lKGRmKSAlPiUgDQogIG11dGF0ZShncmF5ID0gMC4yOTkqUmVkKzAuNTg3KkdyZWVuKzAuMTE0KkJsdWUpICU+JSANCiAgZ2F0aGVyKGMoMTooMytsZW5ndGgoaW5kZXgpKSwxNSksIGtleSA9ICJpbmRleCIsIHZhbHVlID0gInZhbHVlIiApICU+JQ0KICBmaWx0ZXIoIWlzLm5hKHZhbHVlKSwNCiAgICAgICAgICFpcy5pbmZpbml0ZSh2YWx1ZSkpICU+JSANCiAgZ3JvdXBfYnkoaW5kZXgpICU+JSANCiAgZHBseXI6OnN1bW1hcmlzZShtZWFuID0gbWVhbih2YWx1ZSwgbmEucm0gPSBUKSwNCiAgICAgICAgICAgIHN0ZCA9IHNkKHZhbHVlKSwNCiAgICAgICAgICAgIFEyNSA9IHF1YW50aWxlKHZhbHVlLDAuMjUpLA0KICAgICAgICAgICAgUTUwID0gcXVhbnRpbGUodmFsdWUsMC41MCksDQogICAgICAgICAgICBRNzUgPSBxdWFudGlsZSh2YWx1ZSwwLjc1KSkgJT4lIA0KICBtdXRhdGUobGVhZiA9IHBpY3NbaV0pDQoNCg0KYm94ID0gYm94ICU+JSANCiAgYmluZF9yb3dzKGRmZil9DQpsZW5ndGgodW5pcXVlKGJveCRsZWFmKSkNCndyaXRlLnRhYmxlKGJveCwiZGF0YS9pbmRleGVzX1h5bGVsbGEudHh0IikNCmBgYA0KDQpgYGB7cn0NCmJveCA9IHJlYWQudGFibGUoImRhdGEvaW5kZXhlc19YeWxlbGxhLnR4dCIpDQpgYGANCg0KIyMgTG9hZA0KYGBge3J9DQpkYXRhX3h5X2xvYWQgPSByZWFkX2NzdigiZGF0YV9waWNzLzAxLVh5bGVsbGEtdG9iYWNjby1zZXZlcml0eS5jc3YiKSAlPiUgDQogIG11dGF0ZShmaWxlID0gYXMuY2hhcmFjdGVyKEZpbGUpKSAlPiUgDQogIGRwbHlyOjpzZWxlY3QoLUZpbGUpDQpgYGANCg0KYGBge3J9DQpkYXRhX3h5ID0gYm94ICU+JSANCiAgc2VwYXJhdGUobGVhZiwgaW50bz1jKCJmaWxlIiwiZm9ybWF0IiksIHNlcCA9Ii5qcGciKSAlPiUgDQogIGRwbHlyOjpzZWxlY3QoLWZvcm1hdCkgJT4lIA0KICBmdWxsX2pvaW4oZGF0YV94eV9sb2FkLCBieT0iZmlsZSIpICU+JSANCiAgbXV0YXRlKHNldj1JbWFnZUopDQpoZWFkKGRhdGFfeHkpDQoNCiMgbGVuZ3RoKHVuaXF1ZShkYXRhX3h5JHNldikpDQpgYGANCg0KYGBge3J9DQpzdW1tYXJ5KGRhdGFfeHkkc2V2KQ0KYGBgDQoNCg0KIyMjIEltYWdlcw0KDQpgYGB7cn0NCmhpc3Rfc2V2X3h5ID0gIGRhdGFfeHkgJT4lIA0KICBwaXZvdF93aWRlcihpZF9jb2wgPSBjKGZpbGUsc2V2KSwNCiAgICAgICAgICAgICAgbmFtZXNfZnJvbSA9IGluZGV4LCANCiAgICAgICAgICAgICAgdmFsdWVzX2Zyb20gPSAgbWVhbikgJT4lDQogIGdncGxvdChhZXMoc2V2KSkrDQogIGdlb21faGlzdG9ncmFtKGNvbG9yID0gIndoaXRlIiwgZmlsbCA9ICJibGFjayIsIGJpbnMgPSAyMCkrDQogIHRoZW1lX21pbmltYWxfaGdyaWQoZm9udF9zaXplID0gMTApKw0KICBsYWJzKHggPSAiU2V2ZXJpdHkgKCUpIiwNCiAgICAgICB5ID0gIkZyZXF1ZW5jeSIpKw0KICBzY2FsZV94X2NvbnRpbnVvdXMobGltaXRzID0gYygtNSwxMDUpLCBicmVha3MgPSBzZXEoMCwxMDAsMjUpKSsNCiAgIyB0aGVtZV92b2lkKCkrDQogICMgY29vcmRfZml4ZWQoKSsNCiAgdGhlbWUocGFuZWwuYmFja2dyb3VuZCA9IGVsZW1lbnRfcmVjdChjb2xvciA9ICJibGFjayIpKQ0KDQpgYGANCg0KYGBge3J9DQpFWC5MMTwtc3RhY2socGFzdGUoIi4vcGljcy8wMS1YeWxlbGxhLXRvYmFjY28tYmctd2hpdGUvIiwiNzUuanBnIixzZXAgPSAiIikpDQpFWC5MMTwtYWdncmVnYXRlKEVYLkwxLCBmYWN0PTcpDQpFWC5MLlNoYXBlPC1maWVsZFBvbHlnb24obW9zYWljPUVYLkwxLCBleHRlbnQ9VCwgcGxvdCA9IEYpDQoNCkVYMS5JbmRpY2VzPC0gZmllbGRJbmRleChtb3NhaWMgPSBFWC5MMSwNCiAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGluZGV4LCANCiAgICAgICAgICAgICAgICAgICAgICAgICBteUluZGV4ID0gYygiR3JlZW4iKSwgcGxvdCA9IEYpDQoNCkVYLkwyPC1maWVsZE1hc2sobW9zYWljPUVYLkwxLCAgbXlJbmRleCA9IGMoIkJsdWUiKSwgY3JvcFZhbHVlPTIwMCwgY3JvcEFib3ZlPVQsIHBsb3QgPSBGKQ0KDQpjdXQgPSBtYXNrKEVYLkwxLCBFWC5MMiRuZXdNb3NhaWMpDQpFWC5MNDwtZmllbGRJbmRleChtb3NhaWM9Y3V0LA0KICAgICAgICAgICAgICAgICAgaW5kZXggPWluZGV4LA0KICAgICAgICAgICAgICAgICAgcGxvdCA9RikNCiMgcGxvdChFWC5MNCRIVUUpDQpgYGANCg0KYGBge3J9DQpyZ2JfZmlnX3h5ID0gUlN0b29sYm94OjpnZ1JHQihFWC5MMiRuZXdNb3NhaWMsDQogICAgICAgICAgICAgICAgIHIgPSAxLA0KICAgICAgICAgICAgICAgICBnID0gMiwNCiAgICAgICAgICAgICAgICAgYiA9IDMpKw0KICB0aGVtZV9tYXAoKSsNCiAgY29vcmRfZml4ZWQoKSsNCiAgdGhlbWUocGFuZWwuYmFja2dyb3VuZCA9IGVsZW1lbnRfcmVjdChjb2xvciA9ICJ3aGl0ZSIpKQ0KDQoNCmdsaV9maWdfeHkgPSBhcy5kYXRhLmZyYW1lKEVYLkw0JEhVRSwgeHk9VFJVRSwgbmEucm0gPVQpICU+JSANCiAgZ2dwbG90KGFlcyh4LCB5LCBmaWxsID0gSFVFKSkrDQogIGdlb21fdGlsZSgpKw0KICBzY2FsZV9maWxsX3ZpcmlkaXNfYyhvcHRpb24gPSAiQiIsZGlyZWN0aW9uID0gLTEpKw0KICB0aGVtZV9tYXAoKSsNCiAgY29vcmRfZml4ZWQoKSsNCiAgdGhlbWUocGFuZWwuYmFja2dyb3VuZCA9IGVsZW1lbnRfcmVjdChjb2xvciA9ICJ3aGl0ZSIpLA0KICAgICAgICBsZWdlbmQudGl0bGUgPSBlbGVtZW50X3RleHQoc2l6ZSA9IDgpLA0KICAgICAgICBsZWdlbmQudGV4dCA9IGVsZW1lbnRfdGV4dChzaXplID0gOCkpDQoNCiMgcmdiX2ZpZ194eSsgZ2xpX2ZpZ194eQ0KYGBgDQoNCmBgYHtyfQ0KIyByZ2JfZmlnX3NiciArIGdsaV9maWdfc2JyICsgaGlzdF9zZXZfc2JyICMrDQojICAgcmdiX2ZpZ193bGIgKyBnbGlfZmlnX3dsYiArIGhpc3Rfc2V2X1dMQisNCiAgcmdiX2ZpZ194eSArIGdsaV9maWdfeHkgK2hpc3Rfc2V2X3h5DQojICAgIHBsb3RfbGF5b3V0KHdpZHRocyA9IGMoMSwgMSwgMSksDQojICAgICAgICAgICAgICAgIGhlaWdodHMgPSBjKDEsMSwxKSkNCiMgDQojIGdnc2F2ZSgiZmlncy9sZWFmX2dsaS5wbmciLGRwaSA9IDYwMCwgaGVpZ2h0ID0gNywgd2lkdGggPTgpDQpgYGANCg0KIyMjIFJlbGF0aW9uc2hpcCBzZXYgaW5kaWNlcw0KDQpgYGB7cn0NCnJnYl9nZ194eSA9IGRhdGFfeHkgJT4lIA0KICBmaWx0ZXIoaW5kZXggJWluJSBjKCJSZWQiLCAiQmx1ZSIsICJHcmVlbiIpKSAlPiUgDQogICAgZ2dwbG90KGFlcyhtZWFuLCBzZXYsIGNvbG9yID0gaW5kZXgpKSArIA0KICAjIGdlb21fdGV4dCgpKw0KICBnZW9tX3BvaW50KGNvbG9yID0gImdyYXkiLCBzaXplICA9MykrDQogIGdlb21fc21vb3RoKHNlID0gRiwgc2l6ZSA9IDIpKw0KICBmYWNldF93cmFwKH5pbmRleCwgc2NhbGVzID0gImZyZWVfeCIsIG5yb3cgPTEpKw0KICBzY2FsZV9jb2xvcl9tYW51YWwodmFsdWVzID0gYygic3RlZWxibHVlIiwiZGFya2dyZWVuIiwgImRhcmtyZWQiKSkrDQogIHRoZW1lX21pbmltYWxfaGdyaWQoKSsNCiAgbGFicyh4ID0gIk1lYW4gdmFsdWUgaW4gdGhlIGltYWdlIiwNCiAgICAgICB5ID0gIkRpc2Vhc2Ugc2V2ZXJpdHkgKCUpIikrDQogIHRoZW1lKHBhbmVsLmJvcmRlciA9IGVsZW1lbnRfcmVjdChjb2xvciA9ICJncmF5IikpKw0KICB0aGVtZShsZWdlbmQucG9zaXRpb24gPSAibm9uZSIpDQpyZ2JfZ2dfeHkNCmBgYA0KDQpgYGB7cn0NCmluZGV4X2dnX3h5ID0gZGF0YV94eSAlPiUgDQogIGZpbHRlcighaW5kZXggJWluJSBjKCJSZWQiLCAiQmx1ZSIsICJHcmVlbiIpKSAlPiUgDQogICAgZ2dwbG90KGFlcyhtZWFuLCBzZXYpKSArIA0KICAjIGdlb21fdGV4dCgpKw0KICBnZW9tX3BvaW50KGNvbG9yID0gImdyYXkiLCBzaXplICA9MykrDQogIGdlb21fc21vb3RoKGNvbG9yID0gImJsYWNrIiwgc2UgPSBGLCBzaXplID0gMikrDQogIGZhY2V0X3dyYXAofmluZGV4LCBzY2FsZXMgPSAiZnJlZV94IiwgbnJvdyA9MikrDQogIHRoZW1lX21pbmltYWxfaGdyaWQoKSsNCiAgbGFicyh4ID0gIk1lYW4gaW5kZXggdmFsdWUgaW4gdGhlIGltYWdlIiwNCiAgICAgICB5ID0gIkRpc2Vhc2Ugc2V2ZXJpdHkgKCUpIikrDQogIHRoZW1lKHBhbmVsLmJvcmRlciA9IGVsZW1lbnRfcmVjdChjb2xvciA9ICJncmF5IikpDQppbmRleF9nZ194eQ0KYGBgDQoNCmBgYHtyfQ0KcGxvdF9ncmlkKA0KICBwbG90X2dyaWQoTlVMTCxyZ2JfZ2dfeHksTlVMTCwgcmVsX3dpZHRocyA9YygwLjE4LDEsMC4yKSwgbnJvdyA9IDEpLA0KICAgICAgICAgIGluZGV4X2dnX3h5LA0KICAgICAgICAgIG5yb3cgPSAyLA0KICAgICAgICAgIHJlbF9oZWlnaHRzID0gYygwLjUsMSkpDQpnZ3NhdmUoImZpZ3MvaW5kZXhfc2V2X1hZLnBuZyIsIGRwaSA9IDUwMCwgaGVpZ2h0ID0gOCwgd2lkdGggPSAxMCkNCmBgYA0KDQpgYGB7cn0NCmNvcl94eSA9IGRhdGFfeHkgJT4lIA0KICBncm91cF9ieShpbmRleCkgJT4lIA0KICBkcGx5cjo6c3VtbWFyaXNlKGNvciA9IHJvdW5kKCAgY29yLnRlc3QobWVhbixzZXYsIG1ldGhvZCA9ICJzcGVhcm1hbiIpJGVzdGltYXRlLDMpLA0KICAgICAgICAgICAgICAgICAgIFBfdmFsdWUgPSByb3VuZChjb3IudGVzdChtZWFuLHNldiwgbWV0aG9kID0gInNwZWFybWFuIikkcC52YWx1ZSw0KSkgJT4lIA0KICBhcnJhbmdlKC1jb3IpDQpjb3JfeHkNCmBgYA0KDQojIyMgU3ByZWFkIGRmDQoNCmBgYHtyfQ0KYWxsX2RhdGFfc3ByZWFkX3h5ID0gZGF0YV94eSAlPiUgDQogIHBpdm90X3dpZGVyKGlkX2NvbCA9IGMoZmlsZSxzZXYpLA0KICAgICAgICAgICAgICBuYW1lc19mcm9tID0gaW5kZXgsIA0KICAgICAgICAgICAgICB2YWx1ZXNfZnJvbSA9ICBtZWFuKSAgIA0KDQpoZWFkKGFsbF9kYXRhX3NwcmVhZF94eSkNCmBgYA0KDQojIyBHQk0NCg0KYGBge3J9DQp0cmFpbj1zYW1wbGUoeCA9IDE6bGVuZ3RoKGFsbF9kYXRhX3NwcmVhZF94eSRzZXYpLCANCiAgICAgICAgICAgICBzaXplID0gcm91bmQoMC43NSpsZW5ndGgoYWxsX2RhdGFfc3ByZWFkX3h5JHNldiksMSkpDQojIGxlbmd0aCh0cmFpbikNCmdibS5maXQgPSBnYm0oc2V2IH5CR0krQkkrR0xJK0hJK0hVRStOR1JESStWQVJJK2dyYXkrIFJlZCtHcmVlbitCbHVlICArIFNJICsgU0NJLA0KICAgICAgICAgICAgIGRhdGEgPSBhbGxfZGF0YV9zcHJlYWRfeHlbdHJhaW4sXSwNCiAgICAgICAgICAgICBkaXN0cmlidXRpb24gPSAiZ2F1c3NpYW4iLA0KICAgICAgICAgICAgICBuLnRyZWVzID0gMTAwMCwNCiAgICAgICAgICAgICBpbnRlcmFjdGlvbi5kZXB0aCA9IDMsDQogICAgICAgICAgICAgc2hyaW5rYWdlID0gMC4xLA0KICAgICAgICAgICAgIGN2LmZvbGRzID0gNSwNCiAgICAgICAgICAgICBuLmNvcmVzID0gTlVMTCwgIyB3aWxsIHVzZSBhbGwgY29yZXMgYnkgZGVmYXVsdA0KICAgICAgICAgICAgIHZlcmJvc2UgPSBGQUxTRSkNCnByaW50KGdibS5maXQpDQpzcXJ0KG1pbihnYm0uZml0JGN2LmVycm9yKSkNCmBgYA0KDQpgYGB7cn0NCmdibS5wZXJmKGdibS5maXQsIG1ldGhvZCA9ICJjdiIpDQojIGZpbmQgaW5kZXggZm9yIG4gdHJlZXMgd2l0aCBtaW5pbXVtIENWIGVycm9yDQpgYGANCg0KYGBge3J9DQptaW5fTVNFIDwtIHdoaWNoLm1pbihnYm0uZml0JGN2LmVycm9yKQ0Kc3FydChnYm0uZml0JGN2LmVycm9yW21pbl9NU0VdKQ0KDQpgYGANCg0KYGBge3J9DQojIGJlc3QuaXRlciA8LSBnYm0ucGVyZihtb2RlbDEsIG1ldGhvZCA9ICJ0ZXN0IikNCiMgcHJpbnQoYmVzdC5pdGVyKQ0KDQpwcmVkID0gcHJlZGljdChnYm0uZml0LCBuZXdkYXRhID0gYWxsX2RhdGFfc3ByZWFkX3h5Wy10cmFpbiwtMV0sIG50cmVlcyA9IDUwMDAgKQ0KDQpzcXJ0KG1lYW4oKChwcmVkKS1hbGxfZGF0YV9zcHJlYWRfeHkkc2V2Wy10cmFpbl0pXjIpKQ0KQ0NDKChwcmVkKSwgYWxsX2RhdGFfc3ByZWFkX3h5JHNldlstdHJhaW5dKSRyaG8uYyRlc3QNCg0KcGxvdCgocHJlZCksIChwcmVkKS1hbGxfZGF0YV9zcHJlYWRfeHkkc2V2Wy10cmFpbl0pDQphYmxpbmUoYT0wLGI9MCkNCmBgYA0KDQojIyMgVGVzdGluZyB2YXJpb3VzIGh5cGVycGFyYW1ldGVycw0KDQpDcmVhdGUgaHlwZXJwYXJhbWV0ZXIgZ3JpZA0KDQpgYGB7cn0NCg0KaHlwZXJfZ3JpZCA8LSBleHBhbmQuZ3JpZCgNCiAgc2hyaW5rYWdlID0gYyguMDAxLCAuMDEsIC4xLCAuMyksDQogIGludGVyYWN0aW9uLmRlcHRoID0gYygxLCAzLCA1LCA2KSwNCiAgbi5taW5vYnNpbm5vZGUgPSBjKDUsIDEwLCAxNSksDQogIGJhZy5mcmFjdGlvbiA9IGMoLjUsLjY1LCAuOCwgMSksIA0KICBvcHRpbWFsX3RyZWVzID0gMCwgICAgICAgICAgICAgICAjIGEgcGxhY2UgdG8gZHVtcCByZXN1bHRzDQogIG1pbl9STVNFID0gMCwNCiAgQ0NDID0wICMgYSBwbGFjZSB0byBkdW1wIHJlc3VsdHMNCikNCiMgdG90YWwgbnVtYmVyIG9mIGNvbWJpbmF0aW9ucw0KbnJvdyhoeXBlcl9ncmlkKQ0KYGBgDQoNCmBgYHtyIG1lc3NhZ2U9RkFMU0UsIHdhcm5pbmc9RkFMU0V9DQojIHJhbmRvbWl6ZSBkYXRhDQpzZXQuc2VlZCgxMjMpDQp0cmFpbj1zYW1wbGUoeCA9IDE6bGVuZ3RoKGFsbF9kYXRhX3NwcmVhZF94eSRzZXYpLCANCiAgICAgICAgICAgICBzaXplID0gcm91bmQoMC44MCpsZW5ndGgoYWxsX2RhdGFfc3ByZWFkX3h5JHNldiksMSkpDQoNCiMgZ3JpZCBzZWFyY2ggDQpmb3IoaSBpbiAxOm5yb3coaHlwZXJfZ3JpZCkpIHsNCg0KIyByZXByb2R1Y2liaWxpdHkNCnNldC5zZWVkKDEyMykNCg0KDQogIyB0cmFpbiBtb2RlbA0KZ2JtLnR1bmUgPC0gZ2JtKA0KICBmb3JtdWxhID0gKHNldikgfkJHSStCSStHTEkrSEkrSFVFK05HUkRJK1ZBUkkrZ3JheSArUmVkK0dyZWVuK0JsdWUgKyBTSSArIFNDSSwgIzw8PDw8DQogIGRhdGEgPSBhbGxfZGF0YV9zcHJlYWRfeHlbdHJhaW4sXSwNCiAgZGlzdHJpYnV0aW9uID0gImdhdXNzaWFuIiwNCiAgbi50cmVlcyA9IDUwMDAsDQogIGludGVyYWN0aW9uLmRlcHRoID0gaHlwZXJfZ3JpZCRpbnRlcmFjdGlvbi5kZXB0aFtpXSwNCiAgc2hyaW5rYWdlID0gaHlwZXJfZ3JpZCRzaHJpbmthZ2VbaV0sDQogIG4ubWlub2JzaW5ub2RlID0gaHlwZXJfZ3JpZCRuLm1pbm9ic2lubm9kZVtpXSwNCiAgYmFnLmZyYWN0aW9uID0gaHlwZXJfZ3JpZCRiYWcuZnJhY3Rpb25baV0sDQogIHRyYWluLmZyYWN0aW9uID0gLjc1LA0KICBuLmNvcmVzID0gTlVMTCwgIyB3aWxsIHVzZSBhbGwgY29yZXMgYnkgZGVmYXVsdA0KICB2ZXJib3NlID0gRkFMU0UpDQoNCnByZWQgPSBwcmVkaWN0KGdibS50dW5lLCBuZXdkYXRhID0gYWxsX2RhdGFfc3ByZWFkX3h5Wy10cmFpbiwtMV0sIG50cmVlcyA9IDUwMDAgKQ0KICMgYWRkIG1pbiB0cmFpbmluZyBlcnJvciBhbmQgdHJlZXMgdG8gZ3JpZA0KICBoeXBlcl9ncmlkJG9wdGltYWxfdHJlZXNbaV0gPC0gd2hpY2gubWluKGdibS50dW5lJHZhbGlkLmVycm9yKQ0KICBoeXBlcl9ncmlkJG1pbl9STVNFW2ldIDwtIHNxcnQobWluKGdibS50dW5lJHZhbGlkLmVycm9yKSkNCiAgaHlwZXJfZ3JpZCRDQ0NbaV0gPSBDQ0MocHJlZCwgYWxsX2RhdGFfc3ByZWFkX3h5JHNldlstdHJhaW5dKSRyaG8uYyRlc3QjPDw8PDwNCiAgDQp9DQoNCmJlc3RfcGFyID0gaHlwZXJfZ3JpZCAlPiUgDQogIGRwbHlyOjphcnJhbmdlKC1DQ0MpICU+JQ0KICBoZWFkKDEwKQ0KYmVzdF9wYXINCg0KDQoNCiMgZ2JtLnR1bmUkZml0DQpgYGANCg0KIyMjIEJlc3QgbW9kZWwNCg0KYGBge3J9DQojIGZvciByZXByb2R1Y2liaWxpdHkNCnNldC5zZWVkKDEyMykNCg0KIyB0cmFpbiBHQk0gbW9kZWwNCmdibS5maXQuZmluYWxfeHkgPC0gZ2JtKA0KICBmb3JtdWxhID0gKHNldikgfkJHSStCSStHTEkrSEkrSFVFK05HUkRJK1ZBUkkrUmVkK0dyZWVuK0JsdWUrZ3JheStTSStTQ0ksDQogIGRhdGEgPSBhbGxfZGF0YV9zcHJlYWRfeHlbdHJhaW4sXSwNCiAgZGlzdHJpYnV0aW9uID0gImdhdXNzaWFuIiwNCiAgbi50cmVlcyA9IGJlc3RfcGFyJG9wdGltYWxfdHJlZXNbMV0sDQogIGludGVyYWN0aW9uLmRlcHRoID0gYmVzdF9wYXIkaW50ZXJhY3Rpb24uZGVwdGhbMV0sDQogIHNocmlua2FnZSA9IGJlc3RfcGFyJHNocmlua2FnZVsxXSwNCiAgbi5taW5vYnNpbm5vZGUgPSBiZXN0X3BhciRuLm1pbm9ic2lubm9kZVsxXSwNCiAgYmFnLmZyYWN0aW9uID0gYmVzdF9wYXIkYmFnLmZyYWN0aW9uWzFdLCANCiAgdHJhaW4uZnJhY3Rpb24gPTAuNzUsDQogIG4uY29yZXMgPSBOVUxMLCAjIHdpbGwgdXNlIGFsbCBjb3JlcyBieSBkZWZhdWx0DQogIHZlcmJvc2UgPSBGQUxTRQ0KICApDQoNCg0KYGBgDQoNCiMjIyBSZWxhdGl2ZSBpbmZsdWVuY2UNCg0KYGBge3J9DQpwYXIobWFyID0gYyg1LCA4LCAxLCAxKSkNCnN1bW1hcnlfZ2JtX3h5ID0gc3VtbWFyeSgNCiAgZ2JtLmZpdC5maW5hbF94eSwgDQogIGNCYXJzID0gMTUsDQogIG1ldGhvZCA9IHJlbGF0aXZlLmluZmx1ZW5jZSwgIyBhbHNvIGNhbiB1c2UgcGVybXV0YXRpb24udGVzdC5nYm0NCiAgbGFzID0gMg0KICApDQoNCnJlbF94eSA9IHN1bW1hcnlfZ2JtX3h5ICU+JSANCiAgcm93bmFtZXNfdG9fY29sdW1uKCJpbmRleCIpICU+JSANCiAgZ2dwbG90KGFlcyhyZWwuaW5mLCByZW9yZGVyKHZhciwgcmVsLmluZikpKSsNCiAgZ2VvbV9jb2woYWVzKGZpbGwgPXJlbC5pbmY+MSwgY29sb3IgPXJlbC5pbmY+MSApLCB3aWR0aCA9IDAuODUpKw0KICB0aGVtZV9taW5pbWFsX3ZncmlkKCkrDQogIGxhYnMoeCA9ICJSZWxhdGl2ZSBpbmZsdWVuY2UgKCUpIiwNCiAgICAgICB5ID0gIk1vZGVsIHByZWRpY3RvcnMiLA0KICAgICAgIGZpbGwgPSAiUkkgPiAxJSIsDQogICAgICAgY29sb3IgPSAiUkkgPiAxJSIpDQpyZWxfeHkNCiMgZ2dzYXZlKCJmaWdzL3Zhcl9pbmZsdWVuY2UucG5nIixkcGkgPSA2MDAsIGhlaWdodCA9IDQsIHdpZHRoID0gNikNCmBgYA0KDQpQYXJ0aWFsIGRlcGVuZGVuY2UgcGxvdHMNCg0KYGBge3J9DQpnYm0uZml0LmZpbmFsX3h5ICU+JQ0KICBwZHA6OnBhcnRpYWwocHJlZC52YXIgPSAiSFVFIiwgbi50cmVlcyA9IGdibS5maXQuZmluYWxfeHkkbi50cmVlcywgZ3JpZC5yZXNvbHV0aW9uID0gMTAwKSAlPiUNCiAgZ2dwbG90KGFlcyggSFVFLCh5aGF0KSkpKw0KICBnZW9tX2xpbmUoKQ0KYGBgDQoNCkxJTUUNCg0KYGBge3J9DQpsaWJyYXJ5KGxpbWUpDQpgYGANCg0KYGBge3J9DQptb2RlbF90eXBlLmdibSA8LSBmdW5jdGlvbih4LCAuLi4pIHsNCiAgcmV0dXJuKCJyZWdyZXNzaW9uIikNCn0NCg0KcHJlZGljdF9tb2RlbC5nYm0gPC0gZnVuY3Rpb24oeCwgbmV3ZGF0YSwgLi4uKSB7DQogIHByZWQgPC0gcHJlZGljdCh4LCBuZXdkYXRhLCBuLnRyZWVzID0geCRuLnRyZWVzKQ0KICByZXR1cm4oYXMuZGF0YS5mcmFtZShwcmVkKSkNCn0NCmBgYA0KDQpgYGB7cn0NCiMgZ2V0IGEgZmV3IG9ic2VydmF0aW9ucyB0byBwZXJmb3JtIGxvY2FsIGludGVycHJldGF0aW9uIG9uDQpsb2NhbF9vYnMgPC0gKGFsbF9kYXRhX3NwcmVhZF94eVstdHJhaW4sXSlbMTo0LCBdDQoNCiMgYXBwbHkgTElNRQ0KZXhwbGFpbmVyIDwtIGxpbWUoYWxsX2RhdGFfc3ByZWFkX3h5W3RyYWluLF0sIGdibS5maXQuZmluYWxfeHkpDQpleHBsYW5hdGlvbiA8LSBsaW1lOjpleHBsYWluKGxvY2FsX29icywgZXhwbGFpbmVyLCBuX2ZlYXR1cmVzID0gNywgbi50cmVlcyA9MSkNCnBsb3RfZmVhdHVyZXMoZXhwbGFuYXRpb24pDQoNCg0KYGBgDQoNCiMjIFByZWRpY3Rpb24NCg0KYGBge3J9DQojIHByZWRpY3QgdmFsdWVzIGZvciB0ZXN0IGRhdGENCnByZWQgPC0gcHJlZGljdChnYm0uZml0LmZpbmFsX3h5LA0KICAgICAgICAgICAgICAgIG4udHJlZXMgPSBnYm0uZml0LmZpbmFsX3h5JG4udHJlZXMsDQogICAgICAgICAgICAgICAgYWxsX2RhdGFfc3ByZWFkX3h5Wy10cmFpbixdKQ0KDQojIHJlc3VsdHMNCmNhcmV0OjpSTVNFKChwcmVkKSwgYWxsX2RhdGFfc3ByZWFkX3h5Wy10cmFpbixdJHNldikNCkNDQygocHJlZCksIGFsbF9kYXRhX3NwcmVhZF94eSRzZXZbLXRyYWluXSkkcmhvLmMkZXN0DQpjb3IoKHByZWQpLCBhbGxfZGF0YV9zcHJlYWRfeHkkc2V2Wy10cmFpbl0pXjINCg0KYGBgDQoNCmBgYHtyfQ0KYWNjdXJhY3lfeHkgPWRhdGEuZnJhbWUocHJlZGk9cHJlZCwgYWN0dWFsID0gYWxsX2RhdGFfc3ByZWFkX3h5JHNldlstdHJhaW5dKSAlPiUgDQogIHN1bW1hcmlzZShSTVNFID0gY2FyZXQ6OlJNU0UocHJlZCwgYWN0dWFsKSwNCiAgICAgICAgICAgIHIgPSBjb3IocHJlZCwgYWN0dWFsKSwNCiAgICAgICAgICAgIHMuc2hpZnQgPSBDQ0MocHJlZCwgYWN0dWFsKSRzLnNoaWZ0LA0KICAgICAgICAgICAgbC5zaGlmdCA9IENDQyhwcmVkLCBhY3R1YWwpJGwuc2hpZnQsDQogICAgICAgICAgICBDLmIgPSBDQ0MocHJlZCwgYWN0dWFsKSRDLmIsDQogICAgICAgICAgICBDQ0MgPSBDQ0MocHJlZCwgYWN0dWFsKSRyaG8uYyRlc3QsDQogICAgICAgICAgICBDSVMgPSBwYXN0ZSgNCiAgcm91bmQoQ0NDKHByZWQsIGFsbF9kYXRhX3NwcmVhZF94eSRzZXZbLXRyYWluXSkkcmhvLmNbMl0sMiksIiwiLCIgIiwNCiAgcm91bmQoQ0NDKHByZWQsIGFsbF9kYXRhX3NwcmVhZF94eSRzZXZbLXRyYWluXSkkcmhvLmNbM10sMiksc2VwID0gIiINCiAgKSkNCmFjY3VyYWN5X3h5DQpgYGANCg0KDQojIyMjIHBsb3QNCmBgYHtyfQ0KDQpjb25jX3h5ID0gZGF0YS5mcmFtZShwcmVkaWN0ID0gcHJlZCwgYWN0dWFsID1hbGxfZGF0YV9zcHJlYWRfeHkkc2V2Wy10cmFpbl0pICU+JSANCmdncGxvdChhZXMoYWN0dWFsLHByZWRpY3QpKSsNCiAgZ2VvbV9wb2ludChzaXplID0yLCBjb2xvciA9ICJncmF5IikrDQogIGdlb21fYWJsaW5lKGludGVyY2VwdCA9IDAsIHNsb3BlPSAxLCBzaXplID0gLjgxLCBjb2xvciA9ICJibGFjayIsIGxpbmV0eXBlID0gImRhc2hlZCIpKw0KICBnZW9tX3Ntb290aChtZXRob2QgPSAibG0iLCANCiAgICAgICAgICAgICAgY29sb3IgPSAicmVkIiwNCiAgICAgICAgICAgICAgc2l6ZSA9LjgxLCBzZSA9RiwNCiAgICAgICAgICAgICAgZnVsbHJhbmdlPVQpKw0KICB0aGVtZV9taW5pbWFsX2dyaWQoKSsNCiAgbGFicyh4ID0gIlByZWRpY3RlZCBTZXZlcml0eSAoJSkiLA0KICAgICAgIHkgPSAiQWN0dWFsIFNldmVyaXR5ICglKSIpKw0KICBjb29yZF9lcXVhbCh4bGltID0gYygwLDEwMCksDQogICAgICAgICAgICAgIHlsaW0gPSBjKDAsMTAwKSkrDQogIHhsaW0oMCwxMDApDQoNCg0KZ2dzYXZlKCJmaWdzL2NvbmNvcmRhbmNlLnBuZyIsIGRwaSA9IDYwMCwgaGVpZ2h0ID0gMy41LCB3aWR0aCA9IDQpDQoNCmBgYA0KDQojIExhdGUgYmxpZ2h0DQoNCmBgYHtyIGV2YWw9RkFMU0UsIGluY2x1ZGU9VFJVRX0NCnBpY3M8LWxpc3QuZmlsZXMoIi4vcGljcy8wMSAtIFBMQiIpDQojIGxlbmd0aChwaWNzKQ0KI2luZGljZXMNCmluZGV4ID0gYygiQkkiLCJTQ0kiLCJHTEkiLCJISSIsIlNJIiwiVkFSSSIsIkhVRSIsIkJHSSIsIk5HUkRJIikNCg0KDQpib3ggPSBkYXRhLmZyYW1lKCkNCg0KZm9yKGkgaW4gMTpsZW5ndGgocGljcykpew0KDQpFWC5MMTwtc3RhY2socGFzdGUoIi4vcGljcy8wMSAtIFBMQi8iLHBpY3NbaV0sc2VwID0gIiIpKQ0KRVguTDE8LWFnZ3JlZ2F0ZShFWC5MMSwgZmFjdD00KQ0KRVguTC5TaGFwZTwtZmllbGRQb2x5Z29uKG1vc2FpYz1FWC5MMSwgZXh0ZW50PVQsIHBsb3QgPSBGKQ0KDQojIEVYMS5JbmRpY2VzPC0gZmllbGRJbmRleChtb3NhaWMgPSBFWC5MMSwNCiMgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gYygiTkdSREkiLCJCR0kiLCJHTEkiLCAiU0NJIiwiSEkiLCAiU0kiKSwgDQojICAgICAgICAgICAgICAgICAgICAgICAgICBteUluZGV4ID0gYygiKFJlZC1CbHVlKS9HcmVlbiIpLCBwbG90ID0gRikNCg0KRVguTDI8LWZpZWxkTWFzayhtb3NhaWM9RVguTDEsIG15SW5kZXggPSJSZWQiLCBjcm9wVmFsdWU9MSwgY3JvcEFib3ZlPUYsIHBsb3QgPSBGKQ0KDQpjdXQgPSBtYXNrKEVYLkwxLCBFWC5MMiRtYXNrKQ0KRVguTDQ8LWZpZWxkSW5kZXgobW9zYWljPWN1dCwNCiAgICAgICAgICAgICAgICAgIGluZGV4ID1pbmRleCwNCiAgICAgICAgICAgICAgICAgIHBsb3QgPUYpDQoNCg0KZGYgPSBhcyhFWC5MNCwgIlNwYXRpYWxQaXhlbHNEYXRhRnJhbWUiKQ0KZGZmID0gYXMuZGF0YS5mcmFtZShkZikgJT4lIA0KICBtdXRhdGUoZ3JheSA9IDAuMjk5KlJlZCswLjU4NypHcmVlbiswLjExNCpCbHVlKSAlPiUgDQogIGdhdGhlcihjKDE6KDMrbGVuZ3RoKGluZGV4KSksMTUpLCBrZXkgPSAiaW5kZXgiLCB2YWx1ZSA9ICJ2YWx1ZSIgKSAlPiUNCiAgZmlsdGVyKCFpcy5uYSh2YWx1ZSksDQogICAgICAgICAhaXMuaW5maW5pdGUodmFsdWUpKSAlPiUgDQogIGdyb3VwX2J5KGluZGV4KSAlPiUgDQogIGRwbHlyOjpzdW1tYXJpc2UobWVhbiA9IG1lYW4odmFsdWUsIG5hLnJtID0gVCksDQogICAgICAgICAgICBzdGQgPSBzZCh2YWx1ZSksDQogICAgICAgICAgICBRMjUgPSBxdWFudGlsZSh2YWx1ZSwwLjI1KSwNCiAgICAgICAgICAgIFE1MCA9IHF1YW50aWxlKHZhbHVlLDAuNTApLA0KICAgICAgICAgICAgUTc1ID0gcXVhbnRpbGUodmFsdWUsMC43NSkpICU+JSANCiAgbXV0YXRlKGxlYWYgPSBwaWNzW2ldKQ0KDQoNCmJveCA9IGJveCAlPiUgDQogIGJpbmRfcm93cyhkZmYpfQ0KbGVuZ3RoKHVuaXF1ZShib3gkbGVhZikpDQp3cml0ZS50YWJsZShib3gsImRhdGEvaW5kZXhlc19QTEIudHh0IikNCmBgYA0KDQpgYGB7cn0NCmJveCA9IHJlYWQudGFibGUoImRhdGEvaW5kZXhlc19QTEIudHh0IikNCmBgYA0KDQojIyBMb2FkIHNldmVyaXR5IGRhdGENCg0KYGBge3J9DQpsaWJyYXJ5KGdzaGVldCkNCg0KDQpzZXZfZGF0YV9wbGIyID0gZ3NoZWV0MnRibCgiaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vc3ByZWFkc2hlZXRzL2QvMWNueEdQWEJZVlI5bHEwSW5LaGhNTWpyLWNRMjF2Q2YzcTZpdzhWRWk2cFkvZWRpdCNnaWQ9NDQ1MDc0NDc2IikgJT4lIA0KICB1bml0ZSgiZmlsZSIsMToyLCBzZXAgPSAiLiIpDQoNCg0KDQpsZW5ndGgodW5pcXVlKHNldl9kYXRhX3BsYjIkZmlsZSkpDQpgYGANCg0KYGBge3J9DQojbmV3IGV2YWx1YXRpb24NCmFsbF9kYXRhX1BJID0gYm94ICU+JSANCiAgbXV0YXRlKGZpbGUgPSBsZWFmKSAlPiUgDQogIGRwbHlyOjpzZWxlY3QoLWxlYWYpICU+JSANCiAgIyBzZXBhcmF0ZShmaWxlLCBpbnRvID0gYygiZmlsZSIsICJmb3JtYXQiKSwgc2VwID0gIi4iKSAlPiUgDQogICMgZHBseXI6OnNlbGVjdCgtZm9ybWF0KSAlPiUNCiAgcmlnaHRfam9pbihzZXZfZGF0YV9wbGIyKQ0KYGBgDQoNCmBgYHtyfQ0KIyBhbGxfZGF0YV9QSSA9IGJveCAlPiUgDQojICAgbXV0YXRlKGZpbGUgPSBsZWFmKSAlPiUgDQojICAgZHBseXI6OnNlbGVjdCgtbGVhZikgJT4lIA0KIyAgIHJpZ2h0X2pvaW4oc2V2X2RhdGEpICMlPiUgDQojICAgIyBmaWx0ZXIoc2V2PjApICU+JSANCiMgICAjIG11dGF0ZShzZXYgPSBjYXNlX3doZW4oc2V2PT0wIH4wLjAwMSwNCiMgICAjICAgICAgICAgICAgICAgICAgICAgICAgc2V2ID4wIH5zZXYpKQ0KYGBgDQoNCmBgYHtyfQ0Kc3VtbWFyeShhbGxfZGF0YV9QSSRzZXYpDQpgYGANCg0KIyMjIEltYWdlcw0KDQpgYGB7cn0NCmhpc3Rfc2V2X3BpID0gIGFsbF9kYXRhX1BJICU+JSANCiAgcGl2b3Rfd2lkZXIoaWRfY29sID0gYyhmaWxlLHNldiksDQogICAgICAgICAgICAgIG5hbWVzX2Zyb20gPSBpbmRleCwgDQogICAgICAgICAgICAgIHZhbHVlc19mcm9tID0gIG1lYW4pICU+JSANCiAgZ2dwbG90KGFlcyhzZXYpKSsNCiAgZ2VvbV9oaXN0b2dyYW0oY29sb3IgPSAid2hpdGUiLCBmaWxsID0gImJsYWNrIiwgYmlucyA9MjApKw0KICB0aGVtZV9taW5pbWFsX2hncmlkKGZvbnRfc2l6ZSA9IDEwKSsNCiAgbGFicyh4ID0gIlNldmVyaXR5ICglKSIsDQogICAgICAgeSA9ICJGcmVxdWVuY3kiKSsNCiAgc2NhbGVfeF9jb250aW51b3VzKGxpbWl0cyA9IGMoLTUsMTA1KSwgYnJlYWtzID0gc2VxKDAsMTAwLDI1KSkrDQogICMgdGhlbWVfdm9pZCgpKw0KICAjIGNvb3JkX2ZpeGVkKCkrDQogIHRoZW1lKHBhbmVsLmJhY2tncm91bmQgPSBlbGVtZW50X3JlY3QoY29sb3IgPSAiYmxhY2siKSwNCiAgICAgICAgYXhpcy50aXRsZS55ID0gZWxlbWVudF90ZXh0KHNpemU9OCkpDQoNCmBgYA0KDQpgYGB7cn0NCkVYLkwxPC1zdGFjayhwYXN0ZSgiLi9waWNzLzAxLXBvdGF0b19sYXRlX2JsaWdoLyIsIlBJMjFfMkQucG5nIixzZXAgPSAiIikpDQpFWC5MMTwtYWdncmVnYXRlKEVYLkwxLCBmYWN0PTEwKQ0KRVguTC5TaGFwZTwtZmllbGRQb2x5Z29uKG1vc2FpYz1FWC5MMSwgZXh0ZW50PVQsIHBsb3QgPSBGKQ0KDQpFWDEuSW5kaWNlczwtIGZpZWxkSW5kZXgobW9zYWljID0gRVguTDEsDQogICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpbmRleCwgDQogICAgICAgICAgICAgICAgICAgICAgICAgbXlJbmRleCA9IGMoIkdyZWVuIiksIHBsb3QgPSBGKQ0KDQpFWC5MMjwtZmllbGRNYXNrKG1vc2FpYz1FWC5MMSwgIG15SW5kZXggPSBjKCJSZWQiKSwgY3JvcFZhbHVlPTEsIGNyb3BBYm92ZT1GLCBwbG90ID0gRikNCg0KY3V0ID0gbWFzayhFWC5MMSwgRVguTDIkbmV3TW9zYWljKQ0KRVguTDQ8LWZpZWxkSW5kZXgobW9zYWljPWN1dCwNCiAgICAgICAgICAgICAgICAgIGluZGV4ID1pbmRleCwNCiAgICAgICAgICAgICAgICAgIHBsb3QgPSBGKQ0KIyBwbG90KEVYLkw0JEhVRSkNCmBgYA0KDQpgYGB7cn0NCnJnYl9maWdfcGkgPSBSU3Rvb2xib3g6OmdnUkdCKEVYLkwyJG5ld01vc2FpYywNCiAgICAgICAgICAgICAgICAgciA9IDEsDQogICAgICAgICAgICAgICAgIGcgPSAyLA0KICAgICAgICAgICAgICAgICBiID0gMykrDQogIHRoZW1lX21hcCgpKw0KICBjb29yZF9maXhlZCgpKw0KICB4bGltKDI1MCwxNTAwKSsNCiAgeWxpbSg1MCwxMzAwKSsNCiAgdGhlbWUocGFuZWwuYmFja2dyb3VuZCA9IGVsZW1lbnRfcmVjdChjb2xvciA9ICJ3aGl0ZSIpKQ0KDQoNCmdsaV9maWdfcGkgPSBhcy5kYXRhLmZyYW1lKEVYLkw0JEJHSSwgeHk9VFJVRSwgbmEucm0gPVQpICU+JSANCiAgZ2dwbG90KGFlcyh4LCB5LCBmaWxsID0gQkdJKSkrDQogIGdlb21fdGlsZSgpKw0KICBzY2FsZV9maWxsX3ZpcmlkaXNfYyhvcHRpb24gPSAiQiIsZGlyZWN0aW9uID0gLTEpKw0KICB0aGVtZV9tYXAoKSsNCiAgY29vcmRfZml4ZWQoKSsNCiAgeGxpbSgyNTAsMTUwMCkrDQogIHlsaW0oNTAsMTMwMCkrDQogIHRoZW1lKHBhbmVsLmJhY2tncm91bmQgPSBlbGVtZW50X3JlY3QoY29sb3IgPSAid2hpdGUiKSwNCiAgICAgICAgbGVnZW5kLnRpdGxlID0gZWxlbWVudF90ZXh0KHNpemUgPSA4KSwNCiAgICAgICAgbGVnZW5kLnRleHQgPSBlbGVtZW50X3RleHQoc2l6ZSA9IDgpKQ0KDQojIHJnYl9maWdfcGkgKyBnbGlfZmlnX3BpDQoNCmBgYA0KDQpgYGB7cn0NCiMgcmdiX2ZpZ19zYnIgKyBnbGlfZmlnX3NiciArIGhpc3Rfc2V2X3NiciAjKw0KIyAgIHJnYl9maWdfd2xiICsgZ2xpX2ZpZ193bGIgKyBoaXN0X3Nldl9XTEIrDQojICAgcmdiX2ZpZ194eSArIGdsaV9maWdfeHkgK2hpc3Rfc2V2X3h5Kw0KICByZ2JfZmlnX3BpICsgZ2xpX2ZpZ19waSAraGlzdF9zZXZfcGkNCiMgICAgcGxvdF9sYXlvdXQod2lkdGhzID0gYygxLCAxLCAxKSwNCiMgICAgICAgICAgICAgICAgaGVpZ2h0cyA9IGMoMSwxLDEsMSkpKw0KIyAgIHBsb3RfYW5ub3RhdGlvbih0YWdfbGV2ZWxzID0gJ0EnKQ0KDQojIGdnc2F2ZSgiZmlncy9sZWFmX2dsaS5wbmciLGRwaSA9IDYwMCwgaGVpZ2h0ID0gOCwgd2lkdGggPTgpDQpgYGANCg0KIyMjIFJlbGF0aW9uc2hpcCBzZXYgaW5kaWNlcw0KDQpgYGB7cn0NCnJnYl9nZ19waSA9IGFsbF9kYXRhX1BJICU+JSANCiAgZmlsdGVyKGluZGV4ICVpbiUgYygiUmVkIiwgIkJsdWUiLCAiR3JlZW4iKSkgJT4lIA0KICAgIGdncGxvdChhZXMobWVhbiwgc2V2LCBjb2xvciA9IGluZGV4KSkgKyANCiAgIyBnZW9tX3RleHQoKSsNCiAgZ2VvbV9wb2ludChjb2xvciA9ICJncmF5Iiwgc2l6ZSAgPTMpKw0KICBnZW9tX3Ntb290aChzZSA9IEYsIHNpemUgPSAyKSsNCiAgZmFjZXRfd3JhcCh+aW5kZXgsIHNjYWxlcyA9ICJmcmVlX3giLCBucm93ID0xKSsNCiAgc2NhbGVfY29sb3JfbWFudWFsKHZhbHVlcyA9IGMoInN0ZWVsYmx1ZSIsImRhcmtncmVlbiIsICJkYXJrcmVkIikpKw0KICB0aGVtZV9taW5pbWFsX2hncmlkKCkrDQogIGxhYnMoeCA9ICJNZWFuIHZhbHVlIGluIHRoZSBpbWFnZSIsDQogICAgICAgeSA9ICJEaXNlYXNlIHNldmVyaXR5ICglKSIpKw0KICB0aGVtZShwYW5lbC5ib3JkZXIgPSBlbGVtZW50X3JlY3QoY29sb3IgPSAiZ3JheSIpKSsNCiAgdGhlbWUobGVnZW5kLnBvc2l0aW9uID0gIm5vbmUiKQ0KcmdiX2dnX3BpDQpgYGANCg0KYGBge3J9DQppbmRleF9nZ19waSA9IGFsbF9kYXRhX1BJICU+JSANCiAgZmlsdGVyKCFpbmRleCAlaW4lIGMoIlJlZCIsICJCbHVlIiwgIkdyZWVuIikpICU+JSANCiAgICBnZ3Bsb3QoYWVzKG1lYW4sIHNldikpICsgDQogICMgZ2VvbV90ZXh0KCkrDQogIGdlb21fcG9pbnQoY29sb3IgPSAiZ3JheSIsIHNpemUgID0zKSsNCiAgZ2VvbV9zbW9vdGgoY29sb3IgPSAiYmxhY2siLCBzZSA9IEYsIHNpemUgPSAyKSsNCiAgZmFjZXRfd3JhcCh+aW5kZXgsIHNjYWxlcyA9ICJmcmVlX3giLCBucm93ID0yKSsNCiAgdGhlbWVfbWluaW1hbF9oZ3JpZCgpKw0KICBsYWJzKHggPSAiTWVhbiBpbmRleCB2YWx1ZSBpbiB0aGUgaW1hZ2UiLA0KICAgICAgIHkgPSAiRGlzZWFzZSBzZXZlcml0eSAoJSkiKSsNCiAgdGhlbWUocGFuZWwuYm9yZGVyID0gZWxlbWVudF9yZWN0KGNvbG9yID0gImdyYXkiKSkNCmluZGV4X2dnX3BpDQpgYGANCg0KYGBge3J9DQpwbG90X2dyaWQoDQogIHBsb3RfZ3JpZChOVUxMLHJnYl9nZ19waSxOVUxMLCByZWxfd2lkdGhzID1jKDAuMTgsMSwwLjIpLCBucm93ID0gMSksDQogICAgICAgICAgaW5kZXhfZ2dfcGksDQogICAgICAgICAgbnJvdyA9IDIsDQogICAgICAgICAgcmVsX2hlaWdodHMgPSBjKDAuNSwxKSkNCmdnc2F2ZSgiZmlncy9pbmRleF9zZXZfcGkucG5nIiwgZHBpID0gNTAwLCBoZWlnaHQgPSA4LCB3aWR0aCA9IDEwKQ0KYGBgDQoNCmBgYHtyfQ0KY29yX1BJID0gYWxsX2RhdGFfUEkgJT4lIA0KICBncm91cF9ieShpbmRleCkgJT4lIA0KICBkcGx5cjo6c3VtbWFyaXNlKGNvciA9IHJvdW5kKCAgY29yLnRlc3QobWVhbixzZXYsIG1ldGhvZCA9ICJzcGVhcm1hbiIpJGVzdGltYXRlLDMpLA0KICAgICAgICAgICAgICAgICAgIFBfdmFsdWUgPSByb3VuZChjb3IudGVzdChtZWFuLHNldiwgbWV0aG9kID0gInNwZWFybWFuIikkcC52YWx1ZSw0KSkgJT4lIA0KICBhcnJhbmdlKC1jb3IpDQpjb3JfUEkNCmBgYA0KDQojIyMgU3ByZWFkIGRmDQoNCmBgYHtyfQ0KYWxsX2RhdGFfc3ByZWFkX3BsYiA9IGFsbF9kYXRhX1BJICU+JSANCiAgcGl2b3Rfd2lkZXIoaWRfY29sID0gYyhmaWxlLHNldiksDQogICAgICAgICAgICAgIG5hbWVzX2Zyb20gPSBpbmRleCwgDQogICAgICAgICAgICAgIHZhbHVlc19mcm9tID0gIG1lYW4pICAgDQoNCmhlYWQoYWxsX2RhdGFfc3ByZWFkX3BsYikNCmBgYA0KDQojIyMgR0JNDQoNCmBgYHtyfQ0KdHJhaW49c2FtcGxlKHggPSAxOmxlbmd0aChhbGxfZGF0YV9zcHJlYWRfcGxiJHNldiksIA0KICAgICAgICAgICAgIHNpemUgPSByb3VuZCgwLjc1Kmxlbmd0aChhbGxfZGF0YV9zcHJlYWRfcGxiJHNldiksMSkpDQojIGxlbmd0aCh0cmFpbikNCmdibS5maXQgPSBnYm0oc2V2IH5CR0krQkkrR0xJK0hJK0hVRStOR1JESStWQVJJK2dyYXkrIFJlZCtHcmVlbitCbHVlICArIFNJICsgU0NJLA0KICAgICAgICAgICAgIGRhdGEgPSBhbGxfZGF0YV9zcHJlYWRfcGxiW3RyYWluLF0sDQogICAgICAgICAgICAgZGlzdHJpYnV0aW9uID0gImdhdXNzaWFuIiwNCiAgICAgICAgICAgICAgbi50cmVlcyA9IDEwMDAsDQogICAgICAgICAgICAgaW50ZXJhY3Rpb24uZGVwdGggPSAzLA0KICAgICAgICAgICAgIHNocmlua2FnZSA9IDAuMSwNCiAgICAgICAgICAgICBjdi5mb2xkcyA9IDUsDQogICAgICAgICAgICAgbi5jb3JlcyA9IE5VTEwsICMgd2lsbCB1c2UgYWxsIGNvcmVzIGJ5IGRlZmF1bHQNCiAgICAgICAgICAgICB2ZXJib3NlID0gRkFMU0UpDQpwcmludChnYm0uZml0KQ0Kc3FydChtaW4oZ2JtLmZpdCRjdi5lcnJvcikpDQpgYGANCg0KYGBge3J9DQpnYm0ucGVyZihnYm0uZml0LCBtZXRob2QgPSAiY3YiKQ0KIyBmaW5kIGluZGV4IGZvciBuIHRyZWVzIHdpdGggbWluaW11bSBDViBlcnJvcg0KYGBgDQoNCmBgYHtyfQ0KbWluX01TRSA8LSB3aGljaC5taW4oZ2JtLmZpdCRjdi5lcnJvcikNCnNxcnQoZ2JtLmZpdCRjdi5lcnJvclttaW5fTVNFXSkNCmBgYA0KDQpgYGB7cn0NCiMgYmVzdC5pdGVyIDwtIGdibS5wZXJmKG1vZGVsMSwgbWV0aG9kID0gInRlc3QiKQ0KIyBwcmludChiZXN0Lml0ZXIpDQoNCnByZWQgPSBwcmVkaWN0KGdibS5maXQsIG5ld2RhdGEgPSBhbGxfZGF0YV9zcHJlYWRfcGxiWy10cmFpbiwtMV0sIG50cmVlcyA9IDUwMDAgKQ0KDQpzcXJ0KG1lYW4oKChwcmVkKS1hbGxfZGF0YV9zcHJlYWRfcGxiJHNldlstdHJhaW5dKV4yKSkNCkNDQygocHJlZCksIGFsbF9kYXRhX3NwcmVhZF9wbGIkc2V2Wy10cmFpbl0pJHJoby5jJGVzdA0KDQpwbG90KChwcmVkKSwgKHByZWQpLWFsbF9kYXRhX3NwcmVhZF9wbGIkc2V2Wy10cmFpbl0pDQphYmxpbmUoYT0wLGI9MCkNCmBgYA0KDQojIyMgVGVzdGluZyB2YXJpb3VzIGh5cGVycGFyYW1ldGVycw0KDQpDcmVhdGUgaHlwZXJwYXJhbWV0ZXIgZ3JpZA0KDQpgYGB7cn0NCg0KaHlwZXJfZ3JpZCA8LSBleHBhbmQuZ3JpZCgNCiAgc2hyaW5rYWdlID0gYyguMDAxLCAuMDEsIC4xLCAuMyksDQogIGludGVyYWN0aW9uLmRlcHRoID0gYygxLCAzLCA1LCA2KSwNCiAgbi5taW5vYnNpbm5vZGUgPSBjKDUsIDEwLCAxNSksDQogIGJhZy5mcmFjdGlvbiA9IGMoLjUsLjY1LCAuOCwgMSksIA0KICBvcHRpbWFsX3RyZWVzID0gMCwgICAgICAgICAgICAgICAjIGEgcGxhY2UgdG8gZHVtcCByZXN1bHRzDQogIG1pbl9STVNFID0gMCwNCiAgQ0NDID0wICMgYSBwbGFjZSB0byBkdW1wIHJlc3VsdHMNCikNCiMgdG90YWwgbnVtYmVyIG9mIGNvbWJpbmF0aW9ucw0KbnJvdyhoeXBlcl9ncmlkKQ0KYGBgDQoNCmBgYHtyIG1lc3NhZ2U9RkFMU0UsIHdhcm5pbmc9RkFMU0V9DQojIHJhbmRvbWl6ZSBkYXRhDQpzZXQuc2VlZCgxMjMpDQp0cmFpbj1zYW1wbGUoeCA9IDE6bGVuZ3RoKGFsbF9kYXRhX3NwcmVhZF9wbGIkc2V2KSwgDQogICAgICAgICAgICAgc2l6ZSA9IHJvdW5kKDAuODAqbGVuZ3RoKGFsbF9kYXRhX3NwcmVhZF9wbGIkc2V2KSwxKSkNCg0KIyBncmlkIHNlYXJjaCANCmZvcihpIGluIDE6bnJvdyhoeXBlcl9ncmlkKSkgew0KDQojIHJlcHJvZHVjaWJpbGl0eQ0Kc2V0LnNlZWQoMTIzKQ0KDQoNCiAjIHRyYWluIG1vZGVsDQpnYm0udHVuZSA8LSBnYm0oDQogIGZvcm11bGEgPSBzZXYgfkJHSStCSStHTEkrSEkrSFVFK05HUkRJK1ZBUkkrZ3JheSsgUmVkK0dyZWVuK0JsdWUgICsgU0kgKyBTQ0ksIA0KICBkYXRhID0gYWxsX2RhdGFfc3ByZWFkX3BsYlt0cmFpbixdLA0KICBkaXN0cmlidXRpb24gPSAiZ2F1c3NpYW4iLA0KICBuLnRyZWVzID0gNTAwMCwNCiAgaW50ZXJhY3Rpb24uZGVwdGggPSBoeXBlcl9ncmlkJGludGVyYWN0aW9uLmRlcHRoW2ldLA0KICBzaHJpbmthZ2UgPSBoeXBlcl9ncmlkJHNocmlua2FnZVtpXSwNCiAgbi5taW5vYnNpbm5vZGUgPSBoeXBlcl9ncmlkJG4ubWlub2JzaW5ub2RlW2ldLA0KICBiYWcuZnJhY3Rpb24gPSBoeXBlcl9ncmlkJGJhZy5mcmFjdGlvbltpXSwNCiAgdHJhaW4uZnJhY3Rpb24gPSAuNzUsDQogIG4uY29yZXMgPSBOVUxMLCAjIHdpbGwgdXNlIGFsbCBjb3JlcyBieSBkZWZhdWx0DQogIHZlcmJvc2UgPSBGQUxTRSkNCg0KcHJlZCA9IHByZWRpY3QoZ2JtLnR1bmUsIG5ld2RhdGEgPSBhbGxfZGF0YV9zcHJlYWRfcGxiWy10cmFpbiwtMV0sIG50cmVlcyA9IDUwMDAgKQ0KICMgYWRkIG1pbiB0cmFpbmluZyBlcnJvciBhbmQgdHJlZXMgdG8gZ3JpZA0KICBoeXBlcl9ncmlkJG9wdGltYWxfdHJlZXNbaV0gPC0gd2hpY2gubWluKGdibS50dW5lJHZhbGlkLmVycm9yKQ0KICBoeXBlcl9ncmlkJG1pbl9STVNFW2ldIDwtIHNxcnQobWluKGdibS50dW5lJHZhbGlkLmVycm9yKSkNCiAgaHlwZXJfZ3JpZCRDQ0NbaV0gPSBDQ0MoKHByZWQpLCBhbGxfZGF0YV9zcHJlYWRfcGxiJHNldlstdHJhaW5dKSRyaG8uYyRlc3QNCiAgDQp9DQoNCmJlc3RfcGFyID0gaHlwZXJfZ3JpZCAlPiUgDQogIGRwbHlyOjphcnJhbmdlKC1DQ0MpICU+JQ0KICBoZWFkKDEwKQ0KYmVzdF9wYXINCiMgZ2JtLnR1bmUkZml0DQpgYGANCg0KIyMjIEJlc3QgbW9kZWwNCg0KYGBge3J9DQojIGZvciByZXByb2R1Y2liaWxpdHkNCnNldC5zZWVkKDEyMykNCg0KIyB0cmFpbiBHQk0gbW9kZWwNCmdibS5maXQuZmluYWxfcGxiIDwtIGdibSgNCiAgZm9ybXVsYSA9IHNldiB+QkdJK0JJK0dMSStISStIVUUrTkdSREkrVkFSSStncmF5KyBSZWQrR3JlZW4rQmx1ZSAgKyBTSSArIFNDSSwgDQogIGRhdGEgPSBhbGxfZGF0YV9zcHJlYWRfcGxiW3RyYWluLF0sDQogIGRpc3RyaWJ1dGlvbiA9ICJnYXVzc2lhbiIsDQogIG4udHJlZXMgPSBiZXN0X3BhciRvcHRpbWFsX3RyZWVzWzFdLA0KICBpbnRlcmFjdGlvbi5kZXB0aCA9IGJlc3RfcGFyJGludGVyYWN0aW9uLmRlcHRoWzFdLA0KICBzaHJpbmthZ2UgPSBiZXN0X3BhciRzaHJpbmthZ2VbMV0sDQogIG4ubWlub2JzaW5ub2RlID0gYmVzdF9wYXIkbi5taW5vYnNpbm5vZGVbMV0sDQogIGJhZy5mcmFjdGlvbiA9IGJlc3RfcGFyJGJhZy5mcmFjdGlvblsxXSwgDQogIHRyYWluLmZyYWN0aW9uID0wLjc1LA0KICBuLmNvcmVzID0gTlVMTCwgIyB3aWxsIHVzZSBhbGwgY29yZXMgYnkgZGVmYXVsdA0KICB2ZXJib3NlID0gRkFMU0UNCiAgKQ0KDQoNCmBgYA0KDQojIyMgUmVsYXRpdmUgaW5mbHVlbmNlDQoNCmBgYHtyfQ0KcGFyKG1hciA9IGMoNSwgOCwgMSwgMSkpDQpzdW1tYXJ5X2dibV9wbGIgPSBzdW1tYXJ5KA0KICBnYm0uZml0LmZpbmFsX3BsYiwgDQogIGNCYXJzID0gMTMsDQogIG1ldGhvZCA9IHJlbGF0aXZlLmluZmx1ZW5jZSwgIyBhbHNvIGNhbiB1c2UgcGVybXV0YXRpb24udGVzdC5nYm0NCiAgbGFzID0gMg0KICApDQoNCnJlbF9wbGIgPSBzdW1tYXJ5X2dibV9wbGIgICU+JSANCiAgcm93bmFtZXNfdG9fY29sdW1uKCJpbmRleCIpICU+JSANCiAgZ2dwbG90KGFlcyhyZWwuaW5mLCByZW9yZGVyKHZhciwgcmVsLmluZikpKSsNCiAgZ2VvbV9jb2woYWVzKGZpbGwgPXJlbC5pbmY+MSwgY29sb3IgPXJlbC5pbmY+MSApLCB3aWR0aCA9IDAuODUpKw0KICB0aGVtZV9taW5pbWFsX3ZncmlkKCkrDQogIGxhYnMoeCA9ICJSZWxhdGl2ZSBpbmZsdWVuY2UgKCUpIiwNCiAgICAgICB5ID0gIk1vZGVsIHByZWRpY3RvcnMiLA0KICAgICAgIGZpbGwgPSAiUkkgPiAxJSIsDQogICAgICAgY29sb3IgPSAiUkkgPiAxJSIpDQpyZWxfcGxiDQojIGdnc2F2ZSgiZmlncy92YXJfaW5mbHVlbmNlLnBuZyIsZHBpID0gNjAwLCBoZWlnaHQgPSA0LCB3aWR0aCA9IDYpDQpgYGANCg0KUGFydGlhbCBkZXBlbmRlbmNlIHBsb3RzDQoNCmBgYHtyfQ0KZ2JtLmZpdC5maW5hbF9wbGIgJT4lDQogIHBkcDo6cGFydGlhbChwcmVkLnZhciA9ICJCR0kiLCBuLnRyZWVzID0gZ2JtLmZpdC5maW5hbF9wbGIkbi50cmVlcywgZ3JpZC5yZXNvbHV0aW9uID0gMTAwKSAlPiUNCiAgZ2dwbG90KGFlcyggQkdJLCh5aGF0KSkpKw0KICBnZW9tX2xpbmUoKQ0KYGBgDQoNCkxJTUUNCg0KYGBge3J9DQpsaWJyYXJ5KGxpbWUpDQpgYGANCg0KYGBge3J9DQptb2RlbF90eXBlLmdibSA8LSBmdW5jdGlvbih4LCAuLi4pIHsNCiAgcmV0dXJuKCJyZWdyZXNzaW9uIikNCn0NCg0KcHJlZGljdF9tb2RlbC5nYm0gPC0gZnVuY3Rpb24oeCwgbmV3ZGF0YSwgLi4uKSB7DQogIHByZWQgPC0gcHJlZGljdCh4LCBuZXdkYXRhLCBuLnRyZWVzID0geCRuLnRyZWVzKQ0KICByZXR1cm4oYXMuZGF0YS5mcmFtZShwcmVkKSkNCn0NCmBgYA0KDQpgYGB7cn0NCiMgZ2V0IGEgZmV3IG9ic2VydmF0aW9ucyB0byBwZXJmb3JtIGxvY2FsIGludGVycHJldGF0aW9uIG9uDQpsb2NhbF9vYnMgPC0gKGFsbF9kYXRhX3NwcmVhZF9wbGJbLXRyYWluLF0pWzE6NCwgXQ0KDQojIGFwcGx5IExJTUUNCmV4cGxhaW5lciA8LSBsaW1lKGFsbF9kYXRhX3NwcmVhZF9wbGJbdHJhaW4sXSwgZ2JtLmZpdC5maW5hbF9wbGIpDQpleHBsYW5hdGlvbiA8LSBsaW1lOjpleHBsYWluKGxvY2FsX29icywgZXhwbGFpbmVyLCBuX2ZlYXR1cmVzID0gNywgbi50cmVlcyA9MSkNCnBsb3RfZmVhdHVyZXMoZXhwbGFuYXRpb24pDQoNCg0KYGBgDQoNCiMjIFByZWRpY3Rpb24NCg0KYGBge3J9DQojIHByZWRpY3QgdmFsdWVzIGZvciB0ZXN0IGRhdGENCnByZWQgPC0gcHJlZGljdChnYm0uZml0LmZpbmFsX3BsYiwgbi50cmVlcyA9IGdibS5maXQuZmluYWxfcGxiJG4udHJlZXMsIGFsbF9kYXRhX3NwcmVhZF9wbGJbLXRyYWluLF0pDQoNCiMgcmVzdWx0cw0KY2FyZXQ6OlJNU0UocHJlZCwgYWxsX2RhdGFfc3ByZWFkX3BsYlstdHJhaW4sXSRzZXYpDQpDQ0MocHJlZCwgYWxsX2RhdGFfc3ByZWFkX3BsYiRzZXZbLXRyYWluXSkkcmhvLmMkZXN0DQpjb3IocHJlZCwgYWxsX2RhdGFfc3ByZWFkX3BsYiRzZXZbLXRyYWluXSleMg0KYGBgDQoNCmBgYHtyfQ0KYWNjdXJhY3lfcGkgPWRhdGEuZnJhbWUocHJlZGk9cHJlZCwgYWN0dWFsID0gYWxsX2RhdGFfc3ByZWFkX3BsYiRzZXZbLXRyYWluXSkgJT4lIA0KICBzdW1tYXJpc2UoUk1TRSA9IGNhcmV0OjpSTVNFKHByZWQsIGFjdHVhbCksDQogICAgICAgICAgICByID0gY29yKHByZWQsIGFjdHVhbCksDQogICAgICAgICAgICBzLnNoaWZ0ID0gQ0NDKHByZWQsIGFjdHVhbCkkcy5zaGlmdCwNCiAgICAgICAgICAgIGwuc2hpZnQgPSBDQ0MocHJlZCwgYWN0dWFsKSRsLnNoaWZ0LA0KICAgICAgICAgICAgQy5iID0gQ0NDKHByZWQsIGFjdHVhbCkkQy5iLA0KICAgICAgICAgICAgQ0NDID0gQ0NDKHByZWQsIGFjdHVhbCkkcmhvLmMkZXN0LA0KICAgICAgICAgICAgQ0lTID0gcGFzdGUoDQogIHJvdW5kKENDQyhwcmVkLCBhbGxfZGF0YV9zcHJlYWRfcGxiJHNldlstdHJhaW5dKSRyaG8uY1syXSwyKSwiLCIsIiAiLA0KICByb3VuZChDQ0MocHJlZCwgYWxsX2RhdGFfc3ByZWFkX3BsYiRzZXZbLXRyYWluXSkkcmhvLmNbM10sMiksc2VwID0gIiINCiAgKSkNCmFjY3VyYWN5X3BpDQpgYGANCg0KDQoNCiMjIyMgcGxvdA0KYGBge3J9DQoNCmNvbmNfcGkgPSBkYXRhLmZyYW1lKHByZWRpY3QgPSBwcmVkLCBhY3R1YWwgPWFsbF9kYXRhX3NwcmVhZF9wbGIkc2V2Wy10cmFpbl0pICU+JSANCmdncGxvdChhZXMoYWN0dWFsLHByZWRpY3QpKSsNCiAgZ2VvbV9wb2ludChzaXplID0yLCBjb2xvciA9ICJncmF5IikrDQogIGdlb21fYWJsaW5lKGludGVyY2VwdCA9IDAsIHNsb3BlPSAxLCBzaXplID0gLjgxLCBjb2xvciA9ICJibGFjayIsIGxpbmV0eXBlID0gImRhc2hlZCIpKw0KICBnZW9tX3Ntb290aChtZXRob2QgPSAibG0iLCANCiAgICAgICAgICAgICAgY29sb3IgPSAicmVkIiwNCiAgICAgICAgICAgICAgc2l6ZSA9LjgxLCBzZSA9RiwNCiAgICAgICAgICAgICAgZnVsbHJhbmdlPVQpKw0KICB0aGVtZV9taW5pbWFsX2dyaWQoKSsNCiAgbGFicyh4ID0gIlByZWRpY3RlZCBTZXZlcml0eSAoJSkiLA0KICAgICAgIHkgPSAiQWN0dWFsIFNldmVyaXR5ICglKSIpKw0KICBjb29yZF9lcXVhbCh4bGltID0gYygwLDEwMCksDQogICAgICAgICAgICAgIHlsaW0gPSBjKDAsMTAwKSkrDQogIHhsaW0oMCwxMDApDQoNCg0KIyBnZ3NhdmUoImZpZ3MvY29uY29yZGFuY2UucG5nIiwgZHBpID0gNjAwLCBoZWlnaHQgPSAzLjUsIHdpZHRoID0gNCkNCg0KYGBgDQoNCiMgQ2Fsb25lY3RyaWEgbGVhZiBibGlnaHQNCg0KYGBge3IgZXZhbD1GQUxTRSwgaW5jbHVkZT1UUlVFfQ0KcGljczwtbGlzdC5maWxlcygiLi9waWNzLzAxLUNhbG9uZWN0cmlhX2xlYWZfYmxpZ3RoIikNCiMgbGVuZ3RoKHBpY3MpDQojaW5kaWNlcw0KaW5kZXggPSBjKCJCSSIsIlNDSSIsIkdMSSIsIkhJIiwiU0kiLCJWQVJJIiwiSFVFIiwiQkdJIiwiTkdSREkiKQ0KDQoNCmJveCA9IGRhdGEuZnJhbWUoKQ0KDQpmb3IoaSBpbiAxOmxlbmd0aChwaWNzKSl7DQoNCkVYLkwxPC1zdGFjayhwYXN0ZSgiLi9waWNzLzAxLUNhbG9uZWN0cmlhX2xlYWZfYmxpZ3RoLyIscGljc1tpXSxzZXAgPSAiIikpDQpFWC5MMTwtYWdncmVnYXRlKEVYLkwxLCBmYWN0PTcpDQpFWC5MLlNoYXBlPC1maWVsZFBvbHlnb24obW9zYWljPUVYLkwxLCBleHRlbnQ9VCwgcGxvdCA9IEYpDQoNCkVYMS5JbmRpY2VzPC0gZmllbGRJbmRleChtb3NhaWMgPSBFWC5MMSwNCiAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGluZGV4LCANCiAgICAgICAgICAgICAgICAgICAgICAgICBteUluZGV4ID0gYygiR3JlZW4iKSwgcGxvdCA9IEYpDQoNCkVYLkwyPC1maWVsZE1hc2sobW9zYWljPUVYLkwxLCAgbXlJbmRleCA9IGMoIkJsdWUiKSwgY3JvcFZhbHVlPTE3NSwgY3JvcEFib3ZlPVQsIHBsb3QgPSBGKQ0KDQpjdXQgPSBtYXNrKEVYLkwxLCBFWC5MMiRuZXdNb3NhaWMpDQpFWC5MNDwtZmllbGRJbmRleChtb3NhaWM9Y3V0LA0KICAgICAgICAgICAgICAgICAgaW5kZXggPWluZGV4LA0KICAgICAgICAgICAgICAgICAgcGxvdCA9RikNCg0KDQpkZiA9IGFzKEVYLkw0LCAiU3BhdGlhbFBpeGVsc0RhdGFGcmFtZSIpDQpkZmYgPSBhcy5kYXRhLmZyYW1lKGRmKSAlPiUgDQogIG11dGF0ZShncmF5ID0gMC4yOTkqUmVkKzAuNTg3KkdyZWVuKzAuMTE0KkJsdWUpICU+JSANCiAgZ2F0aGVyKGMoMTooMytsZW5ndGgoaW5kZXgpKSwxNSksIGtleSA9ICJpbmRleCIsIHZhbHVlID0gInZhbHVlIiApICU+JQ0KICBmaWx0ZXIoIWlzLm5hKHZhbHVlKSwNCiAgICAgICAgICFpcy5pbmZpbml0ZSh2YWx1ZSkpICU+JSANCiAgZ3JvdXBfYnkoaW5kZXgpICU+JSANCiAgZHBseXI6OnN1bW1hcmlzZShtZWFuID0gbWVhbih2YWx1ZSwgbmEucm0gPSBUKSwNCiAgICAgICAgICAgIHN0ZCA9IHNkKHZhbHVlKSwNCiAgICAgICAgICAgIFEyNSA9IHF1YW50aWxlKHZhbHVlLDAuMjUpLA0KICAgICAgICAgICAgUTUwID0gcXVhbnRpbGUodmFsdWUsMC41MCksDQogICAgICAgICAgICBRNzUgPSBxdWFudGlsZSh2YWx1ZSwwLjc1KSkgJT4lIA0KICBtdXRhdGUobGVhZiA9IHBpY3NbaV0pDQoNCg0KYm94ID0gYm94ICU+JSANCiAgYmluZF9yb3dzKGRmZil9DQpsZW5ndGgodW5pcXVlKGJveCRsZWFmKSkNCndyaXRlLnRhYmxlKGJveCwiZGF0YS9pbmRleGVzX2NhbG9uZWMudHh0IikNCmBgYA0KDQpgYGB7cn0NCmJveCA9IHJlYWQudGFibGUoImRhdGEvaW5kZXhlc19jYWxvbmVjLnR4dCIpDQpgYGANCg0KDQojIyMgTG9hZCBzZXYNCmBgYHtyfQ0KZGF0YV9jYWxvX2xvYWQgPSBnc2hlZXQydGJsKCJodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9zcHJlYWRzaGVldHMvZC8xRDVDbjZDTkQ4T2pRd2R2X0FWdF9zeEowSDIxRGpJUW5mbUI3SEt3cVlYSS9lZGl0P3VzcD1zaGFyaW5nIikgJT4lIA0KICBtdXRhdGUoZmlsZSA9IGFzLmNoYXJhY3RlcihmaWxlKSkgJT4lIA0KICBkcGx5cjo6c2VsZWN0KGZpbGUsYXJlYV90b3RhbCxhcmVhX2RvZW50ZV9yb3hhLGFyZWFfZG9lbnRlLHNldl9yb3hhLHNldikNCmhlYWQoZGF0YV9jYWxvX2xvYWQpDQpgYGANCg0KYGBge3J9DQpkYXRhX2NhbG8gPSBib3ggJT4lIA0KICBzZXBhcmF0ZShsZWFmLCBpbnRvPWMoImZpbGUiLCJmb3JtYXQiKSwgc2VwID0iLmpwZyIpICU+JSANCiAgZHBseXI6OnNlbGVjdCgtZm9ybWF0KSAlPiUgDQogIGZ1bGxfam9pbihkYXRhX2NhbG9fbG9hZCwgYnk9ImZpbGUiKSAlPiUgDQogIG11dGF0ZShzZXY9c2V2X3JveGEpDQojIGRhdGFfY2Fsbw0KDQpsZW5ndGgodW5pcXVlKGRhdGFfY2FsbyRzZXYpKQ0KYGBgDQpgYGB7cn0NCnN1bW1hcnkoZGF0YV9jYWxvJHNldikNCmBgYA0KDQoNCiMjIyBJbWFnZXMNCg0KDQpgYGB7cn0NCmhpc3Rfc2V2X2NhbG8gPSAgZGF0YV9jYWxvICU+JSANCiAgcGl2b3Rfd2lkZXIoaWRfY29sID0gYyhmaWxlLHNldl9yb3hhKSwNCiAgICAgICAgICAgICAgbmFtZXNfZnJvbSA9IGluZGV4LCANCiAgICAgICAgICAgICAgdmFsdWVzX2Zyb20gPSAgbWVhbikgJT4lDQogIGdncGxvdChhZXMoc2V2X3JveGEpKSsNCiAgZ2VvbV9oaXN0b2dyYW0oY29sb3IgPSAid2hpdGUiLCBmaWxsID0gImJsYWNrIiwgYmlucyA9IDIwKSsNCiAgdGhlbWVfbWluaW1hbF9oZ3JpZChmb250X3NpemUgPSAxMCkrDQogIGxhYnMoeCA9ICJTZXZlcml0eSAoJSkiLA0KICAgICAgIHkgPSAiRnJlcXVlbmN5IikrDQogIHNjYWxlX3hfY29udGludW91cyhsaW1pdHMgPSBjKC01LDEwNSksIGJyZWFrcyA9IHNlcSgwLDEwMCwyNSkpKw0KICAjIHRoZW1lX3ZvaWQoKSsNCiAgIyBjb29yZF9maXhlZCgpKw0KICB0aGVtZShwYW5lbC5iYWNrZ3JvdW5kID0gZWxlbWVudF9yZWN0KGNvbG9yID0gImJsYWNrIiksDQogICAgICAgIGF4aXMudGl0bGUueSA9IGVsZW1lbnRfdGV4dChzaXplPTgpKQ0KDQpgYGANCg0KYGBge3J9DQpFWC5MMTwtc3RhY2socGFzdGUoIi4vcGljcy8wMS1DYWxvbmVjdHJpYV9sZWFmX2JsaWd0aC8iLCI1Ny5qcGciLHNlcCA9ICIiKSkNCkVYLkwxPC1hZ2dyZWdhdGUoRVguTDEsIGZhY3Q9NykNCkVYLkwuU2hhcGU8LWZpZWxkUG9seWdvbihtb3NhaWM9RVguTDEsIGV4dGVudD1ULCBwbG90ID0gRikNCg0KIyBFWDEuSW5kaWNlczwtIGZpZWxkSW5kZXgobW9zYWljID0gRVguTDEsDQojICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGluZGV4LCANCiMgICAgICAgICAgICAgICAgICAgICAgICAgIG15SW5kZXggPSBjKCJHcmVlbiIpLCBwbG90ID0gRikNCg0KRVguTDI8LWZpZWxkTWFzayhtb3NhaWM9RVguTDEsICBteUluZGV4ID0gYygiQmx1ZSIpLCBjcm9wVmFsdWU9MTc1LCBjcm9wQWJvdmU9VCwgcGxvdCA9IEYpDQoNCmN1dCA9IG1hc2soRVguTDEsIEVYLkwyJG5ld01vc2FpYykNCkVYLkw0PC1maWVsZEluZGV4KG1vc2FpYz1jdXQsDQogICAgICAgICAgICAgICAgICBpbmRleCA9aW5kZXgsDQogICAgICAgICAgICAgICAgICBwbG90ID1GKQ0KIyBwbG90KEVYLkw0JEhVRSkNCmBgYA0KDQpgYGB7cn0NCnJnYl9maWdfY2FsbyA9IFJTdG9vbGJveDo6Z2dSR0IoRVguTDIkbmV3TW9zYWljLA0KICAgICAgICAgICAgICAgICByID0gMSwNCiAgICAgICAgICAgICAgICAgZyA9IDIsDQogICAgICAgICAgICAgICAgIGIgPSAzKSsNCiAgdGhlbWVfbWFwKCkrDQogIGNvb3JkX2ZpeGVkKCkrDQogIHRoZW1lKHBhbmVsLmJhY2tncm91bmQgPSBlbGVtZW50X3JlY3QoY29sb3IgPSAid2hpdGUiKSkNCg0KDQpnbGlfZmlnX2NhbG8gPSBhcy5kYXRhLmZyYW1lKEVYLkw0JEhVRSwgeHk9VFJVRSwgbmEucm0gPVQpICU+JSANCiAgZ2dwbG90KGFlcyh4LCB5LCBmaWxsID0gSFVFKSkrDQogIGdlb21fdGlsZSgpKw0KICBzY2FsZV9maWxsX3ZpcmlkaXNfYyhvcHRpb24gPSAiQiIsZGlyZWN0aW9uID0gLTEpKw0KICB0aGVtZV9tYXAoKSsNCiAgY29vcmRfZml4ZWQoKSsNCiAgdGhlbWUocGFuZWwuYmFja2dyb3VuZCA9IGVsZW1lbnRfcmVjdChjb2xvciA9ICJ3aGl0ZSIpLA0KICAgICAgICBsZWdlbmQudGl0bGUgPSBlbGVtZW50X3RleHQoc2l6ZSA9IDgpLA0KICAgICAgICBsZWdlbmQudGV4dCA9IGVsZW1lbnRfdGV4dChzaXplID0gOCkpDQoNCnJnYl9maWdfY2FsbysgZ2xpX2ZpZ19jYWxvDQpgYGANCg0KYGBge3IgZmlnLmhlaWdodD05LCBmaWcud2lkdGg9N30NCnJnYl9maWdfc2JyICsgZ2xpX2ZpZ19zYnIgKyBoaXN0X3Nldl9zYnIgKw0KICByZ2JfZmlnX3h5ICsgZ2xpX2ZpZ194eSAraGlzdF9zZXZfeHkrDQogIHJnYl9maWdfY2FsbyArIGdsaV9maWdfY2FsbyArIGhpc3Rfc2V2X2NhbG8rDQogIHJnYl9maWdfd2xiICsgZ2xpX2ZpZ193bGIgKyBoaXN0X3Nldl9XTEIrDQogIHJnYl9maWdfcGkgKyBnbGlfZmlnX3BpICsgaGlzdF9zZXZfcGkrDQogICBwbG90X2xheW91dCh3aWR0aHMgPSBjKDEsIDEsIDEpLA0KICAgICAgICAgICAgICAgaGVpZ2h0cyA9IGMoMSwxLDEsMSwxKSkrDQogIHBsb3RfYW5ub3RhdGlvbih0YWdfbGV2ZWxzID0gJ0EnKSYNCiAgdGhlbWUobGVnZW5kLmtleS5zaXplID0gdW5pdCgzLCAnbW0nKSwNCiAgICAgICAgbGVnZW5kLnRleHQgPSBlbGVtZW50X3RleHQoc2l6ZSA9NikpDQoNCmdnc2F2ZSgiZmlncy9sZWFmX2dsaS5wbmciLGRwaSA9IDYwMCwgaGVpZ2h0ID0gOSwgd2lkdGggPTcpDQpgYGANCg0KDQoNCiMjIyBSZWxhdGlvbnNoaXAgc2V2IGluZGljZXMNCg0KDQpgYGB7cn0NCiByZ2JfZ2dfY2FsbyA9ICBkYXRhX2NhbG8gJT4lIA0KICBmaWx0ZXIoaW5kZXggJWluJSBjKCJSZWQiLCAiQmx1ZSIsICJHcmVlbiIpKSAlPiUNCiAgICBnZ3Bsb3QoYWVzKG1lYW4sIHNldl9yb3hhLCBjb2xvciA9IGluZGV4KSkgKyANCiAgIyBnZW9tX3RleHQoKSsNCiAgZ2VvbV9wb2ludChjb2xvciA9ICJncmF5Iiwgc2l6ZSAgPTMpKw0KICBnZW9tX3Ntb290aChzZSA9IEYsIHNpemUgPSAyKSsNCiAgZmFjZXRfd3JhcCh+aW5kZXgsIHNjYWxlcyA9ICJmcmVlX3giLCBucm93ID0xKSsNCiAgc2NhbGVfY29sb3JfbWFudWFsKHZhbHVlcyA9IGMoInN0ZWVsYmx1ZSIsImRhcmtncmVlbiIsICJkYXJrcmVkIikpKw0KICB0aGVtZV9taW5pbWFsX2hncmlkKCkrDQogIGxhYnMoeCA9ICJNZWFuIHZhbHVlIGluIHRoZSBpbWFnZSIsDQogICAgICAgeSA9ICJEaXNlYXNlIHNldmVyaXR5ICglKSIpKw0KICB0aGVtZShwYW5lbC5ib3JkZXIgPSBlbGVtZW50X3JlY3QoY29sb3IgPSAiZ3JheSIpKSsNCiAgdGhlbWUobGVnZW5kLnBvc2l0aW9uID0gIm5vbmUiKQ0KcmdiX2dnX2NhbG8NCmBgYA0KDQoNCmBgYHtyfQ0KaW5kZXhfZ2dfY2FsbyA9IGRhdGFfY2FsbyAlPiUgDQogIGZpbHRlcighaW5kZXggJWluJSBjKCJSZWQiLCAiQmx1ZSIsICJHcmVlbiIpKSAlPiUgDQogICAgZ2dwbG90KGFlcyhtZWFuLCBzZXZfcm94YSwgbGFiZWwgPSBmaWxlKSkgKyANCiAgIyBnZW9tX3RleHQoKSsNCiAgZ2VvbV9wb2ludChjb2xvciA9ICJncmF5Iiwgc2l6ZSAgPTMpKw0KICBnZW9tX3Ntb290aChjb2xvciA9ICJibGFjayIsIHNlID0gRiwgc2l6ZSA9IDIpKw0KICBmYWNldF93cmFwKH5pbmRleCwgc2NhbGVzID0gImZyZWVfeCIsIG5yb3cgPTIpKw0KICB0aGVtZV9taW5pbWFsX2hncmlkKCkrDQogIGxhYnMoeCA9ICJNZWFuIGluZGV4IHZhbHVlIGluIHRoZSBpbWFnZSIsDQogICAgICAgeSA9ICJEaXNlYXNlIHNldmVyaXR5ICglKSIpKw0KICB0aGVtZShwYW5lbC5ib3JkZXIgPSBlbGVtZW50X3JlY3QoY29sb3IgPSAiZ3JheSIpKQ0KaW5kZXhfZ2dfY2Fsbw0KYGBgDQoNCmBgYHtyfQ0KcGxvdF9ncmlkKA0KICBwbG90X2dyaWQoTlVMTCxyZ2JfZ2dfY2FsbyxOVUxMLCByZWxfd2lkdGhzID1jKDAuMTgsMSwwLjIpLCBucm93ID0gMSksDQogICAgICAgICAgaW5kZXhfZ2dfY2FsbywNCiAgICAgICAgICBucm93ID0gMiwNCiAgICAgICAgICByZWxfaGVpZ2h0cyA9IGMoMC41LDEpKQ0KZ2dzYXZlKCJmaWdzL2luZGV4X3Nldl9jYWxvLnBuZyIsIGRwaSA9IDUwMCwgaGVpZ2h0ID0gOCwgd2lkdGggPSAxMCkNCmBgYA0KDQoNCmBgYHtyfQ0KY29yX2NhbG8gPSBkYXRhX2NhbG8gJT4lIA0KICBncm91cF9ieShpbmRleCkgJT4lIA0KICBkcGx5cjo6c3VtbWFyaXNlKGNvciA9IHJvdW5kKCAgY29yLnRlc3QobWVhbixzZXZfcm94YSwgbWV0aG9kID0gInNwZWFybWFuIikkZXN0aW1hdGUsMyksDQogICAgICAgICAgICAgICAgICAgUF92YWx1ZSA9IHJvdW5kKGNvci50ZXN0KG1lYW4sc2V2X3JveGEsIG1ldGhvZCA9ICJzcGVhcm1hbiIpJHAudmFsdWUsNCkpICU+JSANCiAgYXJyYW5nZSgtY29yKQ0KY29yX2NhbG8NCmBgYA0KDQojIyMgU3ByZWFkIGRmDQoNCmBgYHtyfQ0KYWxsX2RhdGFfc3ByZWFkX2NhbG8gPSBkYXRhX2NhbG8gJT4lIA0KICBwaXZvdF93aWRlcihpZF9jb2wgPSBjKGZpbGUsc2V2X3JveGEpLA0KICAgICAgICAgICAgICBuYW1lc19mcm9tID0gaW5kZXgsIA0KICAgICAgICAgICAgICB2YWx1ZXNfZnJvbSA9ICBtZWFuKSAlPiUgDQogIG11dGF0ZShzZXYgPSBzZXZfcm94YSkgJT4lIA0KICBkcGx5cjo6c2VsZWN0KC1zZXZfcm94YSkNCg0KaGVhZChhbGxfZGF0YV9zcHJlYWRfY2FsbykNCmBgYA0KDQojIyMgR0JNDQoNCmBgYHtyfQ0KdHJhaW49c2FtcGxlKHggPSAxOmxlbmd0aChhbGxfZGF0YV9zcHJlYWRfY2FsbyRzZXYpLCANCiAgICAgICAgICAgICBzaXplID0gcm91bmQoMC43NSpsZW5ndGgoYWxsX2RhdGFfc3ByZWFkX2NhbG8kc2V2KSwxKSkNCiMgbGVuZ3RoKHRyYWluKQ0KZ2JtLmZpdCA9IGdibShzZXYgfkJHSStCSStHTEkrSEkrSFVFK05HUkRJK1ZBUkkrZ3JheSsgUmVkK0dyZWVuK0JsdWUgICsgU0kgKyBTQ0ksDQogICAgICAgICAgICAgZGF0YSA9IGFsbF9kYXRhX3NwcmVhZF9jYWxvW3RyYWluLF0sDQogICAgICAgICAgICAgZGlzdHJpYnV0aW9uID0gImdhdXNzaWFuIiwNCiAgICAgICAgICAgICAgbi50cmVlcyA9IDEwMDAsDQogICAgICAgICAgICAgaW50ZXJhY3Rpb24uZGVwdGggPSAzLA0KICAgICAgICAgICAgIHNocmlua2FnZSA9IDAuMSwNCiAgICAgICAgICAgICBjdi5mb2xkcyA9IDUsDQogICAgICAgICAgICAgbi5jb3JlcyA9IE5VTEwsICMgd2lsbCB1c2UgYWxsIGNvcmVzIGJ5IGRlZmF1bHQNCiAgICAgICAgICAgICB2ZXJib3NlID0gRkFMU0UpDQpwcmludChnYm0uZml0KQ0Kc3FydChtaW4oZ2JtLmZpdCRjdi5lcnJvcikpDQpgYGANCg0KYGBge3J9DQpnYm0ucGVyZihnYm0uZml0LCBtZXRob2QgPSAiY3YiKQ0KIyBmaW5kIGluZGV4IGZvciBuIHRyZWVzIHdpdGggbWluaW11bSBDViBlcnJvcg0KYGBgDQoNCmBgYHtyfQ0KbWluX01TRSA8LSB3aGljaC5taW4oZ2JtLmZpdCRjdi5lcnJvcikNCnNxcnQoZ2JtLmZpdCRjdi5lcnJvclttaW5fTVNFXSkNCmBgYA0KDQpgYGB7cn0NCiMgYmVzdC5pdGVyIDwtIGdibS5wZXJmKG1vZGVsMSwgbWV0aG9kID0gInRlc3QiKQ0KIyBwcmludChiZXN0Lml0ZXIpDQoNCnByZWQgPSBwcmVkaWN0KGdibS5maXQsIG5ld2RhdGEgPSBhbGxfZGF0YV9zcHJlYWRfY2Fsb1stdHJhaW4sLTFdLCBudHJlZXMgPSA1MDAwICkNCg0Kc3FydChtZWFuKCgocHJlZCktYWxsX2RhdGFfc3ByZWFkX2NhbG8kc2V2Wy10cmFpbl0pXjIpKQ0KQ0NDKChwcmVkKSwgYWxsX2RhdGFfc3ByZWFkX2NhbG8kc2V2Wy10cmFpbl0pJHJoby5jJGVzdA0KDQpwbG90KChwcmVkKSwgKHByZWQpLWFsbF9kYXRhX3NwcmVhZF9jYWxvJHNldlstdHJhaW5dKQ0KYWJsaW5lKGE9MCxiPTApDQpgYGANCg0KIyMjIFRlc3RpbmcgdmFyaW91cyBoeXBlcnBhcmFtZXRlcnMNCg0KQ3JlYXRlIGh5cGVycGFyYW1ldGVyIGdyaWQNCg0KYGBge3J9DQoNCmh5cGVyX2dyaWQgPC0gZXhwYW5kLmdyaWQoDQogIHNocmlua2FnZSA9IGMoLjAwMSwgLjAxLCAuMSwgLjMpLA0KICBpbnRlcmFjdGlvbi5kZXB0aCA9IGMoMSwgMywgNSwgNiksDQogIG4ubWlub2JzaW5ub2RlID0gYyg1LCAxMCwgMTUpLA0KICBiYWcuZnJhY3Rpb24gPSBjKC41LC42NSwgLjgsIDEpLCANCiAgb3B0aW1hbF90cmVlcyA9IDAsICAgICAgICAgICAgICAgIyBhIHBsYWNlIHRvIGR1bXAgcmVzdWx0cw0KICBtaW5fUk1TRSA9IDAsDQogIENDQyA9MCAjIGEgcGxhY2UgdG8gZHVtcCByZXN1bHRzDQopDQojIHRvdGFsIG51bWJlciBvZiBjb21iaW5hdGlvbnMNCm5yb3coaHlwZXJfZ3JpZCkNCmBgYA0KDQpgYGB7ciBtZXNzYWdlPUZBTFNFLCB3YXJuaW5nPUZBTFNFfQ0KIyByYW5kb21pemUgZGF0YQ0Kc2V0LnNlZWQoMTIzNCkNCnRyYWluPXNhbXBsZSh4ID0gMTpsZW5ndGgoYWxsX2RhdGFfc3ByZWFkX2NhbG8kc2V2KSwgDQogICAgICAgICAgICAgc2l6ZSA9IHJvdW5kKDAuODAqbGVuZ3RoKGFsbF9kYXRhX3NwcmVhZF9jYWxvJHNldiksMSkpDQoNCiMgZ3JpZCBzZWFyY2ggDQpmb3IoaSBpbiAxOm5yb3coaHlwZXJfZ3JpZCkpIHsNCg0KIyByZXByb2R1Y2liaWxpdHkNCnNldC5zZWVkKDEyMykNCg0KDQogIyB0cmFpbiBtb2RlbA0KZ2JtLnR1bmUgPC0gZ2JtKA0KICBmb3JtdWxhID0gc2V2IH5CR0krQkkrR0xJK0hJK0hVRStOR1JESStWQVJJK2dyYXkrIFJlZCtHcmVlbitCbHVlICArIFNJICsgU0NJLCANCiAgZGF0YSA9IGFsbF9kYXRhX3NwcmVhZF9jYWxvW3RyYWluLF0sDQogIGRpc3RyaWJ1dGlvbiA9ICJnYXVzc2lhbiIsDQogIG4udHJlZXMgPSA1MDAwLA0KICBpbnRlcmFjdGlvbi5kZXB0aCA9IGh5cGVyX2dyaWQkaW50ZXJhY3Rpb24uZGVwdGhbaV0sDQogIHNocmlua2FnZSA9IGh5cGVyX2dyaWQkc2hyaW5rYWdlW2ldLA0KICBuLm1pbm9ic2lubm9kZSA9IGh5cGVyX2dyaWQkbi5taW5vYnNpbm5vZGVbaV0sDQogIGJhZy5mcmFjdGlvbiA9IGh5cGVyX2dyaWQkYmFnLmZyYWN0aW9uW2ldLA0KICB0cmFpbi5mcmFjdGlvbiA9IC43NSwNCiAgbi5jb3JlcyA9IE5VTEwsICMgd2lsbCB1c2UgYWxsIGNvcmVzIGJ5IGRlZmF1bHQNCiAgdmVyYm9zZSA9IEZBTFNFKQ0KDQpwcmVkID0gcHJlZGljdChnYm0udHVuZSwgbmV3ZGF0YSA9IGFsbF9kYXRhX3NwcmVhZF9jYWxvWy10cmFpbiwtMV0sIG50cmVlcyA9IDUwMDAgKQ0KICMgYWRkIG1pbiB0cmFpbmluZyBlcnJvciBhbmQgdHJlZXMgdG8gZ3JpZA0KICBoeXBlcl9ncmlkJG9wdGltYWxfdHJlZXNbaV0gPC0gd2hpY2gubWluKGdibS50dW5lJHZhbGlkLmVycm9yKQ0KICBoeXBlcl9ncmlkJG1pbl9STVNFW2ldIDwtIHNxcnQobWluKGdibS50dW5lJHZhbGlkLmVycm9yKSkNCiAgaHlwZXJfZ3JpZCRDQ0NbaV0gPSBDQ0MoKHByZWQpLCBhbGxfZGF0YV9zcHJlYWRfY2FsbyRzZXZbLXRyYWluXSkkcmhvLmMkZXN0DQogIA0KfQ0KDQpiZXN0X3BhciA9IGh5cGVyX2dyaWQgJT4lIA0KICBkcGx5cjo6YXJyYW5nZSgtQ0NDKSAlPiUNCiAgaGVhZCgxMCkNCmJlc3RfcGFyDQojIGdibS50dW5lJGZpdA0KYGBgDQoNCiMjIyBCZXN0IG1vZGVsDQoNCmBgYHtyfQ0KIyBmb3IgcmVwcm9kdWNpYmlsaXR5DQpzZXQuc2VlZCgxMjMpDQoNCiMgdHJhaW4gR0JNIG1vZGVsDQpnYm0uZml0LmZpbmFsX2NhbG8gPC0gZ2JtKA0KICBmb3JtdWxhID0gc2V2IH5CR0krQkkrR0xJK0hJK0hVRStOR1JESStWQVJJK2dyYXkrIFJlZCtHcmVlbitCbHVlICArIFNJICsgU0NJLCANCiAgZGF0YSA9IGFsbF9kYXRhX3NwcmVhZF9jYWxvW3RyYWluLF0sDQogIGRpc3RyaWJ1dGlvbiA9ICJnYXVzc2lhbiIsDQogIG4udHJlZXMgPSBiZXN0X3BhciRvcHRpbWFsX3RyZWVzWzFdLA0KICBpbnRlcmFjdGlvbi5kZXB0aCA9IGJlc3RfcGFyJGludGVyYWN0aW9uLmRlcHRoWzFdLA0KICBzaHJpbmthZ2UgPSBiZXN0X3BhciRzaHJpbmthZ2VbMV0sDQogIG4ubWlub2JzaW5ub2RlID0gYmVzdF9wYXIkbi5taW5vYnNpbm5vZGVbMV0sDQogIGJhZy5mcmFjdGlvbiA9IGJlc3RfcGFyJGJhZy5mcmFjdGlvblsxXSwgDQogIHRyYWluLmZyYWN0aW9uID0wLjc1LA0KICBuLmNvcmVzID0gTlVMTCwgIyB3aWxsIHVzZSBhbGwgY29yZXMgYnkgZGVmYXVsdA0KICB2ZXJib3NlID0gRkFMU0UNCiAgKQ0KDQoNCmBgYA0KDQojIyMgUmVsYXRpdmUgaW5mbHVlbmNlDQoNCmBgYHtyfQ0KcGFyKG1hciA9IGMoNSwgOCwgMSwgMSkpDQpzdW1tYXJ5X2dibV9jYWxvID0gc3VtbWFyeSgNCiAgZ2JtLmZpdC5maW5hbF9jYWxvLCANCiAgY0JhcnMgPSAxMywNCiAgbWV0aG9kID0gcmVsYXRpdmUuaW5mbHVlbmNlLCAjIGFsc28gY2FuIHVzZSBwZXJtdXRhdGlvbi50ZXN0LmdibQ0KICBsYXMgPSAyDQogICkNCg0KcmVsX2NhbG8gPSBzdW1tYXJ5X2dibV9jYWxvICU+JSANCiAgcm93bmFtZXNfdG9fY29sdW1uKCJpbmRleCIpICU+JSANCiAgZ2dwbG90KGFlcyhyZWwuaW5mLCByZW9yZGVyKHZhciwgcmVsLmluZikpKSsNCiAgZ2VvbV9jb2woYWVzKGZpbGwgPXJlbC5pbmY+MSwgY29sb3IgPXJlbC5pbmY+MSApLCB3aWR0aCA9IDAuODUpKw0KICB0aGVtZV9taW5pbWFsX3ZncmlkKCkrDQogIGxhYnMoeCA9ICJSZWxhdGl2ZSBpbmZsdWVuY2UgKCUpIiwNCiAgICAgICB5ID0gIk1vZGVsIHByZWRpY3RvcnMiLA0KICAgICAgIGZpbGwgPSAiUkkgPiAxJSIsDQogICAgICAgY29sb3IgPSAiUkkgPiAxJSIpDQpyZWxfY2Fsbw0KIyBnZ3NhdmUoImZpZ3MvdmFyX2luZmx1ZW5jZS5wbmciLGRwaSA9IDYwMCwgaGVpZ2h0ID0gNCwgd2lkdGggPSA2KQ0KYGBgDQoNClBhcnRpYWwgZGVwZW5kZW5jZSBwbG90cw0KDQpgYGB7cn0NCmdibS5maXQuZmluYWxfY2FsbyAlPiUNCiAgcGRwOjpwYXJ0aWFsKHByZWQudmFyID0gIkhVRSIsIG4udHJlZXMgPSBnYm0uZml0LmZpbmFsX2NhbG8kbi50cmVlcywgZ3JpZC5yZXNvbHV0aW9uID0gMTAwKSAlPiUNCiAgZ2dwbG90KGFlcyggSFVFLCh5aGF0KSkpKw0KICBnZW9tX2xpbmUoKQ0KYGBgDQoNCkxJTUUNCg0KYGBge3J9DQpsaWJyYXJ5KGxpbWUpDQpgYGANCg0KYGBge3J9DQptb2RlbF90eXBlLmdibSA8LSBmdW5jdGlvbih4LCAuLi4pIHsNCiAgcmV0dXJuKCJyZWdyZXNzaW9uIikNCn0NCg0KcHJlZGljdF9tb2RlbC5nYm0gPC0gZnVuY3Rpb24oeCwgbmV3ZGF0YSwgLi4uKSB7DQogIHByZWQgPC0gcHJlZGljdCh4LCBuZXdkYXRhLCBuLnRyZWVzID0geCRuLnRyZWVzKQ0KICByZXR1cm4oYXMuZGF0YS5mcmFtZShwcmVkKSkNCn0NCmBgYA0KDQpgYGB7cn0NCiMgZ2V0IGEgZmV3IG9ic2VydmF0aW9ucyB0byBwZXJmb3JtIGxvY2FsIGludGVycHJldGF0aW9uIG9uDQpsb2NhbF9vYnMgPC0gKGFsbF9kYXRhX3NwcmVhZF9jYWxvWy10cmFpbixdKVsxOjQsIF0NCg0KIyBhcHBseSBMSU1FDQpleHBsYWluZXIgPC0gbGltZShhbGxfZGF0YV9zcHJlYWRfY2Fsb1t0cmFpbixdLCBnYm0uZml0LmZpbmFsX2NhbG8pDQpleHBsYW5hdGlvbiA8LSBsaW1lOjpleHBsYWluKGxvY2FsX29icywgZXhwbGFpbmVyLCBuX2ZlYXR1cmVzID0gNywgbi50cmVlcyA9MSkNCnBsb3RfZmVhdHVyZXMoZXhwbGFuYXRpb24pDQoNCg0KYGBgDQoNCiMjIFByZWRpY3Rpb24NCg0KYGBge3J9DQojIHByZWRpY3QgdmFsdWVzIGZvciB0ZXN0IGRhdGENCnByZWQgPC0gcHJlZGljdChnYm0uZml0LmZpbmFsX2NhbG8sIG4udHJlZXMgPSBnYm0uZml0LmZpbmFsX2NhbG8kbi50cmVlcywgYWxsX2RhdGFfc3ByZWFkX2NhbG9bLXRyYWluLF0pDQoNCiMgcmVzdWx0cw0KY2FyZXQ6OlJNU0UocHJlZCwgYWxsX2RhdGFfc3ByZWFkX2NhbG9bLXRyYWluLF0kc2V2KQ0KQ0NDKHByZWQsIGFsbF9kYXRhX3NwcmVhZF9jYWxvJHNldlstdHJhaW5dKSRyaG8uYyRlc3QNCmNvcihwcmVkLCBhbGxfZGF0YV9zcHJlYWRfY2FsbyRzZXZbLXRyYWluXSleMg0KYGBgDQoNCmBgYHtyfQ0KYWNjdXJhY3lfY2FsbyA9IGRhdGEuZnJhbWUocHJlZGk9cHJlZCwgYWN0dWFsID0gYWxsX2RhdGFfc3ByZWFkX2NhbG8kc2V2Wy10cmFpbl0pICU+JSANCiAgc3VtbWFyaXNlKFJNU0UgPSBjYXJldDo6Uk1TRShwcmVkLCBhY3R1YWwpLA0KICAgICAgICAgICAgciA9IGNvcihwcmVkLCBhY3R1YWwpLA0KICAgICAgICAgICAgcy5zaGlmdCA9IENDQyhwcmVkLCBhY3R1YWwpJHMuc2hpZnQsDQogICAgICAgICAgICBsLnNoaWZ0ID0gQ0NDKHByZWQsIGFjdHVhbCkkbC5zaGlmdCwNCiAgICAgICAgICAgIEMuYiA9IENDQyhwcmVkLCBhY3R1YWwpJEMuYiwNCiAgICAgICAgICAgIENDQyA9IENDQyhwcmVkLCBhY3R1YWwpJHJoby5jJGVzdCwNCiAgICAgICAgICAgIENJUyA9IHBhc3RlKA0KICByb3VuZChDQ0MocHJlZCwgYWxsX2RhdGFfc3ByZWFkX2NhbG8kc2V2Wy10cmFpbl0pJHJoby5jWzJdLDIpLCIsIiwiICIsDQogIHJvdW5kKENDQyhwcmVkLCBhbGxfZGF0YV9zcHJlYWRfY2FsbyRzZXZbLXRyYWluXSkkcmhvLmNbM10sMiksc2VwID0gIiINCiAgKSkNCmFjY3VyYWN5X2NhbG8NCmBgYA0KDQoNCg0KDQojIyMjIHBsb3QNCmBgYHtyfQ0KDQpjb25jX2NhbG8gPSBkYXRhLmZyYW1lKHByZWRpY3QgPSBwcmVkLCBhY3R1YWwgPWFsbF9kYXRhX3NwcmVhZF9jYWxvJHNldlstdHJhaW5dKSAlPiUgDQpnZ3Bsb3QoYWVzKGFjdHVhbCxwcmVkaWN0KSkrDQogIGdlb21fcG9pbnQoc2l6ZSA9MiwgY29sb3IgPSAiZ3JheSIpKw0KICBnZW9tX2FibGluZShpbnRlcmNlcHQgPSAwLCBzbG9wZT0gMSwgc2l6ZSA9IC44MSwgY29sb3IgPSAiYmxhY2siLCBsaW5ldHlwZSA9ICJkYXNoZWQiKSsNCiAgZ2VvbV9zbW9vdGgobWV0aG9kID0gImxtIiwgDQogICAgICAgICAgICAgIGNvbG9yID0gInJlZCIsDQogICAgICAgICAgICAgIHNpemUgPS44MSwgc2UgPUYsDQogICAgICAgICAgICAgIGZ1bGxyYW5nZT1UKSsNCiAgdGhlbWVfbWluaW1hbF9ncmlkKCkrDQogIGxhYnMoeCA9ICJQcmVkaWN0ZWQgU2V2ZXJpdHkgKCUpIiwNCiAgICAgICB5ID0gIkFjdHVhbCBTZXZlcml0eSAoJSkiKSsNCiAgY29vcmRfZXF1YWwoeGxpbSA9IGMoMCwxMDApLA0KICAgICAgICAgICAgICB5bGltID0gYygwLDEwMCkpKw0KICB4bGltKDAsMTAwKQ0KDQoNCiMgZ2dzYXZlKCJmaWdzL2NvbmNvcmRhbmNlLnBuZyIsIGRwaSA9IDYwMCwgaGVpZ2h0ID0gMy41LCB3aWR0aCA9IDQpDQoNCmBgYA0KDQoNCg0KIyBDb3JyZWxhdGlvbg0KDQpgYGB7cn0NCmluZF9vcmRlciA9IGMoIlJlZCIsIkdyZWVuIiwiQmx1ZSIsIkJJIiwiU0NJIiwiR0xJIiwiSEkiLCJOR1JESSIsIlNJIiwiVkFSSSIsIkhVRSIsIkJHSSIsImdyYXkiKQ0KYmluZF9yb3dzKA0KY29yX3NiciAlPiUgbXV0YXRlKGRpc2Vhc2U9IlNCUiIpLA0KY29yX2NhbG8gJT4lIG11dGF0ZShkaXNlYXNlPSJDTEIiKSwNCmNvcl94eSAlPiUgbXV0YXRlKGRpc2Vhc2U9Ik50WGYiKSwNCmNvcl93bGIgJT4lIG11dGF0ZShkaXNlYXNlPSJXTEIiKSwNCmNvcl9QSSAlPiUgbXV0YXRlKGRpc2Vhc2U9IlBMQiIpKSAlPiUgDQogIG11dGF0ZShzaWcgPSBjYXNlX3doZW4oUF92YWx1ZSA8MC4wNSB+ICIgIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICBQX3ZhbHVlID4wLjA1IH4gIlA+MC4wNSIpKSAlPiUgDQogIG11dGF0ZShkaXNlYXNlID0gZmFjdG9yKGRpc2Vhc2UsIGxldmVscyA9IGMoIlBMQiIsICJXTEIiLCJOdFhmIiwiQ0xCIiwgIlNCUiIpKSwNCiAgICAgICAgIGluZGV4ID0gZmFjdG9yKGluZGV4LCBsZXZlbHMgPSBpbmRfb3JkZXIpKSAlPiUgDQogIGdncGxvdChhZXMoaW5kZXgsZGlzZWFzZSwgZmlsbCA9IGNvciwgbGFiZWwgPSByb3VuZChjb3IsMykpKSsNCiAgZ2VvbV90aWxlKCkrDQogIGdlb21fdGV4dChzaXplID0zLjUpKw0KICBnZW9tX3BvaW50KGFlcyhpbmRleCxkaXNlYXNlLCBjb2xvciA9IHNpZyksIHNoYXBlID0gIlgiLCBzaXplID04LCBhbHBoYSA9IDAuNikrDQogICMgc2NhbGVfZmlsbF9ncmFkaWVudDIobG93ID0gImRhcmtyZWQiLCBtaWQgPSBOQSwgaGlnaCA9ICJkYXJrZ3JlZW4iKSsNCiAgc2NhbGVfZmlsbF9kaXN0aWxsZXIocGFsZXR0ZSA9ICJSZEJ1IiwgZGlyZWN0aW9uID0gMSkrDQogIHNjYWxlX2NvbG9yX21hbnVhbCh2YWx1ZXMgPSBjKE5BLCJibGFjayIpKSsNCiAgdGhlbWVfaGFsZl9vcGVuKCkrDQogIGxhYnMoeCA9ICIiLA0KICAgICAgIHkgPSAiIiwgDQogICAgICAgZmlsbCA9ICIgIHIiLA0KICAgICAgIGNvbG9yID0iIikNCmdnc2F2ZSgiZmlncy9jb3JyLnBuZyIsZHBpID0gNjAwLCBoZWlnaHQgPSAzLjUsIHdpZHRoID0xMCkNCmBgYA0KDQoNCg0KDQoNCiMgUmVsYXRpdmUgaW5mbHVlbmNlIGNvbWJvDQpgYGB7cn0NCiMgc3VtbWFyeV9nYm1fc2JyDQojIHN1bW1hcnlfZ2JtX2NhbG8NCiMgc3VtbWFyeV9nYm1feHkNCiMgc3VtbWFyeV9nYm1fd2xiDQojIHN1bW1hcnlfZ2JtX3BsYg0KYGBgDQoNCg0KYGBge3J9DQpyZWxfc2JyICsgbGFicyh0aXRsZSA9IHBhc3RlKCJTb3liZWFuIHJ1c3QiKSkrDQogIHJlbF9jYWxvICtsYWJzKHRpdGxlID0gcGFzdGUoIkNhbG9uZWN0cmlhIGxlYWYgYmxpZ2h0IikpKw0KICByZWxfd2xiICtsYWJzKHRpdGxlID0gcGFzdGUoIldoZWF0IGxlYWYgYmxhc3QiKSkrDQogIHJlbF9wbGIgK2xhYnModGl0bGUgPSBwYXN0ZSgiUG90YXRvIGxhdGUgYmxpZ2h0IikpKw0KICByZWxfeHkgK2xhYnModGl0bGUgPSBleHByZXNzaW9uKGJvbGRpdGFsaWMoIk4uIHRhYmFjdW0tWC4gZmFzdGlkaW9zYSIpKSkrZ3VpZGVfYXJlYSgpKw0KICBwbG90X2xheW91dChuY29sID0zLCBndWlkZXMgPSAiY29sbGVjdCIpKw0KICBwbG90X2Fubm90YXRpb24odGFnX2xldmVscyA9ICdBJykmDQogIHRoZW1lX21pbmltYWxfZ3JpZChmb250X3NpemUgPSA5KSYNCiAgdGhlbWUocGxvdC50aXRsZSA9IGVsZW1lbnRfdGV4dChzaXplID04KSkmDQogIHhsaW0oMCwxMDApDQpnZ3NhdmUoImZpZ3MvcmVsYXRpdmVfaW5mbHVlbmNlX2NvbWJvLnBuZyIsIGRwaSA9IDMwMCwgaGVpZ2h0ID0gNSwgd2lkdGggPSA2KQ0KYGBgDQpgYGB7cn0NCmJpcGxvdF9yaSA9IGZ1bmN0aW9uKGRhdGFfY29yLCBkYXRhX3JpLCB0aXRsZSwgZmFjZT0icGxhaW4iKXsNCg0KZGF0YV9yaSAlPiUgDQogIHJlbmFtZShpbmRleCA9IHZhcikgJT4lIA0KICBmdWxsX2pvaW4oZGF0YV9jb3IpICU+JSANCiAgZ2dwbG90KGFlcyhyZWwuaW5mLGFicyhjb3IpLGxhYmVsID0gaW5kZXgsIGNvbG9yID0gaW5kZXgpKSsNCiAgIyBnZW9tX3Ntb290aChjb2xvciA9ICJncmF5OTAiLHNlID0gRikrDQogIGdlb21fcG9pbnQoc2l6ZSA9IDMpKw0KICBnZ3JlcGVsOjpnZW9tX3RleHRfcmVwZWwoc2l6ZT0zKSsNCiAgY29vcmRfY2FydGVzaWFuKHhsaW0gPSBjKDAsMTAwKSwNCiAgICAgICAgICAgICAgICAgIHlsaW0gPSBjKDAsMSkpKw0KICB0aGVtZV9taW5pbWFsKCkrDQogIHRoZW1lKGxlZ2VuZC5wb3NpdGlvbiA9ICJub25lIiwNCiAgICAgICAgcGFuZWwuZ3JpZCA9IGVsZW1lbnRfYmxhbmsoKSwNCiAgICAgICAgcGxvdC50aXRsZSA9IGVsZW1lbnRfdGV4dChzaXplID0gMTAsIGZhY2UgPSBmYWNlKSwNCiAgICAgICAgYXhpcy50aWNrcyA9IGVsZW1lbnRfbGluZShjb2xvciA9ICJncmF5IiksDQogICAgICAgIGF4aXMubGluZSA9IGVsZW1lbnRfbGluZShjb2xvciA9ICJncmF5IikpKw0KICBsYWJzKHkgPSAiQWJzb2x1dGUgU3BlYXJtYW4ncyByIiwNCiAgICAgICB4ID0gIlJlbGF0aXZlIEluZmx1ZW5jZSAoJSkiLA0KICAgICAgIHRpdGxlICA9IHBhc3RlKHRpdGxlKSkNCn0NCmBgYA0KDQoNCmBgYHtyfQ0KYmlwbG90X3JpKGRhdGFfY29yID0gY29yX3NiciwgZGF0YV9yaSA9IHN1bW1hcnlfZ2JtX3NiciwgdGl0bGUgPSAiU295YmVhbiBydXN0IikrDQpiaXBsb3RfcmkoZGF0YV9jb3IgPSBjb3JfY2FsbywgZGF0YV9yaSA9IHN1bW1hcnlfZ2JtX2NhbG8sIHRpdGxlID0gIkNhbG9uZWN0cmlhIGxlYWYgYmxpZ2h0IikrDQogIGJpcGxvdF9yaShkYXRhX2NvciA9IGNvcl94eSwgZGF0YV9yaSA9IHN1bW1hcnlfZ2JtX3h5LCB0aXRsZSA9ICJOLiB0YWJhY3VtLVguIGZhc3RpZGlvc2EiLGZhY2UgPSAiaXRhbGljIikrDQogIGJpcGxvdF9yaShkYXRhX2NvciA9IGNvcl93bGIsIGRhdGFfcmkgPSBzdW1tYXJ5X2dibV93bGIsIHRpdGxlID0gIldoZWF0IGxlYWYgYmxhc3QiKSsNCiAgYmlwbG90X3JpKGRhdGFfY29yID0gY29yX1BJLCBkYXRhX3JpID0gc3VtbWFyeV9nYm1fcGxiLCB0aXRsZSA9ICJQb3RhdG8gbGF0ZSBibGlnaHQiKSsNCiAgcGxvdF9sYXlvdXQobnJvdyA9IDMsDQogICAgICAgICAgICAgIG5jb2wgPSAyKSsNCiAgcGxvdF9hbm5vdGF0aW9uKHRhZ19sZXZlbHMgPSAiQSIpKw0KZ2dzYXZlKCJmaWdzL3JpX2Nvci5wbmciLGRwaSA9IDMwMCwgaGVpZ2h0ID0gOCwgd2lkdGggPTYpDQoNCmBgYA0KDQoNCg0KDQojIyMgQWdyZWVtZW50DQoNCmBgYHtyfQ0KIGNvbmNfc2JyK2xhYnModGl0bGUgPSBwYXN0ZSgiU295YmVhbiBydXN0IiksDQogICAgICAgICAgICAgICBzdWJ0aXRsZSA9IHBhc3RlKCJSTVNFID0gIixyb3VuZChhY2N1cmFjeV9zYnIkUk1TRSwyKSwiLCAiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiQ0NDID0gIixyb3VuZChhY2N1cmFjeV9zYnIkQ0NDLDMpKSkrDQogIGNvbmNfY2FsbytsYWJzKHRpdGxlID0gcGFzdGUoIkNhbG9uZWN0cmlhIGxlYWYgYmxpZ2h0IiksDQogICAgICAgICAgICAgICBzdWJ0aXRsZSA9IHBhc3RlKCJSTVNFID0gIixyb3VuZChhY2N1cmFjeV9jYWxvJFJNU0UsMiksIiwgIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIkNDQyA9ICIscm91bmQoYWNjdXJhY3lfY2FsbyRDQ0MsMykpKSsNCiAgY29uY193bGIrbGFicyh0aXRsZSA9IHBhc3RlKCJXaGVhdCBsZWFmIGJsYXN0IiksDQogICAgICAgICAgICAgICBzdWJ0aXRsZSA9IHBhc3RlKCJSTVNFID0gIixyb3VuZChhY2N1cmFjeV93bGIkUk1TRSwyKSwiLCAiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiQ0NDID0gIixyb3VuZChhY2N1cmFjeV93bGIkQ0NDLDMpKSkrDQogIGNvbmNfcGkrbGFicyh0aXRsZSA9IHBhc3RlKCJQb3RhdG8gbGF0ZSBibGlnaHQiKSwNCiAgICAgICAgICAgICAgIHN1YnRpdGxlID0gcGFzdGUoIlJNU0UgPSAiLHJvdW5kKGFjY3VyYWN5X3BpJFJNU0UsMiksIiwgIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIkNDQyA9ICIscm91bmQoYWNjdXJhY3lfcGkkQ0NDLDMpKSkrDQogIGNvbmNfeHkrbGFicyh0aXRsZSA9IGV4cHJlc3Npb24oYm9sZGl0YWxpYygiTi4gdGFiYWN1bS1YLiBmYXN0aWRpb3NhIikpLA0KICAgICAgICAgICAgICAgc3VidGl0bGUgPSBwYXN0ZSgiUk1TRSA9ICIscm91bmQoYWNjdXJhY3lfeHkkUk1TRSwyKSwiLCAiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiQ0NDID0gIixyb3VuZChhY2N1cmFjeV94eSRDQ0MsMykpKSsNCiAgDQogIA0KICAgcGxvdF9sYXlvdXQobmNvbCA9IDMsDQogICAgICAgICAgICAgICB3aWR0aHMgPSBjKDEsIDEsMSksDQogICAgICAgICAgICAgICBoZWlnaHRzID0gYygxLDEpKSsNCg0KICBwbG90X2Fubm90YXRpb24odGFnX2xldmVscyA9ICdBJykmDQogICAgdGhlbWVfbWluaW1hbF9ncmlkKGZvbnRfc2l6ZSA9IDEwKSYNCiAgdGhlbWUocGxvdC50aXRsZSA9IGVsZW1lbnRfdGV4dChzaXplID0xMCwgZmFjZSA9ImJvbGQiKSwNCiAgICAgIHBsb3Quc3VidGl0bGUgPSBlbGVtZW50X3RleHQoc2l6ZSA9MTAsIGZhY2UgPSAicGxhaW4iKSkNCg0KZ2dzYXZlKCJmaWdzL2NvbmNvcmRhbmNlLnBuZyIsIGRwaSA9IDYwMCwgaGVpZ2h0ID0gNiwgd2lkdGggPSA4KQ0KYGBgDQoNCiMgUkdCIGJhbmRzIGJ5IGxlYWYNCg0KDQoNCiMjIyMgRnVuY3Rpb24NCg0KYGBge3J9DQpkZW5zaXR5X3JnYjIgPSBmdW5jdGlvbigNCmZpbGVfbG93ID0gIi4vcGljcy8wMS1zb3liZWFuLXJ1c3QtYmctYmx1ZS9GZXJydWdlbSA1Ml9NZWRpYW4uanBnIiwNCmZpbGVfaGlnaCA9ICIuL3BpY3MvMDEtc295YmVhbi1ydXN0LWJnLWJsdWUvRmVycnVnZW0gNDlfTWVkaWFuLmpwZyIsDQpsaW1pYXIgPSAxMDAsDQppbmRleF9jdXQgPSAiQmx1ZSIsDQpjcm9wQWJvdmU9VCwNCnRpdGxlID0gIlNveWJlYW4gUnVzdCIsZmFjZSA9ICJwbGFpbiIpew0KDQojLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQ0KU0JSX2xvd19FWC5MMTwtc3RhY2socGFzdGUoZmlsZV9sb3cgKSkNClNCUl9sb3dfRVguTDE8LWFnZ3JlZ2F0ZShTQlJfbG93X0VYLkwxLCBmYWN0PTUpDQoNClNCUl9sb3dfRVguTDI8LWZpZWxkTWFzayhtb3NhaWM9U0JSX2xvd19FWC5MMSwgbXlJbmRleCA9IGMoaW5kZXhfY3V0KSwgY3JvcFZhbHVlPWxpbWlhciwgY3JvcEFib3ZlPWNyb3BBYm92ZSwgcGxvdCA9IEYpDQoNCmN1dCA9IG1hc2soU0JSX2xvd19FWC5MMSwgU0JSX2xvd19FWC5MMiRuZXdNb3NhaWMpDQpTQlJfbG93X0VYLkw0PC1maWVsZEluZGV4KG1vc2FpYz1jdXQsDQogICAgICAgICAgICAgICAgICAjIGluZGV4ID1pbmRleCwNCiAgICAgICAgICAgICAgICAgIHBsb3QgPUYpDQoNClNCUl9sb3cgPSBSU3Rvb2xib3g6OmdnUkdCKFNCUl9sb3dfRVguTDIkbmV3TW9zYWljLHIgPSAxLGcgPSAyLGIgPSAzKSsNCiAgdGhlbWVfbWFwKCkrY29vcmRfZml4ZWQoKSsNCiAgdGhlbWUocGFuZWwuYmFja2dyb3VuZCA9IGVsZW1lbnRfcmVjdChjb2xvciA9IE5BLCBmaWxsID0gTkEpLA0KICAgICAgICBwbG90LnRpdGxlID0gZWxlbWVudF90ZXh0KHNpemU9OCwgZmFjZSA9ICJwbGFpbiIpKSsNCiAgbGFicyh0aXRsZSA9ICJMb3ciKQ0KDQpTQlJfbG93X2NvbWIgPSBkYXRhLmZyYW1lKFIgPSBhcy5kYXRhLmZyYW1lKFNCUl9sb3dfRVguTDQkUmVkKSwNCiAgICAgICAgICAgRyA9IGFzLmRhdGEuZnJhbWUoU0JSX2xvd19FWC5MNCRCbHVlKSwNCiAgICAgICAgICAgQiA9IGFzLmRhdGEuZnJhbWUoU0JSX2xvd19FWC5MNCRHcmVlbikpICU+JQ0KICBuYS5vbWl0KCkgJT4lIA0KICBwaXZvdF9sb25nZXIoMTozLG5hbWVzX3RvID0gImJhbmQiLCB2YWx1ZXNfdG8gPSAidmFsdWUiKSAlPiUNCiAgbXV0YXRlKHNldj0iTG93IikNCiMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tDQoNClNCUl9oaWdoX0VYLkwxPC1zdGFjayhwYXN0ZShmaWxlX2hpZ2gpKQ0KU0JSX2hpZ2hfRVguTDE8LWFnZ3JlZ2F0ZShTQlJfaGlnaF9FWC5MMSwgZmFjdD01KQ0KDQpTQlJfaGlnaF9FWC5MMjwtZmllbGRNYXNrKG1vc2FpYz1TQlJfaGlnaF9FWC5MMSwgIG15SW5kZXggPSBjKGluZGV4X2N1dCksIGNyb3BWYWx1ZT1saW1pYXIsIGNyb3BBYm92ZT1jcm9wQWJvdmUsIHBsb3QgPSBGKQ0KDQpjdXQgPSBtYXNrKFNCUl9oaWdoX0VYLkwxLCBTQlJfaGlnaF9FWC5MMiRuZXdNb3NhaWMpDQpTQlJfaGlnaF9FWC5MNDwtZmllbGRJbmRleChtb3NhaWM9Y3V0LA0KICAgICAgICAgICAgICAgICAgIyBpbmRleCA9aW5kZXgsDQogICAgICAgICAgICAgICAgICBwbG90ID1GKQ0KDQpTQlJfaGlnaCA9IFJTdG9vbGJveDo6Z2dSR0IoU0JSX2hpZ2hfRVguTDIkbmV3TW9zYWljLHIgPSAxLGcgPSAyLGIgPSAzKSsNCiAgdGhlbWVfbWFwKCkrY29vcmRfZml4ZWQoKSsNCiAgdGhlbWUocGFuZWwuYmFja2dyb3VuZCA9IGVsZW1lbnRfcmVjdChjb2xvciA9IE5BLCBmaWxsID0gTkEpLA0KICAgICAgICBwbG90LnRpdGxlID0gZWxlbWVudF90ZXh0KHNpemU9OCwgZmFjZSA9ICJwbGFpbiIpKSsNCiAgbGFicyh0aXRsZSA9ICJIaWdoIikNCg0KU0JSX2hpZ2hfY29tYiA9IGRhdGEuZnJhbWUoUiA9IGFzLmRhdGEuZnJhbWUoU0JSX2hpZ2hfRVguTDQkUmVkKSwNCiAgICAgICAgICAgRyA9IGFzLmRhdGEuZnJhbWUoU0JSX2hpZ2hfRVguTDQkQmx1ZSksDQogICAgICAgICAgIEIgPSBhcy5kYXRhLmZyYW1lKFNCUl9oaWdoX0VYLkw0JEdyZWVuKSkgJT4lDQogIG5hLm9taXQoKSAlPiUgDQogIHBpdm90X2xvbmdlcigxOjMsbmFtZXNfdG8gPSAiYmFuZCIsIHZhbHVlc190byA9ICJ2YWx1ZSIpICU+JQ0KICBtdXRhdGUoc2V2PSJIaWdoIikNCg0KIy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0NCmFsbF9jb21iID0gYmluZF9yb3dzKFNCUl9sb3dfY29tYixTQlJfaGlnaF9jb21iKSAlPiUgDQogIG11dGF0ZShzZXYgPWZhY3RvcihzZXYsIGxldmVscyA9YygiTG93IiwiSGlnaCIpKSkNCiMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tDQoNCmFsbF9jb21iICU+JSANCiAgZ2dwbG90KGFlcyh2YWx1ZSxzZXYpKSsNCiAgc3RhdF9zbGFiKGFlcyhmaWxsID0gYmFuZCksIGFscGhhID0gMC43KSsNCiAgIHN0YXRfcG9pbnRpbnRlcnZhbChhZXMoY29sb3IgPSBiYW5kKSwNCiAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uX2RvZGdlKHdpZHRoID0gLjUsIHByZXNlcnZlID0gInNpbmdsZSIpLA0KICAgICAgICAgICAgICAgICAgICAgIyBjb2xvciA9ICJncmF5NDAiLA0KICAgICAgICAgICAgICAgICAgICAgLndpZHRoID0gYygwLDAuOTUpKSsNCiAgDQogIHNjYWxlX2ZpbGxfbWFudWFsKHZhbHVlcyA9IGMoImJsdWUiLCAiZ3JlZW4iLCJyZWQiICkpKw0KICBzY2FsZV9jb2xvcl9tYW51YWwodmFsdWVzID0gYygiYmx1ZSIsICJncmVlbiIsInJlZCIgKSkrDQogIHRoZW1lX21pbmltYWwoKSsNCiAgeGxpbSgwLDI1NSkrDQogIHRoZW1lKHBhbmVsLmdyaWQgPSBlbGVtZW50X2JsYW5rKCksDQogICAgICAgIHBsb3QudGl0bGUgPSBlbGVtZW50X3RleHQoc2l6ZSA9IDEwLCBmYWNlID0gZmFjZSksDQogICAgICAgIGF4aXMudGlja3MgPSBlbGVtZW50X2xpbmUoY29sb3IgPSAiZ3JheSIpLA0KICAgICAgICBheGlzLmxpbmUgPSBlbGVtZW50X2xpbmUoY29sb3IgPSAiZ3JheSIpKSsNCiAgbGFicyh4ID0gIlBpeGVsIGludGVuc2l0eSIsDQogICAgICAgeSA9ICJTZXZlcml0eSIsDQogICAgICAgZmlsbCA9IiIsDQogICAgICAgdGl0bGUgPSBwYXN0ZSh0aXRsZSkpKyAgDQogIGd1aWRlcyhjb2xvciA9RikjKw0KICAjU0JSX2xvdytTQlJfaGlnaCsNCiAgI3Bsb3RfbGF5b3V0KHdpZHRocyA9IGMoMSwgLjIsLjIpKQ0KfQ0KYGBgDQoNCg0KIyMjIHBsb3RzIA0KYGBge3IgbWVzc2FnZT1GQUxTRSwgaW5jbHVkZT1GQUxTRX0NClNCUl9kaXN0ID0gZGVuc2l0eV9yZ2IyKCkNCmNhbG9fZGlzdCA9ZGVuc2l0eV9yZ2IyKGZpbGVfbG93ID0iLi9waWNzLzAxLUNhbG9uZWN0cmlhX2xlYWZfYmxpZ3RoLzEwOC5qcGciLA0KICAgICAgICAgICAgICAgICAgICAgICAgZmlsZV9oaWdoID0gIi4vcGljcy8wMS1DYWxvbmVjdHJpYV9sZWFmX2JsaWd0aC8xNTMuanBnIiwNCiAgICAgICAgICAgICAgICAgICAgICAgIGxpbWlhciA9IDE3NSxpbmRleF9jdXQgPSAiQmx1ZSIsY3JvcEFib3ZlPVQsDQogICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSA9ICJDYWxvbmVjdHJpYSBsZWFmIGJsaWdodCIpDQoNCnh5X2Rpc3QgPSBkZW5zaXR5X3JnYjIoZmlsZV9sb3cgPSIuL3BpY3MvMDEtWHlsZWxsYS10b2JhY2NvLWJnLXdoaXRlLzY4LmpwZyIsDQogICAgICAgICAgICAgICAgICAgICAgICBmaWxlX2hpZ2ggPSAiLi9waWNzLzAxLVh5bGVsbGEtdG9iYWNjby1iZy13aGl0ZS84Mi5qcGciLA0KICAgICAgICAgICAgICAgICAgICAgICAgbGltaWFyID0gMjAwLGluZGV4X2N1dCA9ICJCbHVlIiwgY3JvcEFib3ZlPVQsDQogICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSA9ICJOLiB0YWJhY3VtLVguIGZhc3RpZGlvc2EiLCBmYWNlID0gIml0YWxpYyIpDQoNCg0Kd2xiX2Rpc3QgPSBkZW5zaXR5X3JnYjIoZmlsZV9sb3cgPSIuL3BpY3MvMDEtV2hlYXRfbGVhZl9ibGFzdC9HXzEwOF9SMy5qcGciLA0KICAgICAgICAgICAgICAgICAgICAgICAgZmlsZV9oaWdoID0gIi4vcGljcy8wMS1XaGVhdF9sZWFmX2JsYXN0L1RfMjM5X1IxLmpwZyIsDQogICAgICAgICAgICAgICAgICAgICAgICBsaW1pYXIgPSAxODAsaW5kZXhfY3V0ID0gIkJsdWUiLGNyb3BBYm92ZT1ULA0KICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGUgPSAiV2hlYXQgbGVhZiBibGFzdCIpDQoNCnBsYl9kaXN0ID0gZGVuc2l0eV9yZ2IyKGZpbGVfbG93ID0iLi9waWNzLzAxLXBvdGF0b19sYXRlX2JsaWdoL1BJMjRfNkIucG5nIiwNCiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVfaGlnaCA9ICIuL3BpY3MvMDEtcG90YXRvX2xhdGVfYmxpZ2gvUEkwN18yQS5wbmciLA0KICAgICAgICAgICAgICAgICAgICAgICAgbGltaWFyID0gMSxpbmRleF9jdXQgPSAiUmVkIixjcm9wQWJvdmU9RiwNCiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlID0gIlBvdGF0byBsYXRlIGJsaWdodCIpDQpgYGANCg0KDQoNCiMjIyMgY29tYm8NCg0KDQpgYGB7ciBmaWcuaGVpZ2h0PTcsIGZpZy53aWR0aD02fQ0KKFNCUl9kaXN0K2NhbG9fZGlzdCt4eV9kaXN0K3dsYl9kaXN0K3BsYl9kaXN0K2d1aWRlX2FyZWEoKSkrDQogIHBsb3RfbGF5b3V0KG5yb3cgPSAzLA0KICAgICAgICAgICAgICBuY29sID0gMiwNCiAgICAgICAgICAgICAgdGFnX2xldmVsID0gImtlZXAiLA0KICAgICAgICAgICAgICAjIHdpZHRocyA9IGMoMSwxLDEsMSwxKSwNCiAgICAgICAgICAgICAgZ3VpZGVzID0gJ2NvbGxlY3QnKSsNCiAgcGxvdF9hbm5vdGF0aW9uKHRhZ19sZXZlbHMgPSAiQSIpKw0KICAjIHBsb3RfYW5ub3RhdGlvbih0YWdfbGV2ZWxzID0gbGlzdCh0YWdzMikpJg0KICB0aGVtZShsZWdlbmQua2V5LnNpemUgPSB1bml0KDUsICdtbScpLA0KICAgICAgICBsZWdlbmQucG9zaXRpb24gPSAibm9uZSIsDQogICAgICAgIGxlZ2VuZC50ZXh0ID0gZWxlbWVudF90ZXh0KHNpemUgPTEwKSkNCmdnc2F2ZSgiZmlncy9SR0JfZGVuczIucG5nIixkcGkgPSA2MDAsIGhlaWdodCA9IDcsIHdpZHRoID02KQ0KYGBgDQoNCmBgYHtyfQ0KZGVuc2l0eV9yZ2JfaW1hZ2VzID0gZnVuY3Rpb24oDQpmaWxlX2xvdyA9ICIuL3BpY3MvMDEtc295YmVhbi1ydXN0LWJnLWJsdWUvRmVycnVnZW0gNTJfTWVkaWFuLmpwZyIsDQpmaWxlX2hpZ2ggPSAiLi9waWNzLzAxLXNveWJlYW4tcnVzdC1iZy1ibHVlL0ZlcnJ1Z2VtIDQ5X01lZGlhbi5qcGciLA0KbGltaWFyID0gMTAwLA0KaW5kZXhfY3V0ID0gIkJsdWUiLA0KY3JvcEFib3ZlPVQsDQp0aXRsZSA9ICJTb3liZWFuIFJ1c3QiLGZhY2UgPSAicGxhaW4iKXsNCg0KIy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0NClNCUl9sb3dfRVguTDE8LXN0YWNrKHBhc3RlKGZpbGVfbG93ICkpDQpTQlJfbG93X0VYLkwxPC1hZ2dyZWdhdGUoU0JSX2xvd19FWC5MMSwgZmFjdD01KQ0KDQpTQlJfbG93X0VYLkwyPC1maWVsZE1hc2sobW9zYWljPVNCUl9sb3dfRVguTDEsIG15SW5kZXggPSBjKGluZGV4X2N1dCksIGNyb3BWYWx1ZT1saW1pYXIsIGNyb3BBYm92ZT1jcm9wQWJvdmUsIHBsb3QgPSBGKQ0KDQpjdXQgPSBtYXNrKFNCUl9sb3dfRVguTDEsIFNCUl9sb3dfRVguTDIkbmV3TW9zYWljKQ0KU0JSX2xvd19FWC5MNDwtZmllbGRJbmRleChtb3NhaWM9Y3V0LA0KICAgICAgICAgICAgICAgICAgIyBpbmRleCA9aW5kZXgsDQogICAgICAgICAgICAgICAgICBwbG90ID1GKQ0KDQpTQlJfbG93ID0gUlN0b29sYm94OjpnZ1JHQihTQlJfbG93X0VYLkwyJG5ld01vc2FpYyxyID0gMSxnID0gMixiID0gMykrDQogIHRoZW1lX21hcCgpK2Nvb3JkX2ZpeGVkKCkrDQogIHRoZW1lKHBhbmVsLmJhY2tncm91bmQgPSBlbGVtZW50X3JlY3QoY29sb3IgPSBOQSwgZmlsbCA9IE5BKSwNCiAgICAgICAgcGxvdC50aXRsZSA9IGVsZW1lbnRfdGV4dChzaXplPTgsIGZhY2UgPSAicGxhaW4iKSkjKw0KICAjIGxhYnModGl0bGUgPSAiTG93IikNCg0KU0JSX2xvd19jb21iID0gZGF0YS5mcmFtZShSID0gYXMuZGF0YS5mcmFtZShTQlJfbG93X0VYLkw0JFJlZCksDQogICAgICAgICAgIEcgPSBhcy5kYXRhLmZyYW1lKFNCUl9sb3dfRVguTDQkQmx1ZSksDQogICAgICAgICAgIEIgPSBhcy5kYXRhLmZyYW1lKFNCUl9sb3dfRVguTDQkR3JlZW4pKSAlPiUNCiAgbmEub21pdCgpICU+JSANCiAgcGl2b3RfbG9uZ2VyKDE6MyxuYW1lc190byA9ICJiYW5kIiwgdmFsdWVzX3RvID0gInZhbHVlIikgJT4lDQogIG11dGF0ZShzZXY9IkxvdyIpDQojLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQ0KDQpTQlJfaGlnaF9FWC5MMTwtc3RhY2socGFzdGUoZmlsZV9oaWdoKSkNClNCUl9oaWdoX0VYLkwxPC1hZ2dyZWdhdGUoU0JSX2hpZ2hfRVguTDEsIGZhY3Q9NSkNCg0KU0JSX2hpZ2hfRVguTDI8LWZpZWxkTWFzayhtb3NhaWM9U0JSX2hpZ2hfRVguTDEsICBteUluZGV4ID0gYyhpbmRleF9jdXQpLCBjcm9wVmFsdWU9bGltaWFyLCBjcm9wQWJvdmU9Y3JvcEFib3ZlLCBwbG90ID0gRikNCg0KY3V0ID0gbWFzayhTQlJfaGlnaF9FWC5MMSwgU0JSX2hpZ2hfRVguTDIkbmV3TW9zYWljKQ0KU0JSX2hpZ2hfRVguTDQ8LWZpZWxkSW5kZXgobW9zYWljPWN1dCwNCiAgICAgICAgICAgICAgICAgICMgaW5kZXggPWluZGV4LA0KICAgICAgICAgICAgICAgICAgcGxvdCA9RikNCg0KU0JSX2hpZ2ggPSBSU3Rvb2xib3g6OmdnUkdCKFNCUl9oaWdoX0VYLkwyJG5ld01vc2FpYyxyID0gMSxnID0gMixiID0gMykrDQogIHRoZW1lX21hcCgpK2Nvb3JkX2ZpeGVkKCkrDQogIHRoZW1lKHBhbmVsLmJhY2tncm91bmQgPSBlbGVtZW50X3JlY3QoY29sb3IgPSBOQSwgZmlsbCA9IE5BKSwNCiAgICAgICAgcGxvdC50aXRsZSA9IGVsZW1lbnRfdGV4dChzaXplPTgsIGZhY2UgPSAicGxhaW4iKSkjKw0KICAjIGxhYnModGl0bGUgPSAiSGlnaCIpDQoNClNCUl9oaWdoX2NvbWIgPSBkYXRhLmZyYW1lKFIgPSBhcy5kYXRhLmZyYW1lKFNCUl9oaWdoX0VYLkw0JFJlZCksDQogICAgICAgICAgIEcgPSBhcy5kYXRhLmZyYW1lKFNCUl9oaWdoX0VYLkw0JEJsdWUpLA0KICAgICAgICAgICBCID0gYXMuZGF0YS5mcmFtZShTQlJfaGlnaF9FWC5MNCRHcmVlbikpICU+JQ0KICBuYS5vbWl0KCkgJT4lIA0KICBwaXZvdF9sb25nZXIoMTozLG5hbWVzX3RvID0gImJhbmQiLCB2YWx1ZXNfdG8gPSAidmFsdWUiKSAlPiUNCiAgbXV0YXRlKHNldj0iSGlnaCIpDQoNCiMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tDQphbGxfY29tYiA9IGJpbmRfcm93cyhTQlJfbG93X2NvbWIsU0JSX2hpZ2hfY29tYikgJT4lIA0KICBtdXRhdGUoc2V2ID1mYWN0b3Ioc2V2LCBsZXZlbHMgPWMoIkxvdyIsIkhpZ2giKSkpDQojLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQ0KDQojIGFsbF9jb21iICU+JSANCiMgICBnZ3Bsb3QoYWVzKHZhbHVlLHNldikpKw0KIyAgIHN0YXRfc2xhYihhZXMoZmlsbCA9IGJhbmQpLCBhbHBoYSA9IDAuNykrDQojICAgIHN0YXRfcG9pbnRpbnRlcnZhbChhZXMoY29sb3IgPSBiYW5kKSwNCiMgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gcG9zaXRpb25fZG9kZ2Uod2lkdGggPSAuNSwgcHJlc2VydmUgPSAic2luZ2xlIiksDQojICAgICAgICAgICAgICAgICAgICAgICMgY29sb3IgPSAiZ3JheTQwIiwNCiMgICAgICAgICAgICAgICAgICAgICAgLndpZHRoID0gYygwLDAuOTUpKSsNCiMgICANCiMgICBzY2FsZV9maWxsX21hbnVhbCh2YWx1ZXMgPSBjKCJibHVlIiwgImdyZWVuIiwicmVkIiApKSsNCiMgICBzY2FsZV9jb2xvcl9tYW51YWwodmFsdWVzID0gYygiYmx1ZSIsICJncmVlbiIsInJlZCIgKSkrDQojICAgdGhlbWVfbWluaW1hbCgpKw0KIyAgIHhsaW0oMCwyNTUpKw0KIyAgIHRoZW1lKHBhbmVsLmdyaWQgPSBlbGVtZW50X2JsYW5rKCksDQojICAgICAgICAgcGxvdC50aXRsZSA9IGVsZW1lbnRfdGV4dChzaXplID0gMTAsIGZhY2UgPSBmYWNlKSwNCiMgICAgICAgICBheGlzLnRpY2tzID0gZWxlbWVudF9saW5lKGNvbG9yID0gImdyYXkiKSwNCiMgICAgICAgICBheGlzLmxpbmUgPSBlbGVtZW50X2xpbmUoY29sb3IgPSAiZ3JheSIpKSsNCiMgICBsYWJzKHggPSAiUGl4ZWwgaW50ZW5zaXR5IiwNCiMgICAgICAgIHkgPSAiU2V2ZXJpdHkiLA0KIyAgICAgICAgZmlsbCA9IiIsDQojICAgICAgICB0aXRsZSA9IHBhc3RlKHRpdGxlKSkrICANCiMgICBndWlkZXMoY29sb3IgPUYpIysNCiAgU0JSX2xvd3xTQlJfaGlnaA0KICAjcGxvdF9sYXlvdXQod2lkdGhzID0gYygxLCAuMiwuMikpDQp9DQpgYGANCg0KDQojIyMgcGxvdHMgDQpgYGB7ciBtZXNzYWdlPUZBTFNFLCBpbmNsdWRlPUZBTFNFfQ0KU0JSX2Rpc3RfaW1nID0gZGVuc2l0eV9yZ2JfaW1hZ2VzKCkNCmNhbG9fZGlzdF9pbWcgPWRlbnNpdHlfcmdiX2ltYWdlcyhmaWxlX2xvdyA9Ii4vcGljcy8wMS1DYWxvbmVjdHJpYV9sZWFmX2JsaWd0aC8xMDguanBnIiwNCiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVfaGlnaCA9ICIuL3BpY3MvMDEtQ2Fsb25lY3RyaWFfbGVhZl9ibGlndGgvMTUzLmpwZyIsDQogICAgICAgICAgICAgICAgICAgICAgICBsaW1pYXIgPSAxNzUsaW5kZXhfY3V0ID0gIkJsdWUiLGNyb3BBYm92ZT1ULA0KICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGUgPSAiQ2Fsb25lY3RyaWEgbGVhZiBibGlnaHQiKQ0KDQp4eV9kaXN0X2ltZyA9IGRlbnNpdHlfcmdiX2ltYWdlcyhmaWxlX2xvdyA9Ii4vcGljcy8wMS1YeWxlbGxhLXRvYmFjY28tYmctd2hpdGUvNjguanBnIiwNCiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVfaGlnaCA9ICIuL3BpY3MvMDEtWHlsZWxsYS10b2JhY2NvLWJnLXdoaXRlLzgyLmpwZyIsDQogICAgICAgICAgICAgICAgICAgICAgICBsaW1pYXIgPSAyMDAsaW5kZXhfY3V0ID0gIkJsdWUiLCBjcm9wQWJvdmU9VCwNCiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlID0gIk4uIHRhYmFjdW0tWC4gZmFzdGlkaW9zYSIsIGZhY2UgPSAiaXRhbGljIikNCg0KDQp3bGJfZGlzdF9pbWcgPSBkZW5zaXR5X3JnYl9pbWFnZXMoZmlsZV9sb3cgPSIuL3BpY3MvMDEtV2hlYXRfbGVhZl9ibGFzdC9HXzEwOF9SMy5qcGciLA0KICAgICAgICAgICAgICAgICAgICAgICAgZmlsZV9oaWdoID0gIi4vcGljcy8wMS1XaGVhdF9sZWFmX2JsYXN0L1RfMjM5X1IxLmpwZyIsDQogICAgICAgICAgICAgICAgICAgICAgICBsaW1pYXIgPSAxODAsaW5kZXhfY3V0ID0gIkJsdWUiLGNyb3BBYm92ZT1ULA0KICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGUgPSAiV2hlYXQgbGVhZiBibGFzdCIpDQoNCnBsYl9kaXN0X2ltZyA9IGRlbnNpdHlfcmdiX2ltYWdlcyhmaWxlX2xvdyA9Ii4vcGljcy8wMS1wb3RhdG9fbGF0ZV9ibGlnaC9QSTI0XzZCLnBuZyIsDQogICAgICAgICAgICAgICAgICAgICAgICBmaWxlX2hpZ2ggPSAiLi9waWNzLzAxLXBvdGF0b19sYXRlX2JsaWdoL1BJMDdfMkEucG5nIiwNCiAgICAgICAgICAgICAgICAgICAgICAgIGxpbWlhciA9IDEsaW5kZXhfY3V0ID0gIlJlZCIsY3JvcEFib3ZlPUYsDQogICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSA9ICJQb3RhdG8gbGF0ZSBibGlnaHQiKQ0KYGBgDQoNCg0KDQojIyMjIGNvbWJvDQoNCg0KYGBge3IgZmlnLmhlaWdodD03LCBmaWcud2lkdGg9Nn0NClNCUl9kaXN0X2ltZy9jYWxvX2Rpc3RfaW1nL3h5X2Rpc3RfaW1nL3dsYl9kaXN0X2ltZy9wbGJfZGlzdF9pbWcrDQogIHBsb3RfbGF5b3V0KG5jb2wgPSAxLA0KICAgICAgICAgICAgICBucm93ID01KSsNCiAgcGxvdF9hbm5vdGF0aW9uKHRhZ19sZXZlbHMgPSAiQSIpJg0KICB0aGVtZShsZWdlbmQudGV4dCA9IGVsZW1lbnRfdGV4dChzaXplID0xMCkpDQpnZ3NhdmUoImZpZ3MvUkdCX2RlbnNfaW1nLnBuZyIsZHBpID0gOTAwLCBoZWlnaHQgPSA2LCB3aWR0aCA9MykNCmBgYA0KDQojIyBQcmluY2lwYWwgY29tcG9uZW50IGFuYWx5c2lzDQojIyMgU0JSDQpgYGB7cn0NCnBjYV9zYnIgPSBQQ0EoYWxsX2RhdGFfc3ByZWFkX3NiclsyOjE1XSwgZ3JhcGggPSBGKQ0KYmlwbG90X3NiciA9IGZ2aXpfcGNhX2JpcGxvdChwY2Ffc2JyLCBnZW9tID0gInBvaW50IiwNCiAgICAgICAgICAgICAgICBnZW9tLnZhciA9IGMoInRleHQiLCJhcnJvdyIpLA0KICAgICAgICAgICAgICAgIGNvbC5pbmQgPSBhbGxfZGF0YV9zcHJlYWRfc2JyJHNldiwgDQogICAgICAgICAgICAgICAgY29sLnZhciA9ICJibGFjayIsDQogICAgICAgICAgICAgICAgcmVwZWwgPSBULA0KICAgICAgICAgICAgICAgIGxhYmVsc2l6ZSA9IDIpKw0KICBsYWJzKHRpdGxlID0gIlNveWJlYW4gcnVzdCIpKw0KICBzY2FsZV9jb2xvcl9ncmFkaWVudChsb3cgPSAiZ3JheTkwIiwgaGlnaCA9ICJncmF5NDAiLCBuYW1lID0gIlNldmVyaXR5ICglKSIsIGxpbWl0cyA9YygwLDEwMCkpDQpgYGANCg0KIyMjIENhbG9uZWN0cmlhDQpgYGB7cn0NCnBjYV9jYWxvID0gUENBKGFsbF9kYXRhX3NwcmVhZF9jYWxvWzI6MTVdLCBncmFwaCA9IEYpDQpiaXBsb3RfY2FsbyA9IGZ2aXpfcGNhX2JpcGxvdChwY2FfY2FsbywgZ2VvbSA9ICJwb2ludCIsDQogICAgICAgICAgICAgICAgZ2VvbS52YXIgPSBjKCJ0ZXh0IiwiYXJyb3ciKSwNCiAgICAgICAgICAgICAgICBjb2wuaW5kID0gYWxsX2RhdGFfc3ByZWFkX2NhbG8kc2V2LCANCiAgICAgICAgICAgICAgICBjb2wudmFyID0gImJsYWNrIiwNCiAgICAgICAgICAgICAgICByZXBlbCA9IFQsDQogICAgICAgICAgICAgICAgbGFiZWxzaXplID0gMikrDQogIGxhYnModGl0bGUgPSAiQ2Fsb25lY3RyaWEgbGVhZiBibGlnaHQiKSsNCiAgc2NhbGVfY29sb3JfZ3JhZGllbnQobG93ID0gImdyYXk5MCIsIGhpZ2ggPSAiZ3JheTQwIiwgbmFtZSA9ICJTZXZlcml0eSAoJSkiLCBsaW1pdHMgPWMoMCwxMDApKQ0KYGBgDQoNCiMjIyBOdFhmDQpgYGB7cn0NCnBjYV94eSA9IFBDQShhbGxfZGF0YV9zcHJlYWRfeHlbMjoxNV0sIGdyYXBoID0gRikNCmJpcGxvdF94eSA9IGZ2aXpfcGNhX2JpcGxvdChwY2FfeHksICBnZW9tID0gInBvaW50IiwNCiAgICAgICAgICAgICAgICBnZW9tLnZhciA9IGMoInRleHQiLCJhcnJvdyIpLA0KICAgICAgICAgICAgICAgIGNvbC5pbmQgPSBhbGxfZGF0YV9zcHJlYWRfeHkkc2V2LCANCiAgICAgICAgICAgICAgICBjb2wudmFyID0gImJsYWNrIiwNCiAgICAgICAgICAgICAgICByZXBlbCA9IFQsDQogICAgICAgICAgICAgICAgbGFiZWxzaXplID0gMikrDQogIGxhYnModGl0bGUgPSBleHByZXNzaW9uKGl0YWxpYygiTi4gdGFiYWN1bS1YLmZhc3RpZGlvc2EiKSkpKw0KICBzY2FsZV9jb2xvcl9ncmFkaWVudChsb3cgPSAiZ3JheTkwIiwgaGlnaCA9ICJncmF5NDAiLCBuYW1lID0gIlNldmVyaXR5ICglKSIsIGxpbWl0cyA9YygwLDEwMCkpDQpgYGANCg0KIyMjIFdMQg0KDQoNCmBgYHtyfQ0KcGNhX3dsYiA9IFBDQShhbGxfZGF0YV9zcHJlYWRfd2xiWzI6MTVdLCBncmFwaCA9IEYpDQoNCmJpcGxvdF93bGIgPSBmdml6X3BjYV9iaXBsb3QocGNhX3dsYiwgZ2VvbSA9ICJwb2ludCIsDQogICAgICAgICAgICAgICAgZ2VvbS52YXIgPSBjKCJ0ZXh0IiwiYXJyb3ciKSwNCiAgICAgICAgICAgICAgICBjb2wuaW5kID0gYWxsX2RhdGFfc3ByZWFkX3dsYiRzZXYsIA0KICAgICAgICAgICAgICAgIGNvbC52YXIgPSAiYmxhY2siLA0KICAgICAgICAgICAgICAgIHJlcGVsID0gVCwNCiAgICAgICAgICAgICAgICBsYWJlbHNpemUgPSAyKSsNCiAgbGFicyh0aXRsZSA9ICJXaGVhdCBsZWFmIGJsYXN0IikrDQogIHNjYWxlX2NvbG9yX2dyYWRpZW50KGxvdyA9ICJncmF5OTAiLCBoaWdoID0gImdyYXk0MCIsIG5hbWUgPSAiU2V2ZXJpdHkgKCUpIiwgbGltaXRzID1jKDAsMTAwKSkNCmBgYA0KDQojIyNQTEINCg0KYGBge3J9DQpwY2FfcGxiID0gUENBKGFsbF9kYXRhX3NwcmVhZF9wbGJbMjoxNV0sIGdyYXBoID0gRikNCmJpcGxvdF9wbGIgPSBmdml6X3BjYV9iaXBsb3QocGNhX3BsYiwgZ2VvbSA9ICJwb2ludCIsDQogICAgICAgICAgICAgICAgZ2VvbS52YXIgPSBjKCJ0ZXh0IiwiYXJyb3ciKSwNCiAgICAgICAgICAgICAgICBjb2wuaW5kID0gYWxsX2RhdGFfc3ByZWFkX3BsYiRzZXYsIA0KICAgICAgICAgICAgICAgIGNvbC52YXIgPSAiYmxhY2siLA0KICAgICAgICAgICAgICAgIHJlcGVsID0gVCwNCiAgICAgICAgICAgICAgICBsYWJlbHNpemUgPSAyKSsNCiAgbGFicyh0aXRsZSA9ICJQb3RhdG8gbGF0ZSBibGlnaHQiKSsNCiAgc2NhbGVfY29sb3JfZ3JhZGllbnQobG93ID0gImdyYXk5MCIsIGhpZ2ggPSAiZ3JheTQwIiwgbmFtZSA9ICJTZXZlcml0eSAoJSkiLCBsaW1pdHMgPWMoMCwxMDApKQ0KYGBgDQoNCiMjIw0KYGBge3IgZmlnLmhlaWdodD04LCBmaWcud2lkdGg9Nn0NCmJpcGxvdF9zYnIrYmlwbG90X2NhbG8rYmlwbG90X3h5K2JpcGxvdF93bGIrYmlwbG90X3BsYitndWlkZV9hcmVhKCkrDQogIHBsb3RfbGF5b3V0KG5jb2wgPSAyLA0KICAgICAgICAgICAgICBndWlkZXMgPSAiY29sbGVjdCIpKw0KICBwbG90X2Fubm90YXRpb24odGFnX2xldmVscyA9ICJBIikmDQogIHRoZW1lX21pbmltYWwoKSsNCiAgdGhlbWUoI2xlZ2VuZC5wb3NpdGlvbiA9ICJub25lIiwNCiAgICAgICAgYXhpcy50ZXh0ID0gZWxlbWVudF90ZXh0KHNpemU9OCksDQogICAgICAgIGF4aXMudGl0bGUgPSBlbGVtZW50X3RleHQoc2l6ZT04KSwNCiAgICAgICAgcGxvdC50aXRsZSA9IGVsZW1lbnRfdGV4dChzaXplPTEwKSwNCiAgICAgICAgcGFuZWwuZ3JpZCA9IGVsZW1lbnRfYmxhbmsoKSwNCiAgICAgICAgYXhpcy50aWNrcyA9IGVsZW1lbnRfbGluZShjb2xvciA9ICJncmF5IiksDQogICAgICAgIGF4aXMubGluZSA9IGVsZW1lbnRfbGluZShjb2xvciA9ICJncmF5IikpDQoNCmdnc2F2ZSgiZmlncy9iaXBsb3RzLnBuZyIsZHBpID0gNjAwLCBoZWlnaHQgPSA4LCB3aWR0aCA9NikNCmBgYA0KDQo=</div>


Copyright 2017 Emerson Del Ponte


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("main_code_RGB_index.Rmd");
});
</script>

<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = false;
    options.smoothScroll = false;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
