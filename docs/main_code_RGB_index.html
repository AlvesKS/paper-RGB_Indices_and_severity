<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Data analysis</title>

<script src="site_libs/header-attrs-2.5/header-attrs.js"></script>
<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/pagedtable-1.1/css/pagedtable.css" rel="stylesheet" />
<script src="site_libs/pagedtable-1.1/js/pagedtable.js"></script>
<link href="site_libs/anchor-sections-1.0/anchor-sections.css" rel="stylesheet" />
<script src="site_libs/anchor-sections-1.0/anchor-sections.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
#rmd-source-code {
  display: none;
}
</style>

<link rel="stylesheet" href="my-style.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}

.tocify-subheader {
  display: inline;
}
.tocify-subheader .tocify-item {
  font-size: 0.95em;
}

</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">RGB-indices and severity</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">
    <span class="fa fa fa fa-home"></span>
     
    About
  </a>
</li>
<li>
  <a href="main_code_RGB_index.html">
    <span class="fa fa fa fa-file-code-o"></span>
     
    Data analysis
  </a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/AlvesKS/paper-RGB_Indices_and_severity">
    <span class="fa fa-github-square"></span>
     
    source
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">

<div class="btn-group pull-right">
<button type="button" class="btn btn-default btn-xs dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu" style="min-width: 50px;">
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Data analysis</h1>

</div>


<div id="necessary-packages" class="section level1">
<h1>Necessary packages</h1>
<pre class="r"><code>library(tidyverse)
library(FIELDimageR)
library(raster)
library(readxl)
library(gsheet)
library(foreach)
library(agricolae)
library(reshape2)
library(cowplot)
library(gbm)
library(lime)
library(lme4)
library(DescTools)
library(factoextra)
library(FactoMineR)
library(corrplot)
library(magick)
library(patchwork)
library(forcats)
library(ggdist)</code></pre>
</div>
<div id="example-of-rgb-indices-for-one-image" class="section level1">
<h1>Example of RGB indices for one image</h1>
<p>Load pictures names</p>
<pre class="r"><code>pics&lt;-list.files(&quot;./pics/01-soybean-rust-bg-blue&quot;)
length(pics)</code></pre>
<pre><code>## [1] 203</code></pre>
<pre class="r"><code># write(pics, &quot;pics_names.txt&quot;)</code></pre>
<p>List of RGB-based spectral indices to be calculated in the image</p>
<pre class="r"><code># Vegetation indices
index = c(&quot;BI&quot;,&quot;SCI&quot;,&quot;GLI&quot;,&quot;HI&quot;,&quot;SI&quot;,&quot;VARI&quot;,&quot;HUE&quot;,&quot;BGI&quot;,&quot;NGRDI&quot;)</code></pre>
<p>Load a single image</p>
<pre class="r"><code>#Choose one image to prepare the pipeline
EX.L1&lt;-stack(paste(&quot;./pics/01-soybean-rust-bg-blue/&quot;,pics[110],sep = &quot;&quot;))
EX.L1&lt;-aggregate(EX.L1, fact=7)
EX.L.Shape&lt;-fieldPolygon(mosaic=EX.L1, extent=T, plot =T)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-4-1.png" width="672" /></p>
<pre class="r"><code># plotRGB(EX.L.Shape)</code></pre>
<pre class="r"><code>EX1.Indices&lt;- fieldIndex(mosaic = EX.L1,
                         index = index, 
                         myIndex = c(&quot;Blue&quot;), plot = T)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-5-1.png" width="672" /></p>
<pre class="r"><code>plot(EX1.Indices$Blue)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-6-1.png" width="672" /></p>
<pre class="r"><code>hist(EX1.Indices$Blue)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-6-2.png" width="672" /></p>
<div id="mask" class="section level3">
<h3>mask</h3>
<pre class="r"><code># EX.L2&lt;-fieldMask(mosaic=EX.L1, myIndex = &quot;Red&quot;, cropValue=200, cropAbove=T, plot = T)
# EX.L2&lt;-fieldMask(mosaic=EX.L1, index = &quot;BI&quot;, cropValue=1, cropAbove=F, plot = T)
EX.L2&lt;-fieldMask(mosaic=EX.L1, myIndex = c(&quot;Blue&quot;), cropValue=90, cropAbove=T, plot = T)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;
## [1] &quot;Mask equation myIndex=Blue&quot;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-7-1.png" width="672" /></p>
<pre class="r"><code># plotRGB(EX.L2$newMosaic)
plotRGB(EX.L2$newMosaic)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-7-2.png" width="672" /></p>
<pre class="r"><code>class(EX.L2$mask)</code></pre>
<pre><code>## [1] &quot;RasterStack&quot;
## attr(,&quot;package&quot;)
## [1] &quot;raster&quot;</code></pre>
<pre class="r"><code>rgb_fig = RStoolbox::ggRGB(EX.L2$newMosaic,
                 r = 1,
                 g = 2,
                 b = 3)+
  theme_void()+
  coord_fixed()</code></pre>
<pre><code>## Coordinate system already present. Adding new coordinate system, which will replace the existing one.</code></pre>
<pre class="r"><code>cut = mask(EX.L1, EX.L2$newMosaic)
plot(cut)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-9-1.png" width="672" /></p>
<pre class="r"><code>EX.L4&lt;-fieldIndex(mosaic=cut,
                  index = index)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-9-2.png" width="672" /></p>
<pre class="r"><code>plot(EX.L4$BGI)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-9-3.png" width="672" /></p>
<pre class="r"><code>gli_fig = as.data.frame(EX.L4$NGRDI, xy=TRUE, na.rm =T) %&gt;% 
  ggplot(aes(x, y, fill = NGRDI))+
  geom_tile()+
  # scale_fill_distiller(palette = &quot;Spectral&quot;, direction = 1)+
  scale_fill_gradient2(low = &quot;red&quot;, mid =&quot;green&quot;, high = &quot;green&quot;, midpoint = 0.2)+
  # scale_fill_viridis_c(option = &quot;B&quot;,direction = -1)+
  theme_void()+
  coord_fixed()</code></pre>
<pre class="r"><code>plot_grid(rgb_fig, gli_fig, axis = &quot;b&quot;,
          rel_widths = c(0.9,1),
          labels = c(&quot;RGB&quot;, &quot;NGRDI&quot;),
          scale = 0.90)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-11-1.png" width="672" /></p>
<pre class="r"><code># ggsave(&quot;figs/leaf_gli.png&quot;,dpi = 600, height = 3, width =10 )</code></pre>
<pre class="r"><code>df = as(EX.L4, &quot;SpatialPixelsDataFrame&quot;)
dff = as.data.frame(df) %&gt;% 
  gather(1:(3+length(index)), key = &quot;index&quot;, value = &quot;value&quot; ) %&gt;%
  filter(!is.na(value),
         !is.infinite(value)) %&gt;% 
  group_by(index) %&gt;% 
  summarise(mean = mean(value, na.rm = T),
            std = sd(value),
            Q25 = quantile(value,0.25),
            Q50 = quantile(value,0.50),
            Q75 = quantile(value,0.75)) %&gt;% 
  mutate(leaf = pics[30])</code></pre>
<pre><code>## `summarise()` ungrouping output (override with `.groups` argument)</code></pre>
</div>
</div>
<div id="wheat-leaf-blast" class="section level1">
<h1>Wheat leaf blast</h1>
<pre class="r"><code>pics&lt;-list.files(&quot;./pics/01-Wheat_leaf_blast&quot;)
# length(pics)
#indices
index = c(&quot;BI&quot;,&quot;SCI&quot;,&quot;GLI&quot;,&quot;HI&quot;,&quot;SI&quot;,&quot;VARI&quot;,&quot;HUE&quot;,&quot;BGI&quot;,&quot;NGRDI&quot;)


box = data.frame()

for(i in 1:length(pics)){

EX.L1&lt;-stack(paste(&quot;./pics/01-Wheat_leaf_blast/&quot;,pics[i],sep = &quot;&quot;))
EX.L1&lt;-aggregate(EX.L1, fact=10)
EX.L.Shape&lt;-fieldPolygon(mosaic=EX.L1, extent=T, plot = F)

EX1.Indices&lt;- fieldIndex(mosaic = EX.L1,
                         index = index, 
                         myIndex = c(&quot;Green&quot;), plot = F)

EX.L2&lt;-fieldMask(mosaic=EX.L1,  myIndex = c(&quot;Blue&quot;), cropValue=180, cropAbove=T, plot = F)

cut = mask(EX.L1, EX.L2$newMosaic)
EX.L4&lt;-fieldIndex(mosaic=cut,
                  index =index,
                  plot =F)


df = as(EX.L4, &quot;SpatialPixelsDataFrame&quot;)
dff = as.data.frame(df) %&gt;% 
  mutate(gray = 0.299*Red+0.587*Green+0.114*Blue) %&gt;% 
  gather(c(1:(3+length(index)),15), key = &quot;index&quot;, value = &quot;value&quot; ) %&gt;%
  filter(!is.na(value),
         !is.infinite(value)) %&gt;% 
  group_by(index) %&gt;% 
  dplyr::summarise(mean = mean(value, na.rm = T),
            std = sd(value),
            Q25 = quantile(value,0.25),
            Q50 = quantile(value,0.50),
            Q75 = quantile(value,0.75)) %&gt;% 
  mutate(leaf = pics[i])


box = box %&gt;% 
  bind_rows(dff)}
length(unique(box$leaf))
write.table(box,&quot;data/indexes_WLB.txt&quot;)</code></pre>
<pre class="r"><code>box = read.table(&quot;data/indexes_WLB.txt&quot;)</code></pre>
</div>
<div id="load-severity-data" class="section level1">
<h1>Load severity data</h1>
<pre class="r"><code># sev_data = gsheet2tbl(&quot;https://docs.google.com/spreadsheets/d/106sg_O8DeALZpWnxERQNgk8UKgsFbhobWwrl4JXOzbo/edit#gid=0&quot;)


sev = gsheet2tbl(&quot;https://docs.google.com/spreadsheets/d/106sg_O8DeALZpWnxERQNgk8UKgsFbhobWwrl4JXOzbo/edit#gid=0&quot;)
# sev


blast_data = gsheet2tbl(&quot;https://docs.google.com/spreadsheets/d/1KnJ9N8jqKPMjCt8jCLv7OqYL9hLyYeK8wkGEBmlGSVI/edit?usp=sharing&quot;) %&gt;% 
  dplyr::select(code, city, region, position_wheat, host,species)
# blast_data

sev_data = full_join(sev, blast_data, by = &quot;code&quot;) %&gt;% 
  mutate(n = seq(1:1123)) %&gt;% 
  filter(n&lt;201) %&gt;% 
  dplyr::select(-n) %&gt;% 
  
  dplyr::select(pic_name, sev)
# sev_data


length(unique(sev$pic_name))</code></pre>
<pre><code>## [1] 200</code></pre>
<pre class="r"><code>all_data = box %&gt;%
  separate(leaf, into = c(&quot;pic_name&quot;, &quot;jpg&quot;), sep = &quot;.jpg&quot;) %&gt;%
  # separate(pic_name, into = c(&quot;hh&quot;, &quot;isolate&quot;,&quot;repp&quot;), sep = &quot;_&quot;, remove = F) %&gt;%
  dplyr::select(-jpg) %&gt;% 
  full_join(sev_data) %&gt;% 
  # filter(sev&gt;0) %&gt;% 
  mutate(sev = case_when(sev==0 ~0.01,
                         sev &gt;0 ~sev)) %&gt;% 
  filter(!is.na(index)) %&gt;% 
  mutate(sev = sev)</code></pre>
<pre><code>## Joining, by = &quot;pic_name&quot;</code></pre>
<pre class="r"><code>length(unique(all_data$pic_name))</code></pre>
<pre><code>## [1] 200</code></pre>
<pre class="r"><code># length(unique(box$leaf))</code></pre>
<pre class="r"><code>summary(sev$sev)</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##  0.0000  0.6375 49.6250 44.0737 76.0050 99.9300</code></pre>
<div id="images" class="section level3">
<h3>Images</h3>
<pre class="r"><code>hist_sev_WLB =  sev %&gt;% 
  ggplot(aes(sev))+
  geom_histogram(color = &quot;white&quot;, fill = &quot;black&quot;, bins = 20)+
  theme_minimal_hgrid(font_size = 10)+
  labs(x = &quot;Severity (%)&quot;,
       y = &quot;Frequency&quot;)+
  scale_x_continuous(limits = c(-5,105), breaks = seq(0,100,25))+
  # theme_void()+
  # coord_fixed()+
  theme(panel.background = element_rect(color = &quot;black&quot;),
        axis.title.y = element_text(size=8))
hist_sev_WLB</code></pre>
<pre><code>## Warning: Removed 2 rows containing missing values (geom_bar).</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-18-1.png" width="672" /></p>
<pre class="r"><code>EX.L1&lt;-stack(paste(&quot;./pics/01-Wheat_leaf_blast/&quot;,&quot;G_758_R2.jpg&quot;,sep = &quot;&quot;))
EX.L1&lt;-aggregate(EX.L1, fact=10)
EX.L.Shape&lt;-fieldPolygon(mosaic=EX.L1, extent=T, plot = F)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;</code></pre>
<pre class="r"><code>EX1.Indices&lt;- fieldIndex(mosaic = EX.L1,
                         index = index, 
                         myIndex = c(&quot;Green&quot;), plot = F)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;</code></pre>
<pre class="r"><code>EX.L2&lt;-fieldMask(mosaic=EX.L1,  myIndex = c(&quot;Blue&quot;), cropValue=180, cropAbove=T, plot = F)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;
## [1] &quot;Mask equation myIndex=Blue&quot;</code></pre>
<pre class="r"><code>cut = mask(EX.L1, EX.L2$newMosaic)
EX.L4&lt;-fieldIndex(mosaic=cut,
                  index =index,
                  plot =F)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;</code></pre>
<pre class="r"><code># plot(EX.L4$NGRDI)</code></pre>
<pre class="r"><code>rgb_fig_wlb = RStoolbox::ggRGB(EX.L2$newMosaic,
                 r = 1,
                 g = 2,
                 b = 3)+
  theme_map()+
  coord_fixed()+
  theme(panel.background = element_rect(color = &quot;white&quot;))</code></pre>
<pre><code>## Coordinate system already present. Adding new coordinate system, which will replace the existing one.</code></pre>
<pre class="r"><code>gli_fig_wlb = as.data.frame(EX.L4$VARI, xy=TRUE, na.rm =T) %&gt;% 
  ggplot(aes(x, y, fill = VARI))+
  geom_tile()+
  scale_fill_viridis_c(option = &quot;B&quot;,direction = -1)+
  theme_map()+
  coord_fixed()+
  theme(panel.background = element_rect(color = &quot;white&quot;),
        legend.title = element_text(size = 8),
        legend.text = element_text(size = 8))</code></pre>
<pre class="r"><code># plot_grid(rgb_fig, gli_fig, axis = &quot;b&quot;,
#           rel_widths = c(0.9,1),
#           labels = c(&quot;RGB&quot;, &quot;NGRDI&quot;),
#           scale = 0.90)

rgb_fig_wlb + gli_fig_wlb + hist_sev_WLB</code></pre>
<pre><code>## Warning: Removed 2 rows containing missing values (geom_bar).</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-21-1.png" width="672" /></p>
<pre class="r"><code># ggsave(&quot;figs/leaf_gli_wlb.png&quot;,dpi = 600, height = 4, width =12)</code></pre>
</div>
<div id="relationship-sev-indices" class="section level3">
<h3>Relationship sev indices</h3>
<pre class="r"><code>rgb_gg = all_data %&gt;% 
  filter(index %in% c(&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;)) %&gt;% 
    ggplot(aes(mean, sev, color = index)) + 
  # geom_text()+
  geom_point(color = &quot;gray&quot;, size  =3)+
  geom_smooth(se = F, size = 2)+
  facet_wrap(~index, scales = &quot;free_x&quot;, nrow =1)+
  scale_color_manual(values = c(&quot;steelblue&quot;,&quot;darkgreen&quot;, &quot;darkred&quot;))+
  theme_minimal_hgrid()+
  labs(x = &quot;Mean value in the image&quot;,
       y = &quot;Disease severity (%)&quot;)+
  theme(panel.border = element_rect(color = &quot;gray&quot;))+
  theme(legend.position = &quot;none&quot;)
rgb_gg</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-22-1.png" width="672" /></p>
<pre class="r"><code>index_gg = all_data %&gt;% 
  filter(!index %in% c(&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;)) %&gt;% 
    ggplot(aes(mean, sev)) + 
  # geom_text()+
  geom_point(color = &quot;gray&quot;, size  =3)+
  geom_smooth(color = &quot;black&quot;, se = F, size = 2)+
  facet_wrap(~index, scales = &quot;free_x&quot;, nrow =2)+
  theme_minimal_hgrid()+
  labs(x = &quot;Mean index value in the image&quot;,
       y = &quot;Disease severity (%)&quot;)+
  theme(panel.border = element_rect(color = &quot;gray&quot;))
index_gg</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-23-1.png" width="672" /></p>
<pre class="r"><code>plot_grid(
  plot_grid(NULL,rgb_gg,NULL, rel_widths =c(0.18,1,0.2), nrow = 1),
          index_gg,
          nrow = 2,
          rel_heights = c(0.5,1))</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;
## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-24-1.png" width="672" /></p>
<pre class="r"><code>ggsave(&quot;figs/index_sev_WLB.png&quot;, dpi = 500, height = 8, width = 10)</code></pre>
<pre class="r"><code>cor_wlb = all_data %&gt;% 
  group_by(index) %&gt;% 
  dplyr::summarise(cor = round(  cor.test(mean,sev, method = &quot;spearman&quot;)$estimate,3),
                   P_value = cor.test(mean,sev, method = &quot;spearman&quot;)$p.value) %&gt;% 
  arrange(-cor)</code></pre>
<pre><code>## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties</code></pre>
<pre><code>## `summarise()` ungrouping output (override with `.groups` argument)</code></pre>
<pre class="r"><code>cor_wlb</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["index"],"name":[1],"type":["chr"],"align":["left"]},{"label":["cor"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["P_value"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"SCI","2":"0.867","3":"1.135116e-61"},{"1":"HI","2":"0.823","3":"1.704811e-50"},{"1":"Blue","2":"0.822","3":"2.697964e-50"},{"1":"HUE","2":"0.752","3":"9.442985e-38"},{"1":"Red","2":"0.666","3":"5.109759e-27"},{"1":"BI","2":"0.643","3":"1.121893e-24"},{"1":"gray","2":"0.590","3":"4.157148e-20"},{"1":"BGI","2":"0.475","3":"1.217604e-12"},{"1":"Green","2":"0.436","3":"1.069223e-10"},{"1":"SI","2":"0.382","3":"2.333742e-08"},{"1":"NGRDI","2":"-0.867","3":"1.135116e-61"},{"1":"VARI","2":"-0.870","3":"1.058165e-62"},{"1":"GLI","2":"-0.886","3":"4.527714e-68"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
</div>
<div id="spread" class="section level3">
<h3>Spread</h3>
<pre class="r"><code>all_data_spread_wlb = all_data %&gt;% 
  # mutate(nn=1:length(all_data$pic_name)) %&gt;% 
  pivot_wider(id_col = c(pic_name,sev),
              names_from = index, 
              values_from =  mean)   
head(all_data_spread_wlb)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["pic_name"],"name":[1],"type":["chr"],"align":["left"]},{"label":["sev"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["BGI"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["BI"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["Blue"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["GLI"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["gray"],"name":[7],"type":["dbl"],"align":["right"]},{"label":["Green"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["HI"],"name":[9],"type":["dbl"],"align":["right"]},{"label":["HUE"],"name":[10],"type":["dbl"],"align":["right"]},{"label":["NGRDI"],"name":[11],"type":["dbl"],"align":["right"]},{"label":["Red"],"name":[12],"type":["dbl"],"align":["right"]},{"label":["SCI"],"name":[13],"type":["dbl"],"align":["right"]},{"label":["SI"],"name":[14],"type":["dbl"],"align":["right"]},{"label":["VARI"],"name":[15],"type":["dbl"],"align":["right"]}],"data":[{"1":"G_108_R1","2":"0.20","3":"0.5353055","4":"107.27243","5":"71.72010","6":"0.1933751","7":"117.7501","8":"130.9462","9":"0.21822025","10":"-1.564933","11":"0.09695804","12":"109.39336","13":"-0.09695804","14":"0.2245992","15":"0.1360881"},{"1":"G_108_R2","2":"0.90","3":"0.6463659","4":"103.24035","5":"79.22453","6":"0.1478204","7":"111.6613","8":"122.1817","9":"0.04594559","10":"-1.502459","11":"0.08723410","12":"103.37453","13":"-0.08723410","14":"0.1319861","15":"0.1347354"},{"1":"G_108_R3","2":"0.28","3":"0.6777565","4":"99.33399","5":"79.35054","6":"0.1370868","7":"106.8201","8":"116.4214","9":"-0.09201103","10":"-1.550948","11":"0.08584901","12":"98.44382","13":"-0.08584901","14":"0.1101819","15":"0.1351493"},{"1":"G_108_R4","2":"0.14","3":"0.6489964","4":"103.63470","5":"79.83507","6":"0.1478598","7":"112.1051","8":"122.8038","9":"-0.04995640","10":"-1.562913","11":"0.08848845","12":"103.40509","13":"-0.08848845","14":"0.1290937","15":"0.1365299"},{"1":"G_110_R1","2":"0.19","3":"0.6512916","4":"102.44060","5":"79.28427","6":"0.1481314","7":"110.7991","8":"121.5047","9":"0.07295235","10":"-1.562977","11":"0.09026344","12":"101.79740","13":"-0.09026344","14":"0.1257136","15":"0.1396284"},{"1":"G_110_R2","2":"0.21","3":"0.6375932","4":"104.02830","5":"79.05746","6":"0.1505972","7":"112.7063","8":"123.5010","9":"0.06658159","10":"-1.562526","11":"0.08669032","12":"104.34316","13":"-0.08669032","14":"0.1396295","15":"0.1325084"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
</div>
<div id="gbm" class="section level2">
<h2>GBM</h2>
<pre class="r"><code>train=sample(x = 1:length(all_data_spread_wlb$sev), 
             size = round(0.75*length(all_data_spread_wlb$sev),1))
# length(train)
gbm.fit = gbm(sev ~BGI+BI+GLI+HI+HUE+NGRDI+VARI+gray+ Red+Green+Blue  + SI + SCI,
             data = all_data_spread_wlb[train,],
             distribution = &quot;gaussian&quot;,
              n.trees = 1000,
             interaction.depth = 3,
             shrinkage = 0.1,
             cv.folds = 5,
             n.cores = NULL, # will use all cores by default
             verbose = FALSE)
print(gbm.fit)</code></pre>
<pre><code>## gbm(formula = sev ~ BGI + BI + GLI + HI + HUE + NGRDI + VARI + 
##     gray + Red + Green + Blue + SI + SCI, distribution = &quot;gaussian&quot;, 
##     data = all_data_spread_wlb[train, ], n.trees = 1000, interaction.depth = 3, 
##     shrinkage = 0.1, cv.folds = 5, verbose = FALSE, n.cores = NULL)
## A gradient boosted model with gaussian loss function.
## 1000 iterations were performed.
## The best cross-validation iteration was 83.
## There were 13 predictors of which 13 had non-zero influence.</code></pre>
<pre class="r"><code>sqrt(min(gbm.fit$cv.error))</code></pre>
<pre><code>## [1] 10.09527</code></pre>
<pre class="r"><code>gbm.perf(gbm.fit, method = &quot;cv&quot;)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-28-1.png" width="672" /></p>
<pre><code>## [1] 83</code></pre>
<pre class="r"><code># find index for n trees with minimum CV error</code></pre>
<pre class="r"><code>min_MSE &lt;- which.min(gbm.fit$cv.error)
sqrt(gbm.fit$cv.error[min_MSE])</code></pre>
<pre><code>## [1] 10.09527</code></pre>
<pre class="r"><code># best.iter &lt;- gbm.perf(model1, method = &quot;test&quot;)
# print(best.iter)

pred = predict(gbm.fit, newdata = all_data_spread_wlb[-train,-1], ntrees = 5000 )</code></pre>
<pre><code>## Using 83 trees...</code></pre>
<pre class="r"><code>sqrt(mean(((pred)-all_data_spread_wlb$sev[-train])^2))</code></pre>
<pre><code>## [1] 10.26461</code></pre>
<pre class="r"><code>CCC((pred), all_data_spread_wlb$sev[-train])$rho.c$est</code></pre>
<pre><code>## [1] 0.952772</code></pre>
<pre class="r"><code>plot((pred), (pred)-all_data_spread_wlb$sev[-train])
abline(a=0,b=0)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-30-1.png" width="672" /></p>
<div id="testing-various-hyperparameters" class="section level3">
<h3>Testing various hyperparameters</h3>
<p>Create hyperparameter grid</p>
<pre class="r"><code>hyper_grid &lt;- expand.grid(
  shrinkage = c(.001, .01, .1, .3),
  interaction.depth = c(1, 3, 5, 6),
  n.minobsinnode = c(5, 10, 15),
  bag.fraction = c(.5,.65, .8, 1), 
  optimal_trees = 0,               # a place to dump results
  min_RMSE = 0,
  CCC =0 # a place to dump results
)
# total number of combinations
nrow(hyper_grid)</code></pre>
<pre><code>## [1] 192</code></pre>
<pre class="r"><code># randomize data
set.seed(1234)
train=sample(x = 1:length(all_data_spread_wlb$sev), 
             size = round(0.80*length(all_data_spread_wlb$sev),1))

# grid search 
for(i in 1:nrow(hyper_grid)) {

# reproducibility
set.seed(123)


 # train model
gbm.tune &lt;- gbm(
  formula = (sev) ~BGI+BI+GLI+HI+HUE+NGRDI+VARI+gray +Red+Green+Blue + SI + SCI, #&lt;&lt;&lt;&lt;&lt;
  data = all_data_spread_wlb[train,],
  distribution = &quot;gaussian&quot;,
  n.trees = 5000,
  interaction.depth = hyper_grid$interaction.depth[i],
  shrinkage = hyper_grid$shrinkage[i],
  n.minobsinnode = hyper_grid$n.minobsinnode[i],
  bag.fraction = hyper_grid$bag.fraction[i],
  train.fraction = .75,
  n.cores = NULL, # will use all cores by default
  verbose = FALSE)

pred = predict(gbm.tune, newdata = all_data_spread_wlb[-train,-1], ntrees = 5000 )
 # add min training error and trees to grid
  hyper_grid$optimal_trees[i] &lt;- which.min(gbm.tune$valid.error)
  hyper_grid$min_RMSE[i] &lt;- sqrt(min(gbm.tune$valid.error))
  hyper_grid$CCC[i] = CCC(pred, all_data_spread_wlb$sev[-train])$rho.c$est#&lt;&lt;&lt;&lt;&lt;
  
}

best_par = hyper_grid %&gt;% 
  dplyr::arrange(-CCC) %&gt;%
  head(10)
best_par</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["shrinkage"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["interaction.depth"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["n.minobsinnode"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["bag.fraction"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["optimal_trees"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["min_RMSE"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["CCC"],"name":[7],"type":["dbl"],"align":["right"]}],"data":[{"1":"0.01","2":"5","3":"5","4":"0.80","5":"4988","6":"10.83493","7":"0.9731869","_rn_":"1"},{"1":"0.10","2":"5","3":"5","4":"0.50","5":"36","6":"10.88780","7":"0.9730593","_rn_":"2"},{"1":"0.30","2":"5","3":"5","4":"0.50","5":"19","6":"11.04311","7":"0.9729481","_rn_":"3"},{"1":"0.01","2":"6","3":"5","4":"0.80","5":"5000","6":"10.70554","7":"0.9722267","_rn_":"4"},{"1":"0.30","2":"3","3":"10","4":"0.80","5":"11","6":"10.84073","7":"0.9716871","_rn_":"5"},{"1":"0.01","2":"6","3":"5","4":"0.50","5":"331","6":"10.34085","7":"0.9716634","_rn_":"6"},{"1":"0.01","2":"5","3":"5","4":"0.65","5":"5000","6":"10.62293","7":"0.9713993","_rn_":"7"},{"1":"0.01","2":"6","3":"5","4":"0.65","5":"4970","6":"10.52067","7":"0.9713708","_rn_":"8"},{"1":"0.10","2":"5","3":"10","4":"0.80","5":"4985","6":"10.54148","7":"0.9711163","_rn_":"9"},{"1":"0.30","2":"5","3":"10","4":"1.00","5":"10","6":"11.28268","7":"0.9709846","_rn_":"10"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code># gbm.tune$fit</code></pre>
</div>
<div id="best-model" class="section level3">
<h3>Best model</h3>
<pre class="r"><code># for reproducibility
set.seed(123)

# train GBM model
gbm.fit.final_wlb &lt;- gbm(
  formula = (sev) ~BGI+BI+GLI+HI+HUE+NGRDI+VARI+Red+Green+Blue+gray+SI+SCI,
  data = all_data_spread_wlb[train,],
  distribution = &quot;gaussian&quot;,
  n.trees = best_par$optimal_trees[1],
  interaction.depth = best_par$interaction.depth[1],
  shrinkage = best_par$shrinkage[1],
  n.minobsinnode = best_par$n.minobsinnode[1],
  bag.fraction = best_par$bag.fraction[1], 
  train.fraction =0.75,
  n.cores = NULL, # will use all cores by default
  verbose = FALSE
  )</code></pre>
</div>
<div id="relative-influence" class="section level3">
<h3>Relative influence</h3>
<pre class="r"><code>par(mar = c(5, 8, 1, 1))
summary_gbm_wlb = summary(
  gbm.fit.final_wlb, 
  cBars = 15,
  method = relative.influence, # also can use permutation.test.gbm
  las = 2
  )</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-34-1.png" width="672" /></p>
<pre class="r"><code>rel_wlb = summary_gbm_wlb %&gt;% 
  rownames_to_column(&quot;index&quot;) %&gt;% 
  ggplot(aes(rel.inf, reorder(var, rel.inf)))+
  geom_col(aes(fill =rel.inf&gt;1, color =rel.inf&gt;1 ), width = 0.85)+
  theme_minimal_vgrid()+
  labs(x = &quot;Relative influence (%)&quot;,
       y = &quot;Model predictors&quot;,
       fill = &quot;RI &gt; 1%&quot;,
       color = &quot;RI &gt; 1%&quot;)
rel_wlb</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-34-2.png" width="672" /></p>
<pre class="r"><code># ggsave(&quot;figs/var_influence.png&quot;,dpi = 600, height = 4, width = 6)</code></pre>
<p>Partial dependence plots</p>
<pre class="r"><code>gbm.fit.final_wlb %&gt;%
  pdp::partial(pred.var = &quot;NGRDI&quot;, n.trees = gbm.fit.final_wlb$n.trees, grid.resolution = 100) %&gt;%
  ggplot(aes( NGRDI,(yhat)))+
  geom_line()</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-35-1.png" width="672" /></p>
<p>LIME</p>
<pre class="r"><code>model_type.gbm &lt;- function(x, ...) {
  return(&quot;regression&quot;)
}

predict_model.gbm &lt;- function(x, newdata, ...) {
  pred &lt;- predict(x, newdata, n.trees = x$n.trees)
  return(as.data.frame(pred))
}</code></pre>
<pre class="r"><code># get a few observations to perform local interpretation on
local_obs &lt;- (all_data_spread_wlb[-train,])[1:4, ]

# apply LIME
explainer &lt;- lime(all_data_spread_wlb[train,], gbm.fit.final_wlb)
explanation &lt;- lime::explain(local_obs, explainer, n_features = 7, n.trees =1)
plot_features(explanation)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-37-1.png" width="672" /></p>
</div>
</div>
<div id="prediction" class="section level2">
<h2>Prediction</h2>
<pre class="r"><code># predict values for test data
pred &lt;- predict(gbm.fit.final_wlb,
                n.trees = gbm.fit.final_wlb$n.trees,
                all_data_spread_wlb[-train,])

# results
caret::RMSE((pred), all_data_spread_wlb[-train,]$sev)</code></pre>
<pre><code>## [1] 7.852842</code></pre>
<pre class="r"><code>CCC((pred), all_data_spread_wlb$sev[-train])$rho.c$est</code></pre>
<pre><code>## [1] 0.9733397</code></pre>
<pre class="r"><code>cor((pred), all_data_spread_wlb$sev[-train])^2</code></pre>
<pre><code>## [1] 0.9491022</code></pre>
<pre class="r"><code>accuracy_wlb =data.frame(predi=pred, actual = all_data_spread_wlb$sev[-train]) %&gt;% 
  summarise(RMSE = caret::RMSE(pred, actual),
            r = cor(pred, actual),
            s.shift = CCC(pred, actual)$s.shift,
            l.shift = CCC(pred, actual)$l.shift,
            C.b = CCC(pred, actual)$C.b,
            CCC = CCC(pred, actual)$rho.c$est,
            CIS = paste(
  round(CCC(pred, all_data_spread_wlb$sev[-train])$rho.c[2],2),&quot;,&quot;,&quot; &quot;,
  round(CCC(pred, all_data_spread_wlb$sev[-train])$rho.c[3],2),sep = &quot;&quot;
  ))
accuracy_wlb</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["RMSE"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["r"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["s.shift"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["l.shift"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["C.b"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["CCC"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["CIS"],"name":[7],"type":["chr"],"align":["left"]}],"data":[{"1":"7.852842","2":"0.9742187","3":"1.030742","4":"0.02982214","5":"0.9990977","6":"0.9733397","7":"0.95, 0.99"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<div id="plot" class="section level4">
<h4>plot</h4>
<pre class="r"><code># plot_grid(
conc_wlb = data.frame(predict = pred, actual =all_data_spread_wlb$sev[-train]) %&gt;% 
ggplot(aes(actual,predict))+
  geom_point(size =2, color = &quot;gray&quot;)+
  geom_abline(intercept = 0, slope= 1, size = .81, color = &quot;black&quot;, linetype = &quot;dashed&quot;)+
  geom_smooth(method = &quot;lm&quot;, 
              color = &quot;red&quot;,
              size =.81, se =F,
              fullrange=T)+
  theme_minimal_grid()+
  labs(x = &quot;Predicted Severity (%)&quot;,
       y = &quot;Actual Severity (%)&quot;)+
  coord_equal(xlim = c(0,100),
              ylim = c(0,100))+
  xlim(0,100)

ggsave(&quot;figs/concordance.png&quot;, dpi = 600, height = 3.5, width = 4)</code></pre>
<pre><code>## `geom_smooth()` using formula &#39;y ~ x&#39;</code></pre>
</div>
</div>
</div>
<div id="soybean-rust" class="section level1">
<h1>Soybean Rust</h1>
<pre class="r"><code>pics&lt;-list.files(&quot;./pics/01-soybean-rust-bg-blue&quot;)
# length(pics)
#indices
index = c(&quot;BI&quot;,&quot;SCI&quot;,&quot;GLI&quot;,&quot;HI&quot;,&quot;SI&quot;,&quot;VARI&quot;,&quot;HUE&quot;,&quot;BGI&quot;,&quot;NGRDI&quot;)


box = data.frame()

for(i in 1:length(pics)){

EX.L1&lt;-stack(paste(&quot;./pics/01-soybean-rust-bg-blue/&quot;,pics[i],sep = &quot;&quot;))
EX.L1&lt;-aggregate(EX.L1, fact=7)
EX.L.Shape&lt;-fieldPolygon(mosaic=EX.L1, extent=T, plot = F)

EX1.Indices&lt;- fieldIndex(mosaic = EX.L1,
                         index = index, 
                         myIndex = c(&quot;Green&quot;), plot = F)

EX.L2&lt;-fieldMask(mosaic=EX.L1,  myIndex = c(&quot;Blue&quot;), cropValue=100, cropAbove=T, plot = F)

cut = mask(EX.L1, EX.L2$newMosaic)
EX.L4&lt;-fieldIndex(mosaic=cut,
                  index =index,
                  plot =F)


df = as(EX.L4, &quot;SpatialPixelsDataFrame&quot;)
dff = as.data.frame(df) %&gt;% 
  mutate(gray = 0.299*Red+0.587*Green+0.114*Blue) %&gt;% 
  gather(c(1:(3+length(index)),15), key = &quot;index&quot;, value = &quot;value&quot; ) %&gt;%
  filter(!is.na(value),
         !is.infinite(value)) %&gt;% 
  group_by(index) %&gt;% 
  dplyr::summarise(mean = mean(value, na.rm = T),
            std = sd(value),
            Q25 = quantile(value,0.25),
            Q50 = quantile(value,0.50),
            Q75 = quantile(value,0.75)) %&gt;% 
  mutate(leaf = pics[i])


box = box %&gt;% 
  bind_rows(dff)}
length(unique(box$leaf))
write.table(box,&quot;data/indexes_SBR.txt&quot;)</code></pre>
<pre class="r"><code>box = read.table(&quot;data/indexes_SBR.txt&quot;)</code></pre>
<div id="load-sbr-severity" class="section level3">
<h3>load SBR severity</h3>
<pre class="r"><code>sbr_load = gsheet2tbl(&quot;https://docs.google.com/spreadsheets/d/13TVKBQgfCAr7UGie_LHTF_kwPHC1XI_AkLKoRYtjPrQ/edit?usp=sharing&quot;)</code></pre>
<pre class="r"><code>all_data_sbr = box %&gt;% 
  separate(leaf, into=c(&quot;file&quot;,&quot;format&quot;), sep =&quot;_&quot;) %&gt;% 
  dplyr::select(-format) %&gt;% 
  full_join(sbr_load) %&gt;% 
  na.omit()</code></pre>
<pre><code>## Joining, by = &quot;file&quot;</code></pre>
<pre class="r"><code>length(unique(all_data_sbr$file))</code></pre>
<pre><code>## [1] 203</code></pre>
<pre class="r"><code>head(all_data_sbr)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["index"],"name":[1],"type":["chr"],"align":["left"]},{"label":["mean"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["std"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["Q25"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["Q50"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["Q75"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["file"],"name":[7],"type":["chr"],"align":["left"]},{"label":["sev"],"name":[8],"type":["dbl"],"align":["right"]}],"data":[{"1":"BGI","2":"0.3997101","3":"0.13599078","4":"0.3234259","5":"0.3843265","6":"0.4506906","7":"Ferrugem 1","8":"39.7","_rn_":"1"},{"1":"BI","2":"87.8460326","3":"14.91203193","4":"77.1221560","5":"87.0969043","6":"98.8352819","7":"Ferrugem 1","8":"39.7","_rn_":"2"},{"1":"Blue","2":"41.0937912","3":"11.80079235","4":"33.5510204","5":"40.1326531","6":"46.7959184","7":"Ferrugem 1","8":"39.7","_rn_":"3"},{"1":"GLI","2":"0.1959277","3":"0.06355385","4":"0.1562426","5":"0.1952057","6":"0.2354938","7":"Ferrugem 1","8":"39.7","_rn_":"4"},{"1":"gray","2":"96.1659570","3":"15.23897816","4":"85.5722755","5":"95.7584898","6":"107.3897857","7":"Ferrugem 1","8":"39.7","_rn_":"5"},{"1":"Green","2":"104.4390983","3":"13.30553965","4":"95.8163265","5":"104.3571429","6":"113.8163265","7":"Ferrugem 1","8":"39.7","_rn_":"6"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>summary(all_data_sbr$sev)</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##    0.04    5.52   20.10   25.11   38.07   89.67</code></pre>
</div>
<div id="images-1" class="section level3">
<h3>Images</h3>
<pre class="r"><code>hist_sev_sbr =  all_data_sbr %&gt;%
  pivot_wider(id_col = c(file,sev),
              names_from = index, 
              values_from =  mean) %&gt;%
  ggplot(aes(sev))+
  geom_histogram(color = &quot;white&quot;, fill = &quot;black&quot;, bins = 20)+
  theme_minimal_hgrid(font_size = 10)+
  labs(x = &quot;Severity (%)&quot;,
       y = &quot;Frequency&quot;)+
  scale_x_continuous(limits = c(-5,105), breaks = seq(0,100,25))+
  # theme_void()+
  # coord_fixed()+
  theme(panel.background = element_rect(color = &quot;black&quot;),
        axis.title.y = element_text(size=8))</code></pre>
<pre class="r"><code>EX.L1&lt;-stack(paste(&quot;./pics/01-soybean-rust-bg-blue/&quot;,&quot;Ferrugem 2_Median.jpg&quot;,sep = &quot;&quot;))
EX.L1&lt;-aggregate(EX.L1, fact=7)
EX.L.Shape&lt;-fieldPolygon(mosaic=EX.L1, extent=T, plot = F)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;</code></pre>
<pre class="r"><code>EX1.Indices&lt;- fieldIndex(mosaic = EX.L1,
                         index = index, 
                         myIndex = c(&quot;Green&quot;), plot = F)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;</code></pre>
<pre class="r"><code>EX.L2&lt;-fieldMask(mosaic=EX.L1,  myIndex = c(&quot;Blue&quot;), cropValue=100, cropAbove=T, plot = F)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;
## [1] &quot;Mask equation myIndex=Blue&quot;</code></pre>
<pre class="r"><code>cut = mask(EX.L1, EX.L2$newMosaic)
EX.L4&lt;-fieldIndex(mosaic=cut,
                  index =index,
                  plot =F)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;</code></pre>
<pre class="r"><code># plot(EX.L4$HUE)</code></pre>
<pre class="r"><code>rgb_fig_sbr = RStoolbox::ggRGB(EX.L2$newMosaic,
                 r = 1,
                 g = 2,
                 b = 3)+
  theme_map()+
  coord_fixed()+
  theme(panel.background = element_rect(color = &quot;white&quot;))</code></pre>
<pre><code>## Coordinate system already present. Adding new coordinate system, which will replace the existing one.</code></pre>
<pre class="r"><code>gli_fig_sbr = as.data.frame(EX.L4$HUE, xy=TRUE, na.rm =T) %&gt;% 
  ggplot(aes(x, y, fill = HUE))+
  geom_tile()+
  scale_fill_viridis_c(option = &quot;B&quot;,direction = -1)+
  theme_map()+
  coord_fixed()+
  theme(panel.background = element_rect(color = &quot;white&quot;),
        legend.title = element_text(size = 8),
        legend.text = element_text(size = 8))</code></pre>
<pre class="r"><code>rgb_fig_sbr + gli_fig_sbr + hist_sev_sbr #+</code></pre>
<pre><code>## Warning: Removed 2 rows containing missing values (geom_bar).</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-49-1.png" width="672" /></p>
<pre class="r"><code>  # rgb_fig_wlb + gli_fig_wlb + hist_sev_WLB+
  #  plot_layout(widths = c(1, 1, 1),
  #              heights = c(1,1))

# ggsave(&quot;figs/leaf_gli.png&quot;,dpi = 600, height = 6, width =10)</code></pre>
</div>
<div id="relationship-sev-indices-1" class="section level3">
<h3>Relationship sev indices</h3>
<pre class="r"><code>rgb_gg_sbr = all_data_sbr %&gt;% 
  filter(index %in% c(&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;)) %&gt;% 
    ggplot(aes(mean, sev, color = index)) + 
  # geom_text()+
  geom_point(color = &quot;gray&quot;, size  =3)+
  geom_smooth(se = F, size = 2)+
  facet_wrap(~index, scales = &quot;free_x&quot;, nrow =1)+
  scale_color_manual(values = c(&quot;steelblue&quot;,&quot;darkgreen&quot;, &quot;darkred&quot;))+
  theme_minimal_hgrid()+
  labs(x = &quot;Mean value in the image&quot;,
       y = &quot;Disease severity (%)&quot;)+
  theme(panel.border = element_rect(color = &quot;gray&quot;))+
  theme(legend.position = &quot;none&quot;)
rgb_gg_sbr</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-50-1.png" width="672" /></p>
<pre class="r"><code>index_gg_sbr = all_data_sbr %&gt;% 
  filter(!index %in% c(&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;)) %&gt;% 
    ggplot(aes(mean, sev)) + 
  # geom_text()+
  geom_point(color = &quot;gray&quot;, size  =3)+
  geom_smooth(color = &quot;black&quot;, se = F, size = 2)+
  facet_wrap(~index, scales = &quot;free_x&quot;, nrow =2)+
  theme_minimal_hgrid()+
  labs(x = &quot;Mean index value in the image&quot;,
       y = &quot;Disease severity (%)&quot;)+
  theme(panel.border = element_rect(color = &quot;gray&quot;))
index_gg_sbr</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-51-1.png" width="672" /></p>
<pre class="r"><code>plot_grid(
  plot_grid(NULL,rgb_gg_sbr,NULL, rel_widths =c(0.18,1,0.2), nrow = 1),
          index_gg_sbr,
          nrow = 2,
          rel_heights = c(0.5,1))</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;
## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-52-1.png" width="672" /></p>
<pre class="r"><code>ggsave(&quot;figs/index_sev_SBR.png&quot;, dpi = 500, height = 8, width = 10)</code></pre>
<pre class="r"><code>cor_sbr = all_data_sbr %&gt;% 
  group_by(index) %&gt;% 
  dplyr::summarise(cor = round(  cor.test(mean,sev, method = &quot;spearman&quot;)$estimate,3),
                   P_value = cor.test(mean,sev, method = &quot;spearman&quot;)$p.value) %&gt;% 
  arrange(-cor)</code></pre>
<pre><code>## `summarise()` ungrouping output (override with `.groups` argument)</code></pre>
<pre class="r"><code>cor_sbr</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["index"],"name":[1],"type":["chr"],"align":["left"]},{"label":["cor"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["P_value"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"HUE","2":"0.995","3":"0.000000e+00"},{"1":"SCI","2":"0.946","3":"0.000000e+00"},{"1":"HI","2":"0.906","3":"0.000000e+00"},{"1":"Red","2":"0.848","3":"0.000000e+00"},{"1":"SI","2":"0.823","3":"0.000000e+00"},{"1":"BI","2":"0.745","3":"0.000000e+00"},{"1":"gray","2":"0.710","3":"0.000000e+00"},{"1":"Green","2":"0.582","3":"0.000000e+00"},{"1":"Blue","2":"-0.383","3":"2.262575e-08"},{"1":"GLI","2":"-0.462","3":"3.933944e-12"},{"1":"BGI","2":"-0.617","3":"0.000000e+00"},{"1":"VARI","2":"-0.880","3":"0.000000e+00"},{"1":"NGRDI","2":"-0.946","3":"0.000000e+00"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
</div>
<div id="spread-df" class="section level3">
<h3>Spread df</h3>
<pre class="r"><code>all_data_spread_sbr = all_data_sbr %&gt;% 
  pivot_wider(id_col = c(file,sev),
              names_from = index, 
              values_from =  mean)   

head(all_data_spread_sbr)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["file"],"name":[1],"type":["chr"],"align":["left"]},{"label":["sev"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["BGI"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["BI"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["Blue"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["GLI"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["gray"],"name":[7],"type":["dbl"],"align":["right"]},{"label":["Green"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["HI"],"name":[9],"type":["dbl"],"align":["right"]},{"label":["HUE"],"name":[10],"type":["dbl"],"align":["right"]},{"label":["NGRDI"],"name":[11],"type":["dbl"],"align":["right"]},{"label":["Red"],"name":[12],"type":["dbl"],"align":["right"]},{"label":["SCI"],"name":[13],"type":["dbl"],"align":["right"]},{"label":["SI"],"name":[14],"type":["dbl"],"align":["right"]},{"label":["VARI"],"name":[15],"type":["dbl"],"align":["right"]}],"data":[{"1":"Ferrugem 1","2":"39.70","3":"0.3997101","4":"87.84603","5":"41.09379","6":"0.1959277","7":"96.16596","8":"104.43910","9":"0.6625815","10":"-0.2631971","11":"0.03199372","12":"100.92145","13":"-0.03199372","14":"0.4087857","15":"0.06058750"},{"1":"Ferrugem 10","2":"18.65","3":"0.3792543","4":"84.67287","5":"39.67250","6":"0.2309887","7":"93.99306","8":"105.07461","9":"0.5650574","10":"-0.9527573","11":"0.07109084","12":"92.94849","13":"-0.07109084","14":"0.3981594","15":"0.08849056"},{"1":"Ferrugem 100","2":"26.42","3":"0.5029008","4":"90.31850","5":"53.11091","6":"0.1645689","7":"98.71033","8":"106.72750","9":"0.7463635","10":"-0.6678290","11":"0.03718950","12":"100.35668","13":"-0.03718950","14":"0.2997770","15":"0.04482838"},{"1":"Ferrugem 101","2":"2.33","3":"0.5544438","4":"81.18729","5":"55.13729","6":"0.1862898","7":"89.32461","8":"99.69538","9":"0.2040970","10":"-1.5024190","11":"0.10080088","12":"81.99923","13":"-0.10080088","14":"0.1934977","15":"0.14616311"},{"1":"Ferrugem 102","2":"84.66","3":"0.4337219","4":"113.19410","5":"51.81495","6":"0.1155914","7":"120.83483","8":"123.23074","9":"1.6212932","10":"1.2253308","11":"-0.07125433","12":"142.44643","13":"0.07125433","14":"0.4616619","15":"-0.07777495"},{"1":"Ferrugem 103","2":"4.08","3":"0.5046375","4":"89.30674","5":"55.46616","6":"0.1960571","7":"98.73415","8":"110.07443","9":"0.3192319","10":"-1.4277268","11":"0.08764355","12":"92.96763","13":"-0.08764355","14":"0.2507094","15":"0.12807067"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
</div>
<div id="gbm-1" class="section level2">
<h2>GBM</h2>
<pre class="r"><code>train=sample(x = 1:length(all_data_spread_sbr$sev), 
             size = round(0.75*length(all_data_spread_sbr$sev),1))
# length(train)
gbm.fit = gbm(sev ~BGI+BI+GLI+HI+HUE+NGRDI+VARI+gray+ Red+Green+Blue  + SI + SCI,
             data = all_data_spread_sbr[train,],
             distribution = &quot;gaussian&quot;,
              n.trees = 1000,
             interaction.depth = 3,
             shrinkage = 0.1,
             cv.folds = 5,
             n.cores = NULL, # will use all cores by default
             verbose = FALSE)
print(gbm.fit)</code></pre>
<pre><code>## gbm(formula = sev ~ BGI + BI + GLI + HI + HUE + NGRDI + VARI + 
##     gray + Red + Green + Blue + SI + SCI, distribution = &quot;gaussian&quot;, 
##     data = all_data_spread_sbr[train, ], n.trees = 1000, interaction.depth = 3, 
##     shrinkage = 0.1, cv.folds = 5, verbose = FALSE, n.cores = NULL)
## A gradient boosted model with gaussian loss function.
## 1000 iterations were performed.
## The best cross-validation iteration was 942.
## There were 13 predictors of which 13 had non-zero influence.</code></pre>
<pre class="r"><code>sqrt(min(gbm.fit$cv.error))</code></pre>
<pre><code>## [1] 4.02846</code></pre>
<pre class="r"><code>gbm.perf(gbm.fit, method = &quot;cv&quot;)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-56-1.png" width="672" /></p>
<pre><code>## [1] 942</code></pre>
<pre class="r"><code># find index for n trees with minimum CV error</code></pre>
<pre class="r"><code>min_MSE &lt;- which.min(gbm.fit$cv.error)
sqrt(gbm.fit$cv.error[min_MSE])</code></pre>
<pre><code>## [1] 4.02846</code></pre>
<pre class="r"><code># best.iter &lt;- gbm.perf(model1, method = &quot;test&quot;)
# print(best.iter)

pred = predict(gbm.fit, newdata = all_data_spread_sbr[-train,-1], ntrees = 5000 )</code></pre>
<pre><code>## Using 942 trees...</code></pre>
<pre class="r"><code>sqrt(mean(((pred)-all_data_spread_sbr$sev[-train])^2))</code></pre>
<pre><code>## [1] 3.398297</code></pre>
<pre class="r"><code>CCC((pred), all_data_spread_sbr$sev[-train])$rho.c$est</code></pre>
<pre><code>## [1] 0.9897837</code></pre>
<pre class="r"><code>plot((pred), (pred)-all_data_spread_sbr$sev[-train])
abline(a=0,b=0)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-58-1.png" width="672" /></p>
<div id="testing-various-hyperparameters-1" class="section level3">
<h3>Testing various hyperparameters</h3>
<p>Create hyperparameter grid</p>
<pre class="r"><code>hyper_grid &lt;- expand.grid(
  shrinkage = c(.001, .01, .1, .3),
  interaction.depth = c(1, 3, 5, 6),
  n.minobsinnode = c(5, 10, 15),
  bag.fraction = c(.5,.65, .8, 1), 
  optimal_trees = 0,               # a place to dump results
  min_RMSE = 0,
  CCC =0 # a place to dump results
)
# total number of combinations
nrow(hyper_grid)</code></pre>
<pre><code>## [1] 192</code></pre>
<pre class="r"><code># randomize data
set.seed(123)
train=sample(x = 1:length(all_data_spread_sbr$sev), 
             size = round(0.8*length(all_data_spread_sbr$sev),1))

# grid search 
for(i in 1:nrow(hyper_grid)) {

# reproducibility
set.seed(123)


 # train model
gbm.tune &lt;- gbm(
  formula = (sev) ~BGI+BI+GLI+HI+HUE+NGRDI+VARI+gray +Red+Green+Blue + SI + SCI, #&lt;&lt;&lt;&lt;&lt;
  data = all_data_spread_sbr[train,],
  distribution = &quot;gaussian&quot;,
  n.trees = 5000,
  interaction.depth = hyper_grid$interaction.depth[i],
  shrinkage = hyper_grid$shrinkage[i],
  n.minobsinnode = hyper_grid$n.minobsinnode[i],
  bag.fraction = hyper_grid$bag.fraction[i],
  train.fraction = .75,
  n.cores = NULL, # will use all cores by default
  verbose = FALSE)

pred = predict(gbm.tune, newdata = all_data_spread_sbr[-train,-1], ntrees = 5000 )
 # add min training error and trees to grid
  hyper_grid$optimal_trees[i] &lt;- which.min(gbm.tune$valid.error)
  hyper_grid$min_RMSE[i] &lt;- sqrt(min(gbm.tune$valid.error))
  hyper_grid$CCC[i] = CCC(pred, all_data_spread_sbr$sev[-train])$rho.c$est#&lt;&lt;&lt;&lt;&lt;
  
}

best_par = hyper_grid %&gt;% 
  dplyr::arrange(-CCC) %&gt;%
  head(10)
best_par</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["shrinkage"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["interaction.depth"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["n.minobsinnode"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["bag.fraction"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["optimal_trees"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["min_RMSE"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["CCC"],"name":[7],"type":["dbl"],"align":["right"]}],"data":[{"1":"0.010","2":"3","3":"5","4":"0.80","5":"1148","6":"2.270680","7":"0.9958594","_rn_":"1"},{"1":"0.010","2":"5","3":"5","4":"1.00","5":"1109","6":"2.002059","7":"0.9956714","_rn_":"2"},{"1":"0.100","2":"6","3":"5","4":"1.00","5":"97","6":"1.975201","7":"0.9955144","_rn_":"3"},{"1":"0.100","2":"5","3":"5","4":"1.00","5":"93","6":"2.055946","7":"0.9955131","_rn_":"4"},{"1":"0.010","2":"3","3":"5","4":"1.00","5":"4600","6":"2.157053","7":"0.9955040","_rn_":"5"},{"1":"0.010","2":"1","3":"5","4":"0.80","5":"1601","6":"2.266556","7":"0.9954981","_rn_":"6"},{"1":"0.010","2":"1","3":"5","4":"0.65","5":"1650","6":"2.375012","7":"0.9954573","_rn_":"7"},{"1":"0.001","2":"3","3":"5","4":"0.65","5":"4995","6":"2.488595","7":"0.9954234","_rn_":"8"},{"1":"0.010","2":"6","3":"5","4":"0.80","5":"1161","6":"2.073971","7":"0.9953818","_rn_":"9"},{"1":"0.001","2":"3","3":"5","4":"0.80","5":"5000","6":"2.302626","7":"0.9953742","_rn_":"10"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code># gbm.tune$fit</code></pre>
</div>
<div id="best-model-1" class="section level3">
<h3>Best model</h3>
<pre class="r"><code># for reproducibility
set.seed(123)

# train GBM model
gbm.fit.final_sbr &lt;- gbm(
  formula = (sev) ~BGI+BI+GLI+HI+HUE+NGRDI+VARI+Red+Green+Blue+gray+SI+SCI,
  data = all_data_spread_sbr[train,],
  distribution = &quot;gaussian&quot;,
  n.trees = best_par$optimal_trees[1],
  interaction.depth = best_par$interaction.depth[1],
  shrinkage = best_par$shrinkage[1],
  n.minobsinnode = best_par$n.minobsinnode[1],
  bag.fraction = best_par$bag.fraction[1], 
  train.fraction =0.75,
  n.cores = NULL, # will use all cores by default
  verbose = FALSE
  )</code></pre>
</div>
<div id="relative-influence-1" class="section level3">
<h3>Relative influence</h3>
<pre class="r"><code>par(mar = c(5, 8, 1, 1))
summary_gbm_sbr = summary(
  gbm.fit.final_sbr, 
  cBars = 15,
  method = relative.influence, # also can use permutation.test.gbm
  las = 2
  )</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-62-1.png" width="672" /></p>
<pre class="r"><code>rel_sbr = summary_gbm_sbr %&gt;% 
  rownames_to_column(&quot;index&quot;) %&gt;% 
  ggplot(aes(rel.inf, reorder(var, rel.inf)))+
  geom_col(aes(fill =rel.inf&gt;1, color =rel.inf&gt;1 ), width = 0.85)+
  theme_minimal_vgrid()+
  labs(x = &quot;Relative influence (%)&quot;,
       y = &quot;Model predictors&quot;,
       fill = &quot;RI &gt; 1%&quot;,
       color = &quot;RI &gt; 1%&quot;)
rel_sbr</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-62-2.png" width="672" /></p>
<pre class="r"><code># ggsave(&quot;figs/var_influence.png&quot;,dpi = 600, height = 4, width = 6)</code></pre>
<p>Partial dependence plots</p>
<pre class="r"><code>gbm.fit.final_sbr %&gt;%
  pdp::partial(pred.var = &quot;HUE&quot;, n.trees = gbm.fit.final_sbr$n.trees, grid.resolution = 100) %&gt;%
  ggplot(aes( HUE,(yhat)))+
  geom_line()</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-63-1.png" width="672" /></p>
<p>LIME</p>
<pre class="r"><code>library(lime)</code></pre>
<pre class="r"><code>model_type.gbm &lt;- function(x, ...) {
  return(&quot;regression&quot;)
}

predict_model.gbm &lt;- function(x, newdata, ...) {
  pred &lt;- predict(x, newdata, n.trees = x$n.trees)
  return(as.data.frame(pred))
}</code></pre>
<pre class="r"><code># get a few observations to perform local interpretation on
local_obs &lt;- (all_data_spread_sbr[-train,])[1:4, ]

# apply LIME
explainer &lt;- lime(all_data_spread_sbr[train,], gbm.fit.final_sbr)
explanation &lt;- lime::explain(local_obs, explainer, n_features = 7, n.trees =1)
plot_features(explanation)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-66-1.png" width="672" /></p>
</div>
</div>
<div id="prediction-1" class="section level2">
<h2>Prediction</h2>
<pre class="r"><code># predict values for test data
pred &lt;- predict(gbm.fit.final_sbr,
                n.trees = gbm.fit.final_sbr$n.trees,
                all_data_spread_sbr[-train,])

# results
caret::RMSE((pred), all_data_spread_sbr[-train,]$sev)</code></pre>
<pre><code>## [1] 1.926231</code></pre>
<pre class="r"><code>CCC(pred, all_data_spread_sbr$sev[-train])$rho.c$est</code></pre>
<pre><code>## [1] 0.9958621</code></pre>
<pre class="r"><code>cor(pred, all_data_spread_sbr$sev[-train])^2</code></pre>
<pre><code>## [1] 0.9921386</code></pre>
<pre class="r"><code>accuracy_sbr =data.frame(predi=pred, actual = all_data_spread_sbr$sev[-train]) %&gt;% 
  summarise(RMSE = caret::RMSE(pred, actual),
            r = cor(pred, actual),
            s.shift = CCC(pred, actual)$s.shift,
            l.shift = CCC(pred, actual)$l.shift,
            C.b = CCC(pred, actual)$C.b,
            CCC = CCC(pred, actual)$rho.c$est,
            CIS = paste(
  round(CCC(pred, all_data_spread_sbr$sev[-train])$rho.c[2],2),&quot;,&quot;,&quot; &quot;,
  round(CCC(pred, all_data_spread_sbr$sev[-train])$rho.c[3],2),sep = &quot;&quot;
  ))
accuracy_sbr</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["RMSE"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["r"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["s.shift"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["l.shift"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["C.b"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["CCC"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["CIS"],"name":[7],"type":["chr"],"align":["left"]}],"data":[{"1":"1.926231","2":"0.9960615","3":"0.9916907","4":"-0.01819114","5":"0.9997998","6":"0.9958621","7":"0.99, 1"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<div id="plot-1" class="section level4">
<h4>plot</h4>
<pre class="r"><code>conc_sbr = data.frame(predict = pred, actual =all_data_spread_sbr$sev[-train]) %&gt;% 
ggplot(aes(actual, predict ))+
  geom_point(size =2, color = &quot;gray&quot;)+
  geom_abline(intercept = 0, slope= 1, size = .81, color = &quot;black&quot;, linetype = &quot;dashed&quot;)+
  geom_smooth(method = &quot;lm&quot;, 
              color = &quot;red&quot;,
              size =.81, se =F,
              fullrange=T)+
  theme_minimal_grid()+
  labs(x = &quot;Predicted Severity (%)&quot;,
       y = &quot;Actual Severity (%)&quot;)+
  coord_equal(xlim = c(0,100),
              ylim = c(0,100))+
  xlim(0,100)


ggsave(&quot;figs/concordance.png&quot;, dpi = 600, height = 3.5, width = 4)</code></pre>
<pre><code>## `geom_smooth()` using formula &#39;y ~ x&#39;</code></pre>
</div>
</div>
</div>
<div id="xylella" class="section level1">
<h1>Xylella</h1>
<pre class="r"><code>pics&lt;-list.files(&quot;./pics/01-Xylella-tobacco-bg-white&quot;)
# length(pics)
#indices
index = c(&quot;BI&quot;,&quot;SCI&quot;,&quot;GLI&quot;,&quot;HI&quot;,&quot;SI&quot;,&quot;VARI&quot;,&quot;HUE&quot;,&quot;BGI&quot;,&quot;NGRDI&quot;)


box = data.frame()

for(i in 1:length(pics)){

EX.L1&lt;-stack(paste(&quot;./pics/01-Xylella-tobacco-bg-white/&quot;,pics[i],sep = &quot;&quot;))
EX.L1&lt;-aggregate(EX.L1, fact=7)
EX.L.Shape&lt;-fieldPolygon(mosaic=EX.L1, extent=T, plot = F)

EX1.Indices&lt;- fieldIndex(mosaic = EX.L1,
                         index = index, 
                         myIndex = c(&quot;Green&quot;), plot = F)

EX.L2&lt;-fieldMask(mosaic=EX.L1,  myIndex = c(&quot;Blue&quot;), cropValue=200, cropAbove=T, plot = F)

cut = mask(EX.L1, EX.L2$newMosaic)
EX.L4&lt;-fieldIndex(mosaic=cut,
                  index =index,
                  plot =F)


df = as(EX.L4, &quot;SpatialPixelsDataFrame&quot;)
dff = as.data.frame(df) %&gt;% 
  mutate(gray = 0.299*Red+0.587*Green+0.114*Blue) %&gt;% 
  gather(c(1:(3+length(index)),15), key = &quot;index&quot;, value = &quot;value&quot; ) %&gt;%
  filter(!is.na(value),
         !is.infinite(value)) %&gt;% 
  group_by(index) %&gt;% 
  dplyr::summarise(mean = mean(value, na.rm = T),
            std = sd(value),
            Q25 = quantile(value,0.25),
            Q50 = quantile(value,0.50),
            Q75 = quantile(value,0.75)) %&gt;% 
  mutate(leaf = pics[i])


box = box %&gt;% 
  bind_rows(dff)}
length(unique(box$leaf))
write.table(box,&quot;data/indexes_Xylella.txt&quot;)</code></pre>
<pre class="r"><code>box = read.table(&quot;data/indexes_Xylella.txt&quot;)</code></pre>
<div id="load" class="section level2">
<h2>Load</h2>
<pre class="r"><code>data_xy_load = read_csv(&quot;data_pics/01-Xylella-tobacco-severity.csv&quot;) %&gt;% 
  mutate(file = as.character(File)) %&gt;% 
  dplyr::select(-File)</code></pre>
<pre><code>## 
## -- Column specification --------------------------------------------------------
## cols(
##   File = col_double(),
##   ImageJ = col_double(),
##   LeafDoctor = col_double(),
##   APSAssess = col_double()
## )</code></pre>
<pre class="r"><code>data_xy = box %&gt;% 
  separate(leaf, into=c(&quot;file&quot;,&quot;format&quot;), sep =&quot;.jpg&quot;) %&gt;% 
  dplyr::select(-format) %&gt;% 
  full_join(data_xy_load, by=&quot;file&quot;) %&gt;% 
  mutate(sev=ImageJ)
head(data_xy)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["index"],"name":[1],"type":["chr"],"align":["left"]},{"label":["mean"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["std"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["Q25"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["Q50"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["Q75"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["file"],"name":[7],"type":["chr"],"align":["left"]},{"label":["ImageJ"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["LeafDoctor"],"name":[9],"type":["dbl"],"align":["right"]},{"label":["APSAssess"],"name":[10],"type":["dbl"],"align":["right"]},{"label":["sev"],"name":[11],"type":["dbl"],"align":["right"]}],"data":[{"1":"BGI","2":"0.5436164","3":"0.06012171","4":"0.5121507","5":"0.5339519","6":"0.5541888","7":"1","8":"26.78","9":"27.16","10":"26.11","11":"26.78","_rn_":"1"},{"1":"BI","2":"167.1293733","3":"13.09258103","4":"159.0452599","5":"167.3032019","6":"174.4013051","7":"1","8":"26.78","9":"27.16","10":"26.11","11":"26.78","_rn_":"2"},{"1":"Blue","2":"105.5686704","3":"17.59494065","4":"94.8571429","5":"103.7959184","6":"112.1020408","7":"1","8":"26.78","9":"27.16","10":"26.11","11":"26.78","_rn_":"3"},{"1":"GLI","2":"0.1386614","3":"0.02024763","4":"0.1340011","5":"0.1426077","6":"0.1493713","7":"1","8":"26.78","9":"27.16","10":"26.11","11":"26.78","_rn_":"4"},{"1":"gray","2":"181.5699319","3":"13.15076107","4":"173.3458163","5":"182.0882245","6":"189.5007959","7":"1","8":"26.78","9":"27.16","10":"26.11","11":"26.78","_rn_":"5"},{"1":"Green","2":"193.3106785","3":"13.42077360","4":"184.7346939","5":"194.0408163","6":"202.0408163","7":"1","8":"26.78","9":"27.16","10":"26.11","11":"26.78","_rn_":"6"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code># length(unique(data_xy$sev))</code></pre>
<pre class="r"><code>summary(data_xy$sev)</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##    0.42    8.50   19.07   25.20   37.83   83.99</code></pre>
<div id="images-2" class="section level3">
<h3>Images</h3>
<pre class="r"><code>hist_sev_xy =  data_xy %&gt;% 
  pivot_wider(id_col = c(file,sev),
              names_from = index, 
              values_from =  mean) %&gt;%
  ggplot(aes(sev))+
  geom_histogram(color = &quot;white&quot;, fill = &quot;black&quot;, bins = 20)+
  theme_minimal_hgrid(font_size = 10)+
  labs(x = &quot;Severity (%)&quot;,
       y = &quot;Frequency&quot;)+
  scale_x_continuous(limits = c(-5,105), breaks = seq(0,100,25))+
  # theme_void()+
  # coord_fixed()+
  theme(panel.background = element_rect(color = &quot;black&quot;))</code></pre>
<pre class="r"><code>EX.L1&lt;-stack(paste(&quot;./pics/01-Xylella-tobacco-bg-white/&quot;,&quot;75.jpg&quot;,sep = &quot;&quot;))
EX.L1&lt;-aggregate(EX.L1, fact=7)
EX.L.Shape&lt;-fieldPolygon(mosaic=EX.L1, extent=T, plot = F)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;</code></pre>
<pre class="r"><code>EX1.Indices&lt;- fieldIndex(mosaic = EX.L1,
                         index = index, 
                         myIndex = c(&quot;Green&quot;), plot = F)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;</code></pre>
<pre class="r"><code>EX.L2&lt;-fieldMask(mosaic=EX.L1,  myIndex = c(&quot;Blue&quot;), cropValue=200, cropAbove=T, plot = F)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;
## [1] &quot;Mask equation myIndex=Blue&quot;</code></pre>
<pre class="r"><code>cut = mask(EX.L1, EX.L2$newMosaic)
EX.L4&lt;-fieldIndex(mosaic=cut,
                  index =index,
                  plot =F)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;</code></pre>
<pre class="r"><code># plot(EX.L4$HUE)</code></pre>
<pre class="r"><code>rgb_fig_xy = RStoolbox::ggRGB(EX.L2$newMosaic,
                 r = 1,
                 g = 2,
                 b = 3)+
  theme_map()+
  coord_fixed()+
  theme(panel.background = element_rect(color = &quot;white&quot;))</code></pre>
<pre><code>## Coordinate system already present. Adding new coordinate system, which will replace the existing one.</code></pre>
<pre class="r"><code>gli_fig_xy = as.data.frame(EX.L4$HUE, xy=TRUE, na.rm =T) %&gt;% 
  ggplot(aes(x, y, fill = HUE))+
  geom_tile()+
  scale_fill_viridis_c(option = &quot;B&quot;,direction = -1)+
  theme_map()+
  coord_fixed()+
  theme(panel.background = element_rect(color = &quot;white&quot;),
        legend.title = element_text(size = 8),
        legend.text = element_text(size = 8))

# rgb_fig_xy+ gli_fig_xy</code></pre>
<pre class="r"><code># rgb_fig_sbr + gli_fig_sbr + hist_sev_sbr #+
#   rgb_fig_wlb + gli_fig_wlb + hist_sev_WLB+
  rgb_fig_xy + gli_fig_xy +hist_sev_xy</code></pre>
<pre><code>## Warning: Removed 2 rows containing missing values (geom_bar).</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-78-1.png" width="672" /></p>
<pre class="r"><code>#    plot_layout(widths = c(1, 1, 1),
#                heights = c(1,1,1))
# 
# ggsave(&quot;figs/leaf_gli.png&quot;,dpi = 600, height = 7, width =8)</code></pre>
</div>
<div id="relationship-sev-indices-2" class="section level3">
<h3>Relationship sev indices</h3>
<pre class="r"><code>rgb_gg_xy = data_xy %&gt;% 
  filter(index %in% c(&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;)) %&gt;% 
    ggplot(aes(mean, sev, color = index)) + 
  # geom_text()+
  geom_point(color = &quot;gray&quot;, size  =3)+
  geom_smooth(se = F, size = 2)+
  facet_wrap(~index, scales = &quot;free_x&quot;, nrow =1)+
  scale_color_manual(values = c(&quot;steelblue&quot;,&quot;darkgreen&quot;, &quot;darkred&quot;))+
  theme_minimal_hgrid()+
  labs(x = &quot;Mean value in the image&quot;,
       y = &quot;Disease severity (%)&quot;)+
  theme(panel.border = element_rect(color = &quot;gray&quot;))+
  theme(legend.position = &quot;none&quot;)
rgb_gg_xy</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-79-1.png" width="672" /></p>
<pre class="r"><code>index_gg_xy = data_xy %&gt;% 
  filter(!index %in% c(&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;)) %&gt;% 
    ggplot(aes(mean, sev)) + 
  # geom_text()+
  geom_point(color = &quot;gray&quot;, size  =3)+
  geom_smooth(color = &quot;black&quot;, se = F, size = 2)+
  facet_wrap(~index, scales = &quot;free_x&quot;, nrow =2)+
  theme_minimal_hgrid()+
  labs(x = &quot;Mean index value in the image&quot;,
       y = &quot;Disease severity (%)&quot;)+
  theme(panel.border = element_rect(color = &quot;gray&quot;))
index_gg_xy</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-80-1.png" width="672" /></p>
<pre class="r"><code>plot_grid(
  plot_grid(NULL,rgb_gg_xy,NULL, rel_widths =c(0.18,1,0.2), nrow = 1),
          index_gg_xy,
          nrow = 2,
          rel_heights = c(0.5,1))</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;
## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-81-1.png" width="672" /></p>
<pre class="r"><code>ggsave(&quot;figs/index_sev_XY.png&quot;, dpi = 500, height = 8, width = 10)</code></pre>
<pre class="r"><code>cor_xy = data_xy %&gt;% 
  group_by(index) %&gt;% 
  dplyr::summarise(cor = round(  cor.test(mean,sev, method = &quot;spearman&quot;)$estimate,3),
                   P_value = round(cor.test(mean,sev, method = &quot;spearman&quot;)$p.value,4)) %&gt;% 
  arrange(-cor)</code></pre>
<pre><code>## `summarise()` ungrouping output (override with `.groups` argument)</code></pre>
<pre class="r"><code>cor_xy</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["index"],"name":[1],"type":["chr"],"align":["left"]},{"label":["cor"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["P_value"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"HUE","2":"0.694","3":"0.0000"},{"1":"HI","2":"0.627","3":"0.0000"},{"1":"SCI","2":"0.623","3":"0.0000"},{"1":"SI","2":"0.356","3":"0.0002"},{"1":"Red","2":"0.286","3":"0.0032"},{"1":"BI","2":"0.219","3":"0.0252"},{"1":"BGI","2":"0.214","3":"0.0288"},{"1":"Blue","2":"0.195","3":"0.0463"},{"1":"gray","2":"0.194","3":"0.0477"},{"1":"Green","2":"0.121","3":"0.2174"},{"1":"GLI","2":"-0.490","3":"0.0000"},{"1":"NGRDI","2":"-0.623","3":"0.0000"},{"1":"VARI","2":"-0.624","3":"0.0000"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
</div>
<div id="spread-df-1" class="section level3">
<h3>Spread df</h3>
<pre class="r"><code>all_data_spread_xy = data_xy %&gt;% 
  pivot_wider(id_col = c(file,sev),
              names_from = index, 
              values_from =  mean)   

head(all_data_spread_xy)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["file"],"name":[1],"type":["chr"],"align":["left"]},{"label":["sev"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["BGI"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["BI"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["Blue"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["GLI"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["gray"],"name":[7],"type":["dbl"],"align":["right"]},{"label":["Green"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["HI"],"name":[9],"type":["dbl"],"align":["right"]},{"label":["HUE"],"name":[10],"type":["dbl"],"align":["right"]},{"label":["NGRDI"],"name":[11],"type":["dbl"],"align":["right"]},{"label":["Red"],"name":[12],"type":["dbl"],"align":["right"]},{"label":["SCI"],"name":[13],"type":["dbl"],"align":["right"]},{"label":["SI"],"name":[14],"type":["dbl"],"align":["right"]},{"label":["VARI"],"name":[15],"type":["dbl"],"align":["right"]}],"data":[{"1":"1","2":"26.78","3":"0.5436164","4":"167.1294","5":"105.56867","6":"0.13866141","7":"181.5699","8":"193.3107","9":"0.8683842","10":"-1.2312437","11":"0.015137044","12":"187.4974","13":"-0.015137044","14":"0.2835890","15":"0.020974514"},{"1":"10","2":"24.32","3":"0.5232702","4":"161.7949","5":"99.36791","6":"0.14893788","7":"176.3900","8":"188.8874","9":"0.8288865","10":"-1.3059402","11":"0.020765087","12":"181.2212","13":"-0.020765087","14":"0.2962883","15":"0.028340543"},{"1":"11","2":"16.31","3":"0.4770135","4":"134.6668","5":"78.49852","6":"0.18416802","7":"148.3695","8":"162.5577","9":"0.6317971","10":"-1.5660679","11":"0.050797655","12":"147.1550","13":"-0.050797655","14":"0.3130982","15":"0.067298775"},{"1":"12","2":"14.81","3":"0.5471168","4":"162.6126","5":"103.37410","6":"0.13803486","7":"176.5774","8":"187.9669","9":"0.8632352","10":"-1.1780436","11":"0.015827295","12":"182.1276","13":"-0.015827295","14":"0.2803030","15":"0.021911565"},{"1":"126","2":"7.92","3":"0.6397902","4":"188.3111","5":"134.90474","6":"0.09997205","7":"201.3672","8":"210.1206","9":"0.9952901","10":"-0.6338601","11":"0.001230542","12":"209.5227","13":"-0.001230542","14":"0.2199965","15":"0.001781766"},{"1":"127","2":"9.48","3":"0.5820188","4":"177.2043","5":"118.39907","6":"0.12488155","7":"191.4034","8":"202.4200","9":"0.8999821","10":"-1.1214523","11":"0.012366628","12":"197.6099","13":"-0.012366628","14":"0.2550979","15":"0.017096316"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
</div>
</div>
<div id="gbm-2" class="section level2">
<h2>GBM</h2>
<pre class="r"><code>train=sample(x = 1:length(all_data_spread_xy$sev), 
             size = round(0.75*length(all_data_spread_xy$sev),1))
# length(train)
gbm.fit = gbm(sev ~BGI+BI+GLI+HI+HUE+NGRDI+VARI+gray+ Red+Green+Blue  + SI + SCI,
             data = all_data_spread_xy[train,],
             distribution = &quot;gaussian&quot;,
              n.trees = 1000,
             interaction.depth = 3,
             shrinkage = 0.1,
             cv.folds = 5,
             n.cores = NULL, # will use all cores by default
             verbose = FALSE)
print(gbm.fit)</code></pre>
<pre><code>## gbm(formula = sev ~ BGI + BI + GLI + HI + HUE + NGRDI + VARI + 
##     gray + Red + Green + Blue + SI + SCI, distribution = &quot;gaussian&quot;, 
##     data = all_data_spread_xy[train, ], n.trees = 1000, interaction.depth = 3, 
##     shrinkage = 0.1, cv.folds = 5, verbose = FALSE, n.cores = NULL)
## A gradient boosted model with gaussian loss function.
## 1000 iterations were performed.
## The best cross-validation iteration was 231.
## There were 13 predictors of which 13 had non-zero influence.</code></pre>
<pre class="r"><code>sqrt(min(gbm.fit$cv.error))</code></pre>
<pre><code>## [1] 12.43899</code></pre>
<pre class="r"><code>gbm.perf(gbm.fit, method = &quot;cv&quot;)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-85-1.png" width="672" /></p>
<pre><code>## [1] 231</code></pre>
<pre class="r"><code># find index for n trees with minimum CV error</code></pre>
<pre class="r"><code>min_MSE &lt;- which.min(gbm.fit$cv.error)
sqrt(gbm.fit$cv.error[min_MSE])</code></pre>
<pre><code>## [1] 12.43899</code></pre>
<pre class="r"><code># best.iter &lt;- gbm.perf(model1, method = &quot;test&quot;)
# print(best.iter)

pred = predict(gbm.fit, newdata = all_data_spread_xy[-train,-1], ntrees = 5000 )</code></pre>
<pre><code>## Using 231 trees...</code></pre>
<pre class="r"><code>sqrt(mean(((pred)-all_data_spread_xy$sev[-train])^2))</code></pre>
<pre><code>## [1] 11.5175</code></pre>
<pre class="r"><code>CCC((pred), all_data_spread_xy$sev[-train])$rho.c$est</code></pre>
<pre><code>## [1] 0.6909319</code></pre>
<pre class="r"><code>plot((pred), (pred)-all_data_spread_xy$sev[-train])
abline(a=0,b=0)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-87-1.png" width="672" /></p>
<div id="testing-various-hyperparameters-2" class="section level3">
<h3>Testing various hyperparameters</h3>
<p>Create hyperparameter grid</p>
<pre class="r"><code>hyper_grid &lt;- expand.grid(
  shrinkage = c(.001, .01, .1, .3),
  interaction.depth = c(1, 3, 5, 6),
  n.minobsinnode = c(5, 10, 15),
  bag.fraction = c(.5,.65, .8, 1), 
  optimal_trees = 0,               # a place to dump results
  min_RMSE = 0,
  CCC =0 # a place to dump results
)
# total number of combinations
nrow(hyper_grid)</code></pre>
<pre><code>## [1] 192</code></pre>
<pre class="r"><code># randomize data
set.seed(123)
train=sample(x = 1:length(all_data_spread_xy$sev), 
             size = round(0.80*length(all_data_spread_xy$sev),1))

# grid search 
for(i in 1:nrow(hyper_grid)) {

# reproducibility
set.seed(123)


 # train model
gbm.tune &lt;- gbm(
  formula = (sev) ~BGI+BI+GLI+HI+HUE+NGRDI+VARI+gray +Red+Green+Blue + SI + SCI, #&lt;&lt;&lt;&lt;&lt;
  data = all_data_spread_xy[train,],
  distribution = &quot;gaussian&quot;,
  n.trees = 5000,
  interaction.depth = hyper_grid$interaction.depth[i],
  shrinkage = hyper_grid$shrinkage[i],
  n.minobsinnode = hyper_grid$n.minobsinnode[i],
  bag.fraction = hyper_grid$bag.fraction[i],
  train.fraction = .75,
  n.cores = NULL, # will use all cores by default
  verbose = FALSE)

pred = predict(gbm.tune, newdata = all_data_spread_xy[-train,-1], ntrees = 5000 )
 # add min training error and trees to grid
  hyper_grid$optimal_trees[i] &lt;- which.min(gbm.tune$valid.error)
  hyper_grid$min_RMSE[i] &lt;- sqrt(min(gbm.tune$valid.error))
  hyper_grid$CCC[i] = CCC(pred, all_data_spread_xy$sev[-train])$rho.c$est#&lt;&lt;&lt;&lt;&lt;
  
}

best_par = hyper_grid %&gt;% 
  dplyr::arrange(-CCC) %&gt;%
  head(10)
best_par</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["shrinkage"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["interaction.depth"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["n.minobsinnode"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["bag.fraction"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["optimal_trees"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["min_RMSE"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["CCC"],"name":[7],"type":["dbl"],"align":["right"]}],"data":[{"1":"0.30","2":"3","3":"5","4":"0.65","5":"19","6":"11.37018","7":"0.8649715","_rn_":"1"},{"1":"0.30","2":"5","3":"5","4":"0.65","5":"4662","6":"12.21829","7":"0.8407627","_rn_":"2"},{"1":"0.01","2":"1","3":"5","4":"0.65","5":"966","6":"12.00979","7":"0.8362572","_rn_":"3"},{"1":"0.30","2":"6","3":"5","4":"0.65","5":"25","6":"12.57791","7":"0.8356177","_rn_":"4"},{"1":"0.01","2":"1","3":"5","4":"1.00","5":"2091","6":"12.73349","7":"0.8252694","_rn_":"5"},{"1":"0.01","2":"1","3":"5","4":"0.80","5":"928","6":"12.61867","7":"0.8244094","_rn_":"6"},{"1":"0.30","2":"1","3":"5","4":"0.80","5":"23","6":"12.65166","7":"0.8236509","_rn_":"7"},{"1":"0.30","2":"1","3":"5","4":"1.00","5":"59","6":"12.65081","7":"0.8226995","_rn_":"8"},{"1":"0.10","2":"1","3":"5","4":"1.00","5":"218","6":"12.83123","7":"0.8215836","_rn_":"9"},{"1":"0.10","2":"1","3":"5","4":"0.65","5":"64","6":"12.07186","7":"0.8157707","_rn_":"10"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code># gbm.tune$fit</code></pre>
</div>
<div id="best-model-2" class="section level3">
<h3>Best model</h3>
<pre class="r"><code># for reproducibility
set.seed(123)

# train GBM model
gbm.fit.final_xy &lt;- gbm(
  formula = (sev) ~BGI+BI+GLI+HI+HUE+NGRDI+VARI+Red+Green+Blue+gray+SI+SCI,
  data = all_data_spread_xy[train,],
  distribution = &quot;gaussian&quot;,
  n.trees = best_par$optimal_trees[1],
  interaction.depth = best_par$interaction.depth[1],
  shrinkage = best_par$shrinkage[1],
  n.minobsinnode = best_par$n.minobsinnode[1],
  bag.fraction = best_par$bag.fraction[1], 
  train.fraction =0.75,
  n.cores = NULL, # will use all cores by default
  verbose = FALSE
  )</code></pre>
</div>
<div id="relative-influence-2" class="section level3">
<h3>Relative influence</h3>
<pre class="r"><code>par(mar = c(5, 8, 1, 1))
summary_gbm_xy = summary(
  gbm.fit.final_xy, 
  cBars = 15,
  method = relative.influence, # also can use permutation.test.gbm
  las = 2
  )</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-91-1.png" width="672" /></p>
<pre class="r"><code>rel_xy = summary_gbm_xy %&gt;% 
  rownames_to_column(&quot;index&quot;) %&gt;% 
  ggplot(aes(rel.inf, reorder(var, rel.inf)))+
  geom_col(aes(fill =rel.inf&gt;1, color =rel.inf&gt;1 ), width = 0.85)+
  theme_minimal_vgrid()+
  labs(x = &quot;Relative influence (%)&quot;,
       y = &quot;Model predictors&quot;,
       fill = &quot;RI &gt; 1%&quot;,
       color = &quot;RI &gt; 1%&quot;)
rel_xy</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-91-2.png" width="672" /></p>
<pre class="r"><code># ggsave(&quot;figs/var_influence.png&quot;,dpi = 600, height = 4, width = 6)</code></pre>
<p>Partial dependence plots</p>
<pre class="r"><code>gbm.fit.final_xy %&gt;%
  pdp::partial(pred.var = &quot;HUE&quot;, n.trees = gbm.fit.final_xy$n.trees, grid.resolution = 100) %&gt;%
  ggplot(aes( HUE,(yhat)))+
  geom_line()</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-92-1.png" width="672" /></p>
<p>LIME</p>
<pre class="r"><code>library(lime)</code></pre>
<pre class="r"><code>model_type.gbm &lt;- function(x, ...) {
  return(&quot;regression&quot;)
}

predict_model.gbm &lt;- function(x, newdata, ...) {
  pred &lt;- predict(x, newdata, n.trees = x$n.trees)
  return(as.data.frame(pred))
}</code></pre>
<pre class="r"><code># get a few observations to perform local interpretation on
local_obs &lt;- (all_data_spread_xy[-train,])[1:4, ]

# apply LIME
explainer &lt;- lime(all_data_spread_xy[train,], gbm.fit.final_xy)
explanation &lt;- lime::explain(local_obs, explainer, n_features = 7, n.trees =1)
plot_features(explanation)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-95-1.png" width="672" /></p>
</div>
</div>
<div id="prediction-2" class="section level2">
<h2>Prediction</h2>
<pre class="r"><code># predict values for test data
pred &lt;- predict(gbm.fit.final_xy,
                n.trees = gbm.fit.final_xy$n.trees,
                all_data_spread_xy[-train,])

# results
caret::RMSE((pred), all_data_spread_xy[-train,]$sev)</code></pre>
<pre><code>## [1] 10.55157</code></pre>
<pre class="r"><code>CCC((pred), all_data_spread_xy$sev[-train])$rho.c$est</code></pre>
<pre><code>## [1] 0.8649715</code></pre>
<pre class="r"><code>cor((pred), all_data_spread_xy$sev[-train])^2</code></pre>
<pre><code>## [1] 0.757813</code></pre>
<pre class="r"><code>accuracy_xy =data.frame(predi=pred, actual = all_data_spread_xy$sev[-train]) %&gt;% 
  summarise(RMSE = caret::RMSE(pred, actual),
            r = cor(pred, actual),
            s.shift = CCC(pred, actual)$s.shift,
            l.shift = CCC(pred, actual)$l.shift,
            C.b = CCC(pred, actual)$C.b,
            CCC = CCC(pred, actual)$rho.c$est,
            CIS = paste(
  round(CCC(pred, all_data_spread_xy$sev[-train])$rho.c[2],2),&quot;,&quot;,&quot; &quot;,
  round(CCC(pred, all_data_spread_xy$sev[-train])$rho.c[3],2),sep = &quot;&quot;
  ))
accuracy_xy</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["RMSE"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["r"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["s.shift"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["l.shift"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["C.b"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["CCC"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["CIS"],"name":[7],"type":["chr"],"align":["left"]}],"data":[{"1":"10.55157","2":"0.8705245","3":"1.077005","4":"0.08563874","5":"0.9936211","6":"0.8649715","7":"0.7, 0.94"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<div id="plot-2" class="section level4">
<h4>plot</h4>
<pre class="r"><code>conc_xy = data.frame(predict = pred, actual =all_data_spread_xy$sev[-train]) %&gt;% 
ggplot(aes(actual,predict))+
  geom_point(size =2, color = &quot;gray&quot;)+
  geom_abline(intercept = 0, slope= 1, size = .81, color = &quot;black&quot;, linetype = &quot;dashed&quot;)+
  geom_smooth(method = &quot;lm&quot;, 
              color = &quot;red&quot;,
              size =.81, se =F,
              fullrange=T)+
  theme_minimal_grid()+
  labs(x = &quot;Predicted Severity (%)&quot;,
       y = &quot;Actual Severity (%)&quot;)+
  coord_equal(xlim = c(0,100),
              ylim = c(0,100))+
  xlim(0,100)


ggsave(&quot;figs/concordance.png&quot;, dpi = 600, height = 3.5, width = 4)</code></pre>
<pre><code>## `geom_smooth()` using formula &#39;y ~ x&#39;</code></pre>
</div>
</div>
</div>
<div id="late-blight" class="section level1">
<h1>Late blight</h1>
<pre class="r"><code>pics&lt;-list.files(&quot;./pics/01 - PLB&quot;)
# length(pics)
#indices
index = c(&quot;BI&quot;,&quot;SCI&quot;,&quot;GLI&quot;,&quot;HI&quot;,&quot;SI&quot;,&quot;VARI&quot;,&quot;HUE&quot;,&quot;BGI&quot;,&quot;NGRDI&quot;)


box = data.frame()

for(i in 1:length(pics)){

EX.L1&lt;-stack(paste(&quot;./pics/01 - PLB/&quot;,pics[i],sep = &quot;&quot;))
EX.L1&lt;-aggregate(EX.L1, fact=4)
EX.L.Shape&lt;-fieldPolygon(mosaic=EX.L1, extent=T, plot = F)

# EX1.Indices&lt;- fieldIndex(mosaic = EX.L1,
#                          index = c(&quot;NGRDI&quot;,&quot;BGI&quot;,&quot;GLI&quot;, &quot;SCI&quot;,&quot;HI&quot;, &quot;SI&quot;), 
#                          myIndex = c(&quot;(Red-Blue)/Green&quot;), plot = F)

EX.L2&lt;-fieldMask(mosaic=EX.L1, myIndex =&quot;Red&quot;, cropValue=1, cropAbove=F, plot = F)

cut = mask(EX.L1, EX.L2$mask)
EX.L4&lt;-fieldIndex(mosaic=cut,
                  index =index,
                  plot =F)


df = as(EX.L4, &quot;SpatialPixelsDataFrame&quot;)
dff = as.data.frame(df) %&gt;% 
  mutate(gray = 0.299*Red+0.587*Green+0.114*Blue) %&gt;% 
  gather(c(1:(3+length(index)),15), key = &quot;index&quot;, value = &quot;value&quot; ) %&gt;%
  filter(!is.na(value),
         !is.infinite(value)) %&gt;% 
  group_by(index) %&gt;% 
  dplyr::summarise(mean = mean(value, na.rm = T),
            std = sd(value),
            Q25 = quantile(value,0.25),
            Q50 = quantile(value,0.50),
            Q75 = quantile(value,0.75)) %&gt;% 
  mutate(leaf = pics[i])


box = box %&gt;% 
  bind_rows(dff)}
length(unique(box$leaf))
write.table(box,&quot;data/indexes_PLB.txt&quot;)</code></pre>
<pre class="r"><code>box = read.table(&quot;data/indexes_PLB.txt&quot;)</code></pre>
<div id="load-severity-data-1" class="section level2">
<h2>Load severity data</h2>
<pre class="r"><code>library(gsheet)


sev_data_plb2 = gsheet2tbl(&quot;https://docs.google.com/spreadsheets/d/1cnxGPXBYVR9lq0InKhhMMjr-cQ21vCf3q6iw8VEi6pY/edit#gid=445074476&quot;) %&gt;% 
  unite(&quot;file&quot;,1:2, sep = &quot;.&quot;)



length(unique(sev_data_plb2$file))</code></pre>
<pre><code>## [1] 232</code></pre>
<pre class="r"><code>#new evaluation
all_data_PI = box %&gt;% 
  mutate(file = leaf) %&gt;% 
  dplyr::select(-leaf) %&gt;% 
  # separate(file, into = c(&quot;file&quot;, &quot;format&quot;), sep = &quot;.&quot;) %&gt;% 
  # dplyr::select(-format) %&gt;%
  right_join(sev_data_plb2)</code></pre>
<pre><code>## Joining, by = &quot;file&quot;</code></pre>
<pre class="r"><code># all_data_PI = box %&gt;% 
#   mutate(file = leaf) %&gt;% 
#   dplyr::select(-leaf) %&gt;% 
#   right_join(sev_data) #%&gt;% 
#   # filter(sev&gt;0) %&gt;% 
#   # mutate(sev = case_when(sev==0 ~0.001,
#   #                        sev &gt;0 ~sev))</code></pre>
<pre class="r"><code>summary(all_data_PI$sev)</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##    0.00   39.23   52.19   49.96   65.42   88.87</code></pre>
<div id="images-3" class="section level3">
<h3>Images</h3>
<pre class="r"><code>hist_sev_pi =  all_data_PI %&gt;% 
  pivot_wider(id_col = c(file,sev),
              names_from = index, 
              values_from =  mean) %&gt;% 
  ggplot(aes(sev))+
  geom_histogram(color = &quot;white&quot;, fill = &quot;black&quot;, bins =20)+
  theme_minimal_hgrid(font_size = 10)+
  labs(x = &quot;Severity (%)&quot;,
       y = &quot;Frequency&quot;)+
  scale_x_continuous(limits = c(-5,105), breaks = seq(0,100,25))+
  # theme_void()+
  # coord_fixed()+
  theme(panel.background = element_rect(color = &quot;black&quot;),
        axis.title.y = element_text(size=8))</code></pre>
<pre class="r"><code>EX.L1&lt;-stack(paste(&quot;./pics/01-potato_late_bligh/&quot;,&quot;PI21_2D.png&quot;,sep = &quot;&quot;))
EX.L1&lt;-aggregate(EX.L1, fact=10)
EX.L.Shape&lt;-fieldPolygon(mosaic=EX.L1, extent=T, plot = F)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;</code></pre>
<pre class="r"><code>EX1.Indices&lt;- fieldIndex(mosaic = EX.L1,
                         index = index, 
                         myIndex = c(&quot;Green&quot;), plot = F)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;</code></pre>
<pre class="r"><code>EX.L2&lt;-fieldMask(mosaic=EX.L1,  myIndex = c(&quot;Red&quot;), cropValue=1, cropAbove=F, plot = F)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;
## [1] &quot;Mask equation myIndex=Red&quot;</code></pre>
<pre class="r"><code>cut = mask(EX.L1, EX.L2$newMosaic)
EX.L4&lt;-fieldIndex(mosaic=cut,
                  index =index,
                  plot = F)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;</code></pre>
<pre class="r"><code># plot(EX.L4$HUE)</code></pre>
<pre class="r"><code>rgb_fig_pi = RStoolbox::ggRGB(EX.L2$newMosaic,
                 r = 1,
                 g = 2,
                 b = 3)+
  theme_map()+
  coord_fixed()+
  xlim(250,1500)+
  ylim(50,1300)+
  theme(panel.background = element_rect(color = &quot;white&quot;))</code></pre>
<pre><code>## Coordinate system already present. Adding new coordinate system, which will replace the existing one.</code></pre>
<pre class="r"><code>gli_fig_pi = as.data.frame(EX.L4$BGI, xy=TRUE, na.rm =T) %&gt;% 
  ggplot(aes(x, y, fill = BGI))+
  geom_tile()+
  scale_fill_viridis_c(option = &quot;B&quot;,direction = -1)+
  theme_map()+
  coord_fixed()+
  xlim(250,1500)+
  ylim(50,1300)+
  theme(panel.background = element_rect(color = &quot;white&quot;),
        legend.title = element_text(size = 8),
        legend.text = element_text(size = 8))

# rgb_fig_pi + gli_fig_pi</code></pre>
<pre class="r"><code># rgb_fig_sbr + gli_fig_sbr + hist_sev_sbr #+
#   rgb_fig_wlb + gli_fig_wlb + hist_sev_WLB+
#   rgb_fig_xy + gli_fig_xy +hist_sev_xy+
  rgb_fig_pi + gli_fig_pi +hist_sev_pi</code></pre>
<pre><code>## Warning: Removed 2 rows containing missing values (geom_bar).</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-108-1.png" width="672" /></p>
<pre class="r"><code>#    plot_layout(widths = c(1, 1, 1),
#                heights = c(1,1,1,1))+
#   plot_annotation(tag_levels = &#39;A&#39;)

# ggsave(&quot;figs/leaf_gli.png&quot;,dpi = 600, height = 8, width =8)</code></pre>
</div>
<div id="relationship-sev-indices-3" class="section level3">
<h3>Relationship sev indices</h3>
<pre class="r"><code>rgb_gg_pi = all_data_PI %&gt;% 
  filter(index %in% c(&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;)) %&gt;% 
    ggplot(aes(mean, sev, color = index)) + 
  # geom_text()+
  geom_point(color = &quot;gray&quot;, size  =3)+
  geom_smooth(se = F, size = 2)+
  facet_wrap(~index, scales = &quot;free_x&quot;, nrow =1)+
  scale_color_manual(values = c(&quot;steelblue&quot;,&quot;darkgreen&quot;, &quot;darkred&quot;))+
  theme_minimal_hgrid()+
  labs(x = &quot;Mean value in the image&quot;,
       y = &quot;Disease severity (%)&quot;)+
  theme(panel.border = element_rect(color = &quot;gray&quot;))+
  theme(legend.position = &quot;none&quot;)
rgb_gg_pi</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-109-1.png" width="672" /></p>
<pre class="r"><code>index_gg_pi = all_data_PI %&gt;% 
  filter(!index %in% c(&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;)) %&gt;% 
    ggplot(aes(mean, sev)) + 
  # geom_text()+
  geom_point(color = &quot;gray&quot;, size  =3)+
  geom_smooth(color = &quot;black&quot;, se = F, size = 2)+
  facet_wrap(~index, scales = &quot;free_x&quot;, nrow =2)+
  theme_minimal_hgrid()+
  labs(x = &quot;Mean index value in the image&quot;,
       y = &quot;Disease severity (%)&quot;)+
  theme(panel.border = element_rect(color = &quot;gray&quot;))
index_gg_pi</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-110-1.png" width="672" /></p>
<pre class="r"><code>plot_grid(
  plot_grid(NULL,rgb_gg_pi,NULL, rel_widths =c(0.18,1,0.2), nrow = 1),
          index_gg_pi,
          nrow = 2,
          rel_heights = c(0.5,1))</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;
## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-111-1.png" width="672" /></p>
<pre class="r"><code>ggsave(&quot;figs/index_sev_pi.png&quot;, dpi = 500, height = 8, width = 10)</code></pre>
<pre class="r"><code>cor_PI = all_data_PI %&gt;% 
  group_by(index) %&gt;% 
  dplyr::summarise(cor = round(  cor.test(mean,sev, method = &quot;spearman&quot;)$estimate,3),
                   P_value = round(cor.test(mean,sev, method = &quot;spearman&quot;)$p.value,4)) %&gt;% 
  arrange(-cor)</code></pre>
<pre><code>## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties</code></pre>
<pre><code>## `summarise()` ungrouping output (override with `.groups` argument)</code></pre>
<pre class="r"><code>cor_PI</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["index"],"name":[1],"type":["chr"],"align":["left"]},{"label":["cor"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["P_value"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"BGI","2":"0.889","3":"0.0000"},{"1":"Blue","2":"0.854","3":"0.0000"},{"1":"BI","2":"0.609","3":"0.0000"},{"1":"gray","2":"0.572","3":"0.0000"},{"1":"Red","2":"0.501","3":"0.0000"},{"1":"Green","2":"0.492","3":"0.0000"},{"1":"SCI","2":"0.082","3":"0.2142"},{"1":"VARI","2":"0.020","3":"0.7601"},{"1":"HUE","2":"-0.054","3":"0.4138"},{"1":"NGRDI","2":"-0.082","3":"0.2142"},{"1":"HI","2":"-0.327","3":"0.0000"},{"1":"GLI","2":"-0.661","3":"0.0000"},{"1":"SI","2":"-0.855","3":"0.0000"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
</div>
<div id="spread-df-2" class="section level3">
<h3>Spread df</h3>
<pre class="r"><code>all_data_spread_plb = all_data_PI %&gt;% 
  pivot_wider(id_col = c(file,sev),
              names_from = index, 
              values_from =  mean)   

head(all_data_spread_plb)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["file"],"name":[1],"type":["chr"],"align":["left"]},{"label":["sev"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["BGI"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["BI"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["Blue"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["GLI"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["gray"],"name":[7],"type":["dbl"],"align":["right"]},{"label":["Green"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["HI"],"name":[9],"type":["dbl"],"align":["right"]},{"label":["HUE"],"name":[10],"type":["dbl"],"align":["right"]},{"label":["NGRDI"],"name":[11],"type":["dbl"],"align":["right"]},{"label":["Red"],"name":[12],"type":["dbl"],"align":["right"]},{"label":["SCI"],"name":[13],"type":["dbl"],"align":["right"]},{"label":["SI"],"name":[14],"type":["dbl"],"align":["right"]},{"label":["VARI"],"name":[15],"type":["dbl"],"align":["right"]}],"data":[{"1":"foto01.png","2":"9.000000","3":"0.25363365","4":"57.12791","5":"20.651936","6":"0.3042240","7":"64.04993","8":"74.07280","9":"0.5110658","10":"-0.6627991","11":"0.09754001","12":"60.91931","13":"-0.09754001","14":"0.5667016","15":"0.1141011"},{"1":"foto02.png","2":"18.000000","3":"0.22692752","4":"54.33280","5":"17.979925","6":"0.3113957","7":"60.84859","8":"70.34088","9":"0.5497061","10":"-0.6820149","11":"0.09185999","12":"58.55780","13":"-0.09185999","14":"0.6117315","15":"0.1061503"},{"1":"foto03.png","2":"3.106504","3":"0.05612778","4":"45.37976","5":"4.379311","6":"0.4765589","7":"51.59967","8":"64.93425","9":"0.2824614","10":"-0.6584705","11":"0.20944996","12":"43.42484","13":"-0.20944996","14":"0.8700296","15":"0.2161284"},{"1":"foto04.png","2":"3.211166","3":"0.31267603","4":"60.16884","5":"25.972990","6":"0.2737552","7":"67.38537","8":"77.17300","9":"0.4994249","10":"-0.6649015","11":"0.09138491","12":"63.95952","13":"-0.09138491","14":"0.4796293","15":"0.1124940"},{"1":"foto07.png","2":"4.136306","3":"0.28881103","4":"55.09950","5":"25.490871","6":"0.3914085","7":"62.30321","8":"76.53045","9":"-0.1944951","10":"-0.8530637","11":"0.24807269","12":"48.40760","13":"-0.24807269","14":"0.4434008","15":"0.3047156"},{"1":"foto08.png","2":"5.951718","3":"0.36046580","4":"56.27959","5":"28.602833","6":"0.2870583","7":"62.97897","8":"73.48632","9":"0.1828795","10":"-0.7832093","11":"0.13832606","12":"55.45744","13":"-0.13832606","14":"0.3962352","15":"0.1791645"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
</div>
<div id="gbm-3" class="section level3">
<h3>GBM</h3>
<pre class="r"><code>train=sample(x = 1:length(all_data_spread_plb$sev), 
             size = round(0.75*length(all_data_spread_plb$sev),1))
# length(train)
gbm.fit = gbm(sev ~BGI+BI+GLI+HI+HUE+NGRDI+VARI+gray+ Red+Green+Blue  + SI + SCI,
             data = all_data_spread_plb[train,],
             distribution = &quot;gaussian&quot;,
              n.trees = 1000,
             interaction.depth = 3,
             shrinkage = 0.1,
             cv.folds = 5,
             n.cores = NULL, # will use all cores by default
             verbose = FALSE)
print(gbm.fit)</code></pre>
<pre><code>## gbm(formula = sev ~ BGI + BI + GLI + HI + HUE + NGRDI + VARI + 
##     gray + Red + Green + Blue + SI + SCI, distribution = &quot;gaussian&quot;, 
##     data = all_data_spread_plb[train, ], n.trees = 1000, interaction.depth = 3, 
##     shrinkage = 0.1, cv.folds = 5, verbose = FALSE, n.cores = NULL)
## A gradient boosted model with gaussian loss function.
## 1000 iterations were performed.
## The best cross-validation iteration was 69.
## There were 13 predictors of which 13 had non-zero influence.</code></pre>
<pre class="r"><code>sqrt(min(gbm.fit$cv.error))</code></pre>
<pre><code>## [1] 10.52827</code></pre>
<pre class="r"><code>gbm.perf(gbm.fit, method = &quot;cv&quot;)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-115-1.png" width="672" /></p>
<pre><code>## [1] 69</code></pre>
<pre class="r"><code># find index for n trees with minimum CV error</code></pre>
<pre class="r"><code>min_MSE &lt;- which.min(gbm.fit$cv.error)
sqrt(gbm.fit$cv.error[min_MSE])</code></pre>
<pre><code>## [1] 10.52827</code></pre>
<pre class="r"><code># best.iter &lt;- gbm.perf(model1, method = &quot;test&quot;)
# print(best.iter)

pred = predict(gbm.fit, newdata = all_data_spread_plb[-train,-1], ntrees = 5000 )</code></pre>
<pre><code>## Using 69 trees...</code></pre>
<pre class="r"><code>sqrt(mean(((pred)-all_data_spread_plb$sev[-train])^2))</code></pre>
<pre><code>## [1] 10.35476</code></pre>
<pre class="r"><code>CCC((pred), all_data_spread_plb$sev[-train])$rho.c$est</code></pre>
<pre><code>## [1] 0.8523472</code></pre>
<pre class="r"><code>plot((pred), (pred)-all_data_spread_plb$sev[-train])
abline(a=0,b=0)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-117-1.png" width="672" /></p>
</div>
<div id="testing-various-hyperparameters-3" class="section level3">
<h3>Testing various hyperparameters</h3>
<p>Create hyperparameter grid</p>
<pre class="r"><code>hyper_grid &lt;- expand.grid(
  shrinkage = c(.001, .01, .1, .3),
  interaction.depth = c(1, 3, 5, 6),
  n.minobsinnode = c(5, 10, 15),
  bag.fraction = c(.5,.65, .8, 1), 
  optimal_trees = 0,               # a place to dump results
  min_RMSE = 0,
  CCC =0 # a place to dump results
)
# total number of combinations
nrow(hyper_grid)</code></pre>
<pre><code>## [1] 192</code></pre>
<pre class="r"><code># randomize data
set.seed(123)
train=sample(x = 1:length(all_data_spread_plb$sev), 
             size = round(0.80*length(all_data_spread_plb$sev),1))

# grid search 
for(i in 1:nrow(hyper_grid)) {

# reproducibility
set.seed(123)


 # train model
gbm.tune &lt;- gbm(
  formula = sev ~BGI+BI+GLI+HI+HUE+NGRDI+VARI+gray+ Red+Green+Blue  + SI + SCI, 
  data = all_data_spread_plb[train,],
  distribution = &quot;gaussian&quot;,
  n.trees = 5000,
  interaction.depth = hyper_grid$interaction.depth[i],
  shrinkage = hyper_grid$shrinkage[i],
  n.minobsinnode = hyper_grid$n.minobsinnode[i],
  bag.fraction = hyper_grid$bag.fraction[i],
  train.fraction = .75,
  n.cores = NULL, # will use all cores by default
  verbose = FALSE)

pred = predict(gbm.tune, newdata = all_data_spread_plb[-train,-1], ntrees = 5000 )
 # add min training error and trees to grid
  hyper_grid$optimal_trees[i] &lt;- which.min(gbm.tune$valid.error)
  hyper_grid$min_RMSE[i] &lt;- sqrt(min(gbm.tune$valid.error))
  hyper_grid$CCC[i] = CCC((pred), all_data_spread_plb$sev[-train])$rho.c$est
  
}

best_par = hyper_grid %&gt;% 
  dplyr::arrange(-CCC) %&gt;%
  head(10)
best_par</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["shrinkage"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["interaction.depth"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["n.minobsinnode"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["bag.fraction"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["optimal_trees"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["min_RMSE"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["CCC"],"name":[7],"type":["dbl"],"align":["right"]}],"data":[{"1":"0.100","2":"3","3":"5","4":"0.80","5":"32","6":"11.43165","7":"0.8969288","_rn_":"1"},{"1":"0.100","2":"6","3":"5","4":"0.65","5":"32","6":"11.52381","7":"0.8928580","_rn_":"2"},{"1":"0.100","2":"3","3":"5","4":"0.50","5":"32","6":"11.24831","7":"0.8870234","_rn_":"3"},{"1":"0.100","2":"5","3":"5","4":"0.50","5":"31","6":"11.81925","7":"0.8837066","_rn_":"4"},{"1":"0.001","2":"3","3":"5","4":"0.65","5":"3641","6":"12.00226","7":"0.8829091","_rn_":"5"},{"1":"0.010","2":"3","3":"5","4":"0.65","5":"400","6":"11.96944","7":"0.8823258","_rn_":"6"},{"1":"0.100","2":"6","3":"5","4":"0.50","5":"46","6":"11.54810","7":"0.8820699","_rn_":"7"},{"1":"0.100","2":"3","3":"5","4":"0.65","5":"69","6":"11.34887","7":"0.8818385","_rn_":"8"},{"1":"0.001","2":"3","3":"5","4":"0.50","5":"3709","6":"12.00293","7":"0.8815219","_rn_":"9"},{"1":"0.300","2":"5","3":"5","4":"1.00","5":"9","6":"12.74006","7":"0.8813283","_rn_":"10"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code># gbm.tune$fit</code></pre>
</div>
<div id="best-model-3" class="section level3">
<h3>Best model</h3>
<pre class="r"><code># for reproducibility
set.seed(123)

# train GBM model
gbm.fit.final_plb &lt;- gbm(
  formula = sev ~BGI+BI+GLI+HI+HUE+NGRDI+VARI+gray+ Red+Green+Blue  + SI + SCI, 
  data = all_data_spread_plb[train,],
  distribution = &quot;gaussian&quot;,
  n.trees = best_par$optimal_trees[1],
  interaction.depth = best_par$interaction.depth[1],
  shrinkage = best_par$shrinkage[1],
  n.minobsinnode = best_par$n.minobsinnode[1],
  bag.fraction = best_par$bag.fraction[1], 
  train.fraction =0.75,
  n.cores = NULL, # will use all cores by default
  verbose = FALSE
  )</code></pre>
</div>
<div id="relative-influence-3" class="section level3">
<h3>Relative influence</h3>
<pre class="r"><code>par(mar = c(5, 8, 1, 1))
summary_gbm_plb = summary(
  gbm.fit.final_plb, 
  cBars = 13,
  method = relative.influence, # also can use permutation.test.gbm
  las = 2
  )</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-121-1.png" width="672" /></p>
<pre class="r"><code>rel_plb = summary_gbm_plb  %&gt;% 
  rownames_to_column(&quot;index&quot;) %&gt;% 
  ggplot(aes(rel.inf, reorder(var, rel.inf)))+
  geom_col(aes(fill =rel.inf&gt;1, color =rel.inf&gt;1 ), width = 0.85)+
  theme_minimal_vgrid()+
  labs(x = &quot;Relative influence (%)&quot;,
       y = &quot;Model predictors&quot;,
       fill = &quot;RI &gt; 1%&quot;,
       color = &quot;RI &gt; 1%&quot;)
rel_plb</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-121-2.png" width="672" /></p>
<pre class="r"><code># ggsave(&quot;figs/var_influence.png&quot;,dpi = 600, height = 4, width = 6)</code></pre>
<p>Partial dependence plots</p>
<pre class="r"><code>gbm.fit.final_plb %&gt;%
  pdp::partial(pred.var = &quot;BGI&quot;, n.trees = gbm.fit.final_plb$n.trees, grid.resolution = 100) %&gt;%
  ggplot(aes( BGI,(yhat)))+
  geom_line()</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-122-1.png" width="672" /></p>
<p>LIME</p>
<pre class="r"><code>library(lime)</code></pre>
<pre class="r"><code>model_type.gbm &lt;- function(x, ...) {
  return(&quot;regression&quot;)
}

predict_model.gbm &lt;- function(x, newdata, ...) {
  pred &lt;- predict(x, newdata, n.trees = x$n.trees)
  return(as.data.frame(pred))
}</code></pre>
<pre class="r"><code># get a few observations to perform local interpretation on
local_obs &lt;- (all_data_spread_plb[-train,])[1:4, ]

# apply LIME
explainer &lt;- lime(all_data_spread_plb[train,], gbm.fit.final_plb)
explanation &lt;- lime::explain(local_obs, explainer, n_features = 7, n.trees =1)
plot_features(explanation)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-125-1.png" width="672" /></p>
</div>
</div>
<div id="prediction-3" class="section level2">
<h2>Prediction</h2>
<pre class="r"><code># predict values for test data
pred &lt;- predict(gbm.fit.final_plb, n.trees = gbm.fit.final_plb$n.trees, all_data_spread_plb[-train,])

# results
caret::RMSE(pred, all_data_spread_plb[-train,]$sev)</code></pre>
<pre><code>## [1] 8.128485</code></pre>
<pre class="r"><code>CCC(pred, all_data_spread_plb$sev[-train])$rho.c$est</code></pre>
<pre><code>## [1] 0.8969288</code></pre>
<pre class="r"><code>cor(pred, all_data_spread_plb$sev[-train])^2</code></pre>
<pre><code>## [1] 0.8131546</code></pre>
<pre class="r"><code>accuracy_pi =data.frame(predi=pred, actual = all_data_spread_plb$sev[-train]) %&gt;% 
  summarise(RMSE = caret::RMSE(pred, actual),
            r = cor(pred, actual),
            s.shift = CCC(pred, actual)$s.shift,
            l.shift = CCC(pred, actual)$l.shift,
            C.b = CCC(pred, actual)$C.b,
            CCC = CCC(pred, actual)$rho.c$est,
            CIS = paste(
  round(CCC(pred, all_data_spread_plb$sev[-train])$rho.c[2],2),&quot;,&quot;,&quot; &quot;,
  round(CCC(pred, all_data_spread_plb$sev[-train])$rho.c[3],2),sep = &quot;&quot;
  ))
accuracy_pi</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["RMSE"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["r"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["s.shift"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["l.shift"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["C.b"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["CCC"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["CIS"],"name":[7],"type":["chr"],"align":["left"]}],"data":[{"1":"8.128485","2":"0.9017508","3":"1.106488","4":"0.02244766","5":"0.9946526","6":"0.8969288","7":"0.82, 0.94"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<div id="plot-3" class="section level4">
<h4>plot</h4>
<pre class="r"><code>conc_pi = data.frame(predict = pred, actual =all_data_spread_plb$sev[-train]) %&gt;% 
ggplot(aes(actual,predict))+
  geom_point(size =2, color = &quot;gray&quot;)+
  geom_abline(intercept = 0, slope= 1, size = .81, color = &quot;black&quot;, linetype = &quot;dashed&quot;)+
  geom_smooth(method = &quot;lm&quot;, 
              color = &quot;red&quot;,
              size =.81, se =F,
              fullrange=T)+
  theme_minimal_grid()+
  labs(x = &quot;Predicted Severity (%)&quot;,
       y = &quot;Actual Severity (%)&quot;)+
  coord_equal(xlim = c(0,100),
              ylim = c(0,100))+
  xlim(0,100)


# ggsave(&quot;figs/concordance.png&quot;, dpi = 600, height = 3.5, width = 4)</code></pre>
</div>
</div>
</div>
<div id="calonectria-leaf-blight" class="section level1">
<h1>Calonectria leaf blight</h1>
<pre class="r"><code>pics&lt;-list.files(&quot;./pics/01-Calonectria_leaf_bligth&quot;)
# length(pics)
#indices
index = c(&quot;BI&quot;,&quot;SCI&quot;,&quot;GLI&quot;,&quot;HI&quot;,&quot;SI&quot;,&quot;VARI&quot;,&quot;HUE&quot;,&quot;BGI&quot;,&quot;NGRDI&quot;)


box = data.frame()

for(i in 1:length(pics)){

EX.L1&lt;-stack(paste(&quot;./pics/01-Calonectria_leaf_bligth/&quot;,pics[i],sep = &quot;&quot;))
EX.L1&lt;-aggregate(EX.L1, fact=7)
EX.L.Shape&lt;-fieldPolygon(mosaic=EX.L1, extent=T, plot = F)

EX1.Indices&lt;- fieldIndex(mosaic = EX.L1,
                         index = index, 
                         myIndex = c(&quot;Green&quot;), plot = F)

EX.L2&lt;-fieldMask(mosaic=EX.L1,  myIndex = c(&quot;Blue&quot;), cropValue=175, cropAbove=T, plot = F)

cut = mask(EX.L1, EX.L2$newMosaic)
EX.L4&lt;-fieldIndex(mosaic=cut,
                  index =index,
                  plot =F)


df = as(EX.L4, &quot;SpatialPixelsDataFrame&quot;)
dff = as.data.frame(df) %&gt;% 
  mutate(gray = 0.299*Red+0.587*Green+0.114*Blue) %&gt;% 
  gather(c(1:(3+length(index)),15), key = &quot;index&quot;, value = &quot;value&quot; ) %&gt;%
  filter(!is.na(value),
         !is.infinite(value)) %&gt;% 
  group_by(index) %&gt;% 
  dplyr::summarise(mean = mean(value, na.rm = T),
            std = sd(value),
            Q25 = quantile(value,0.25),
            Q50 = quantile(value,0.50),
            Q75 = quantile(value,0.75)) %&gt;% 
  mutate(leaf = pics[i])


box = box %&gt;% 
  bind_rows(dff)}
length(unique(box$leaf))
write.table(box,&quot;data/indexes_calonec.txt&quot;)</code></pre>
<pre class="r"><code>box = read.table(&quot;data/indexes_calonec.txt&quot;)</code></pre>
<div id="load-sev" class="section level3">
<h3>Load sev</h3>
<pre class="r"><code>data_calo_load = gsheet2tbl(&quot;https://docs.google.com/spreadsheets/d/1D5Cn6CND8OjQwdv_AVt_sxJ0H21DjIQnfmB7HKwqYXI/edit?usp=sharing&quot;) %&gt;% 
  mutate(file = as.character(file)) %&gt;% 
  dplyr::select(file,area_total,area_doente_roxa,area_doente,sev_roxa,sev)
head(data_calo_load)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["file"],"name":[1],"type":["chr"],"align":["left"]},{"label":["area_total"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["area_doente_roxa"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["area_doente"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["sev_roxa"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["sev"],"name":[6],"type":["dbl"],"align":["right"]}],"data":[{"1":"1","2":"411776","3":"54374","4":"9384","5":"13.20475","6":"2.278909"},{"1":"2","2":"415627","3":"81757","4":"55557","5":"19.67076","6":"13.367033"},{"1":"3","2":"761523","3":"569173","4":"413002","5":"74.74141","6":"54.233687"},{"1":"4","2":"798787","3":"708346","4":"594451","5":"88.67771","6":"74.419213"},{"1":"5","2":"657200","3":"219361","4":"85449","5":"33.37812","6":"13.001978"},{"1":"6","2":"784817","3":"628389","4":"628389","5":"80.06822","6":"80.068220"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>data_calo = box %&gt;% 
  separate(leaf, into=c(&quot;file&quot;,&quot;format&quot;), sep =&quot;.jpg&quot;) %&gt;% 
  dplyr::select(-format) %&gt;% 
  full_join(data_calo_load, by=&quot;file&quot;) %&gt;% 
  mutate(sev=sev_roxa)
# data_calo

length(unique(data_calo$sev))</code></pre>
<pre><code>## [1] 300</code></pre>
<pre class="r"><code>summary(data_calo$sev)</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##  0.8715  4.4431  9.8264 16.2402 20.1989 95.4470</code></pre>
</div>
<div id="images-4" class="section level3">
<h3>Images</h3>
<pre class="r"><code>hist_sev_calo =  data_calo %&gt;% 
  pivot_wider(id_col = c(file,sev_roxa),
              names_from = index, 
              values_from =  mean) %&gt;%
  ggplot(aes(sev_roxa))+
  geom_histogram(color = &quot;white&quot;, fill = &quot;black&quot;, bins = 20)+
  theme_minimal_hgrid(font_size = 10)+
  labs(x = &quot;Severity (%)&quot;,
       y = &quot;Frequency&quot;)+
  scale_x_continuous(limits = c(-5,105), breaks = seq(0,100,25))+
  # theme_void()+
  # coord_fixed()+
  theme(panel.background = element_rect(color = &quot;black&quot;),
        axis.title.y = element_text(size=8))</code></pre>
<pre class="r"><code>EX.L1&lt;-stack(paste(&quot;./pics/01-Calonectria_leaf_bligth/&quot;,&quot;57.jpg&quot;,sep = &quot;&quot;))
EX.L1&lt;-aggregate(EX.L1, fact=7)
EX.L.Shape&lt;-fieldPolygon(mosaic=EX.L1, extent=T, plot = F)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;</code></pre>
<pre class="r"><code># EX1.Indices&lt;- fieldIndex(mosaic = EX.L1,
#                          index = index, 
#                          myIndex = c(&quot;Green&quot;), plot = F)

EX.L2&lt;-fieldMask(mosaic=EX.L1,  myIndex = c(&quot;Blue&quot;), cropValue=175, cropAbove=T, plot = F)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;
## [1] &quot;Mask equation myIndex=Blue&quot;</code></pre>
<pre class="r"><code>cut = mask(EX.L1, EX.L2$newMosaic)
EX.L4&lt;-fieldIndex(mosaic=cut,
                  index =index,
                  plot =F)</code></pre>
<pre><code>## [1] &quot;3 layers available&quot;</code></pre>
<pre class="r"><code># plot(EX.L4$HUE)</code></pre>
<pre class="r"><code>rgb_fig_calo = RStoolbox::ggRGB(EX.L2$newMosaic,
                 r = 1,
                 g = 2,
                 b = 3)+
  theme_map()+
  coord_fixed()+
  theme(panel.background = element_rect(color = &quot;white&quot;))</code></pre>
<pre><code>## Coordinate system already present. Adding new coordinate system, which will replace the existing one.</code></pre>
<pre class="r"><code>gli_fig_calo = as.data.frame(EX.L4$HUE, xy=TRUE, na.rm =T) %&gt;% 
  ggplot(aes(x, y, fill = HUE))+
  geom_tile()+
  scale_fill_viridis_c(option = &quot;B&quot;,direction = -1)+
  theme_map()+
  coord_fixed()+
  theme(panel.background = element_rect(color = &quot;white&quot;),
        legend.title = element_text(size = 8),
        legend.text = element_text(size = 8))

rgb_fig_calo+ gli_fig_calo</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-136-1.png" width="672" /></p>
<pre class="r"><code>rgb_fig_sbr + gli_fig_sbr + hist_sev_sbr +
  rgb_fig_xy + gli_fig_xy +hist_sev_xy+
  rgb_fig_calo + gli_fig_calo + hist_sev_calo+
  rgb_fig_wlb + gli_fig_wlb + hist_sev_WLB+
  rgb_fig_pi + gli_fig_pi + hist_sev_pi+
   plot_layout(widths = c(1, 1, 1),
               heights = c(1,1,1,1,1))+
  plot_annotation(tag_levels = &#39;A&#39;)&amp;
  theme(legend.key.size = unit(3, &#39;mm&#39;),
        legend.text = element_text(size =6))</code></pre>
<pre><code>## Warning: Removed 2 rows containing missing values (geom_bar).

## Warning: Removed 2 rows containing missing values (geom_bar).

## Warning: Removed 2 rows containing missing values (geom_bar).

## Warning: Removed 2 rows containing missing values (geom_bar).

## Warning: Removed 2 rows containing missing values (geom_bar).</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-137-1.png" width="672" /></p>
<pre class="r"><code>ggsave(&quot;figs/leaf_gli.png&quot;,dpi = 600, height = 9, width =7)</code></pre>
<pre><code>## Warning: Removed 2 rows containing missing values (geom_bar).

## Warning: Removed 2 rows containing missing values (geom_bar).

## Warning: Removed 2 rows containing missing values (geom_bar).

## Warning: Removed 2 rows containing missing values (geom_bar).

## Warning: Removed 2 rows containing missing values (geom_bar).</code></pre>
</div>
<div id="relationship-sev-indices-4" class="section level3">
<h3>Relationship sev indices</h3>
<pre class="r"><code> rgb_gg_calo =  data_calo %&gt;% 
  filter(index %in% c(&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;)) %&gt;%
    ggplot(aes(mean, sev_roxa, color = index)) + 
  # geom_text()+
  geom_point(color = &quot;gray&quot;, size  =3)+
  geom_smooth(se = F, size = 2)+
  facet_wrap(~index, scales = &quot;free_x&quot;, nrow =1)+
  scale_color_manual(values = c(&quot;steelblue&quot;,&quot;darkgreen&quot;, &quot;darkred&quot;))+
  theme_minimal_hgrid()+
  labs(x = &quot;Mean value in the image&quot;,
       y = &quot;Disease severity (%)&quot;)+
  theme(panel.border = element_rect(color = &quot;gray&quot;))+
  theme(legend.position = &quot;none&quot;)
rgb_gg_calo</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-138-1.png" width="672" /></p>
<pre class="r"><code>index_gg_calo = data_calo %&gt;% 
  filter(!index %in% c(&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;)) %&gt;% 
    ggplot(aes(mean, sev_roxa, label = file)) + 
  # geom_text()+
  geom_point(color = &quot;gray&quot;, size  =3)+
  geom_smooth(color = &quot;black&quot;, se = F, size = 2)+
  facet_wrap(~index, scales = &quot;free_x&quot;, nrow =2)+
  theme_minimal_hgrid()+
  labs(x = &quot;Mean index value in the image&quot;,
       y = &quot;Disease severity (%)&quot;)+
  theme(panel.border = element_rect(color = &quot;gray&quot;))
index_gg_calo</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-139-1.png" width="672" /></p>
<pre class="r"><code>plot_grid(
  plot_grid(NULL,rgb_gg_calo,NULL, rel_widths =c(0.18,1,0.2), nrow = 1),
          index_gg_calo,
          nrow = 2,
          rel_heights = c(0.5,1))</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;
## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-140-1.png" width="672" /></p>
<pre class="r"><code>ggsave(&quot;figs/index_sev_calo.png&quot;, dpi = 500, height = 8, width = 10)</code></pre>
<pre class="r"><code>cor_calo = data_calo %&gt;% 
  group_by(index) %&gt;% 
  dplyr::summarise(cor = round(  cor.test(mean,sev_roxa, method = &quot;spearman&quot;)$estimate,3),
                   P_value = round(cor.test(mean,sev_roxa, method = &quot;spearman&quot;)$p.value,4)) %&gt;% 
  arrange(-cor)</code></pre>
<pre><code>## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties

## Warning in cor.test.default(mean, sev_roxa, method = &quot;spearman&quot;): Cannot compute
## exact p-value with ties</code></pre>
<pre><code>## `summarise()` ungrouping output (override with `.groups` argument)</code></pre>
<pre class="r"><code>cor_calo</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["index"],"name":[1],"type":["chr"],"align":["left"]},{"label":["cor"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["P_value"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"HUE","2":"0.982","3":"0.0000"},{"1":"SCI","2":"0.773","3":"0.0000"},{"1":"Red","2":"0.754","3":"0.0000"},{"1":"SI","2":"0.678","3":"0.0000"},{"1":"HI","2":"0.621","3":"0.0000"},{"1":"BI","2":"0.568","3":"0.0000"},{"1":"gray","2":"0.479","3":"0.0000"},{"1":"BGI","2":"0.405","3":"0.0000"},{"1":"Blue","2":"0.360","3":"0.0000"},{"1":"Green","2":"0.065","3":"0.2643"},{"1":"GLI","2":"-0.736","3":"0.0000"},{"1":"VARI","2":"-0.743","3":"0.0000"},{"1":"NGRDI","2":"-0.773","3":"0.0000"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
</div>
<div id="spread-df-3" class="section level3">
<h3>Spread df</h3>
<pre class="r"><code>all_data_spread_calo = data_calo %&gt;% 
  pivot_wider(id_col = c(file,sev_roxa),
              names_from = index, 
              values_from =  mean) %&gt;% 
  mutate(sev = sev_roxa) %&gt;% 
  dplyr::select(-sev_roxa)

head(all_data_spread_calo)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["file"],"name":[1],"type":["chr"],"align":["left"]},{"label":["BGI"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["BI"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["Blue"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["GLI"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["gray"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["Green"],"name":[7],"type":["dbl"],"align":["right"]},{"label":["HI"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["HUE"],"name":[9],"type":["dbl"],"align":["right"]},{"label":["NGRDI"],"name":[10],"type":["dbl"],"align":["right"]},{"label":["Red"],"name":[11],"type":["dbl"],"align":["right"]},{"label":["SCI"],"name":[12],"type":["dbl"],"align":["right"]},{"label":["SI"],"name":[13],"type":["dbl"],"align":["right"]},{"label":["VARI"],"name":[14],"type":["dbl"],"align":["right"]},{"label":["sev"],"name":[15],"type":["dbl"],"align":["right"]}],"data":[{"1":"1","2":"0.6882197","3":"87.79606","4":"75.18746","5":"0.224798612","6":"93.79712","7":"111.2791","8":"-0.9847117","9":"-1.205552","10":"0.2649870","11":"66.57161","12":"-0.2649870","13":"-0.079926311","14":"0.4723708","15":"13.204752"},{"1":"10","2":"0.7326462","3":"151.64523","4":"109.29395","5":"0.009936558","6":"155.41167","7":"149.2397","8":"2.7492952","9":"1.303940","10":"-0.1012609","11":"185.11183","12":"0.1012609","13":"0.254983627","14":"-0.1452390","15":"90.115078"},{"1":"100","2":"0.6775662","3":"95.31257","4":"82.53846","5":"0.230691558","6":"102.41756","7":"122.0173","8":"-1.0425429","9":"-1.362278","10":"0.2736601","11":"71.51841","12":"-0.2736601","13":"-0.084985140","14":"0.5005331","15":"5.935931"},{"1":"101","2":"0.6607986","3":"97.47074","4":"79.85178","5":"0.203593527","6":"105.15663","7":"121.5156","8":"-0.4899614","9":"-1.266092","10":"0.2026749","11":"82.68859","12":"-0.2026749","13":"0.004990806","14":"0.3418387","15":"7.430647"},{"1":"102","2":"0.6307378","3":"87.31118","4":"71.86025","5":"0.257009366","6":"94.58699","7":"114.0222","8":"-1.0501503","9":"-1.347605","10":"0.2905345","11":"65.09655","12":"-0.2905345","13":"-0.067849610","14":"0.4992782","15":"6.274879"},{"1":"103","2":"0.5985339","3":"90.35100","4":"69.09128","5":"0.242727713","6":"98.69131","7":"116.9304","8":"-0.5163754","9":"-1.232165","10":"0.2332942","11":"74.16980","12":"-0.2332942","13":"0.024057502","14":"0.3770632","15":"16.696985"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
</div>
<div id="gbm-4" class="section level3">
<h3>GBM</h3>
<pre class="r"><code>train=sample(x = 1:length(all_data_spread_calo$sev), 
             size = round(0.75*length(all_data_spread_calo$sev),1))
# length(train)
gbm.fit = gbm(sev ~BGI+BI+GLI+HI+HUE+NGRDI+VARI+gray+ Red+Green+Blue  + SI + SCI,
             data = all_data_spread_calo[train,],
             distribution = &quot;gaussian&quot;,
              n.trees = 1000,
             interaction.depth = 3,
             shrinkage = 0.1,
             cv.folds = 5,
             n.cores = NULL, # will use all cores by default
             verbose = FALSE)
print(gbm.fit)</code></pre>
<pre><code>## gbm(formula = sev ~ BGI + BI + GLI + HI + HUE + NGRDI + VARI + 
##     gray + Red + Green + Blue + SI + SCI, distribution = &quot;gaussian&quot;, 
##     data = all_data_spread_calo[train, ], n.trees = 1000, interaction.depth = 3, 
##     shrinkage = 0.1, cv.folds = 5, verbose = FALSE, n.cores = NULL)
## A gradient boosted model with gaussian loss function.
## 1000 iterations were performed.
## The best cross-validation iteration was 188.
## There were 13 predictors of which 13 had non-zero influence.</code></pre>
<pre class="r"><code>sqrt(min(gbm.fit$cv.error))</code></pre>
<pre><code>## [1] 4.383517</code></pre>
<pre class="r"><code>gbm.perf(gbm.fit, method = &quot;cv&quot;)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-144-1.png" width="672" /></p>
<pre><code>## [1] 188</code></pre>
<pre class="r"><code># find index for n trees with minimum CV error</code></pre>
<pre class="r"><code>min_MSE &lt;- which.min(gbm.fit$cv.error)
sqrt(gbm.fit$cv.error[min_MSE])</code></pre>
<pre><code>## [1] 4.383517</code></pre>
<pre class="r"><code># best.iter &lt;- gbm.perf(model1, method = &quot;test&quot;)
# print(best.iter)

pred = predict(gbm.fit, newdata = all_data_spread_calo[-train,-1], ntrees = 5000 )</code></pre>
<pre><code>## Using 188 trees...</code></pre>
<pre class="r"><code>sqrt(mean(((pred)-all_data_spread_calo$sev[-train])^2))</code></pre>
<pre><code>## [1] 3.630006</code></pre>
<pre class="r"><code>CCC((pred), all_data_spread_calo$sev[-train])$rho.c$est</code></pre>
<pre><code>## [1] 0.9637904</code></pre>
<pre class="r"><code>plot((pred), (pred)-all_data_spread_calo$sev[-train])
abline(a=0,b=0)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-146-1.png" width="672" /></p>
</div>
<div id="testing-various-hyperparameters-4" class="section level3">
<h3>Testing various hyperparameters</h3>
<p>Create hyperparameter grid</p>
<pre class="r"><code>hyper_grid &lt;- expand.grid(
  shrinkage = c(.001, .01, .1, .3),
  interaction.depth = c(1, 3, 5, 6),
  n.minobsinnode = c(5, 10, 15),
  bag.fraction = c(.5,.65, .8, 1), 
  optimal_trees = 0,               # a place to dump results
  min_RMSE = 0,
  CCC =0 # a place to dump results
)
# total number of combinations
nrow(hyper_grid)</code></pre>
<pre><code>## [1] 192</code></pre>
<pre class="r"><code># randomize data
set.seed(1234)
train=sample(x = 1:length(all_data_spread_calo$sev), 
             size = round(0.80*length(all_data_spread_calo$sev),1))

# grid search 
for(i in 1:nrow(hyper_grid)) {

# reproducibility
set.seed(123)


 # train model
gbm.tune &lt;- gbm(
  formula = sev ~BGI+BI+GLI+HI+HUE+NGRDI+VARI+gray+ Red+Green+Blue  + SI + SCI, 
  data = all_data_spread_calo[train,],
  distribution = &quot;gaussian&quot;,
  n.trees = 5000,
  interaction.depth = hyper_grid$interaction.depth[i],
  shrinkage = hyper_grid$shrinkage[i],
  n.minobsinnode = hyper_grid$n.minobsinnode[i],
  bag.fraction = hyper_grid$bag.fraction[i],
  train.fraction = .75,
  n.cores = NULL, # will use all cores by default
  verbose = FALSE)

pred = predict(gbm.tune, newdata = all_data_spread_calo[-train,-1], ntrees = 5000 )
 # add min training error and trees to grid
  hyper_grid$optimal_trees[i] &lt;- which.min(gbm.tune$valid.error)
  hyper_grid$min_RMSE[i] &lt;- sqrt(min(gbm.tune$valid.error))
  hyper_grid$CCC[i] = CCC((pred), all_data_spread_calo$sev[-train])$rho.c$est
  
}

best_par = hyper_grid %&gt;% 
  dplyr::arrange(-CCC) %&gt;%
  head(10)
best_par</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["shrinkage"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["interaction.depth"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["n.minobsinnode"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["bag.fraction"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["optimal_trees"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["min_RMSE"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["CCC"],"name":[7],"type":["dbl"],"align":["right"]}],"data":[{"1":"0.300","2":"3","3":"5","4":"1","5":"53","6":"3.188960","7":"0.9921566","_rn_":"1"},{"1":"0.100","2":"1","3":"5","4":"1","5":"843","6":"2.913543","7":"0.9917062","_rn_":"2"},{"1":"0.010","2":"1","3":"5","4":"1","5":"4991","6":"3.008064","7":"0.9912300","_rn_":"3"},{"1":"0.300","2":"1","3":"5","4":"1","5":"262","6":"3.429057","7":"0.9907054","_rn_":"4"},{"1":"0.100","2":"3","3":"5","4":"1","5":"213","6":"2.960664","7":"0.9906812","_rn_":"5"},{"1":"0.001","2":"5","3":"5","4":"1","5":"5000","6":"3.378191","7":"0.9904229","_rn_":"6"},{"1":"0.001","2":"6","3":"5","4":"1","5":"5000","6":"3.403406","7":"0.9903718","_rn_":"7"},{"1":"0.300","2":"6","3":"5","4":"1","5":"44","6":"3.064615","7":"0.9901287","_rn_":"8"},{"1":"0.300","2":"5","3":"5","4":"1","5":"51","6":"3.177959","7":"0.9900388","_rn_":"9"},{"1":"0.001","2":"3","3":"5","4":"1","5":"5000","6":"3.297901","7":"0.9900336","_rn_":"10"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code># gbm.tune$fit</code></pre>
</div>
<div id="best-model-4" class="section level3">
<h3>Best model</h3>
<pre class="r"><code># for reproducibility
set.seed(123)

# train GBM model
gbm.fit.final_calo &lt;- gbm(
  formula = sev ~BGI+BI+GLI+HI+HUE+NGRDI+VARI+gray+ Red+Green+Blue  + SI + SCI, 
  data = all_data_spread_calo[train,],
  distribution = &quot;gaussian&quot;,
  n.trees = best_par$optimal_trees[1],
  interaction.depth = best_par$interaction.depth[1],
  shrinkage = best_par$shrinkage[1],
  n.minobsinnode = best_par$n.minobsinnode[1],
  bag.fraction = best_par$bag.fraction[1], 
  train.fraction =0.75,
  n.cores = NULL, # will use all cores by default
  verbose = FALSE
  )</code></pre>
</div>
<div id="relative-influence-4" class="section level3">
<h3>Relative influence</h3>
<pre class="r"><code>par(mar = c(5, 8, 1, 1))
summary_gbm_calo = summary(
  gbm.fit.final_calo, 
  cBars = 13,
  method = relative.influence, # also can use permutation.test.gbm
  las = 2
  )</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-150-1.png" width="672" /></p>
<pre class="r"><code>rel_calo = summary_gbm_calo %&gt;% 
  rownames_to_column(&quot;index&quot;) %&gt;% 
  ggplot(aes(rel.inf, reorder(var, rel.inf)))+
  geom_col(aes(fill =rel.inf&gt;1, color =rel.inf&gt;1 ), width = 0.85)+
  theme_minimal_vgrid()+
  labs(x = &quot;Relative influence (%)&quot;,
       y = &quot;Model predictors&quot;,
       fill = &quot;RI &gt; 1%&quot;,
       color = &quot;RI &gt; 1%&quot;)
rel_calo</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-150-2.png" width="672" /></p>
<pre class="r"><code># ggsave(&quot;figs/var_influence.png&quot;,dpi = 600, height = 4, width = 6)</code></pre>
<p>Partial dependence plots</p>
<pre class="r"><code>gbm.fit.final_calo %&gt;%
  pdp::partial(pred.var = &quot;HUE&quot;, n.trees = gbm.fit.final_calo$n.trees, grid.resolution = 100) %&gt;%
  ggplot(aes( HUE,(yhat)))+
  geom_line()</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-151-1.png" width="672" /></p>
<p>LIME</p>
<pre class="r"><code>library(lime)</code></pre>
<pre class="r"><code>model_type.gbm &lt;- function(x, ...) {
  return(&quot;regression&quot;)
}

predict_model.gbm &lt;- function(x, newdata, ...) {
  pred &lt;- predict(x, newdata, n.trees = x$n.trees)
  return(as.data.frame(pred))
}</code></pre>
<pre class="r"><code># get a few observations to perform local interpretation on
local_obs &lt;- (all_data_spread_calo[-train,])[1:4, ]

# apply LIME
explainer &lt;- lime(all_data_spread_calo[train,], gbm.fit.final_calo)
explanation &lt;- lime::explain(local_obs, explainer, n_features = 7, n.trees =1)
plot_features(explanation)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-154-1.png" width="672" /></p>
</div>
<div id="prediction-4" class="section level2">
<h2>Prediction</h2>
<pre class="r"><code># predict values for test data
pred &lt;- predict(gbm.fit.final_calo, n.trees = gbm.fit.final_calo$n.trees, all_data_spread_calo[-train,])

# results
caret::RMSE(pred, all_data_spread_calo[-train,]$sev)</code></pre>
<pre><code>## [1] 2.358233</code></pre>
<pre class="r"><code>CCC(pred, all_data_spread_calo$sev[-train])$rho.c$est</code></pre>
<pre><code>## [1] 0.9921566</code></pre>
<pre class="r"><code>cor(pred, all_data_spread_calo$sev[-train])^2</code></pre>
<pre><code>## [1] 0.9872815</code></pre>
<pre class="r"><code>accuracy_calo = data.frame(predi=pred, actual = all_data_spread_calo$sev[-train]) %&gt;% 
  summarise(RMSE = caret::RMSE(pred, actual),
            r = cor(pred, actual),
            s.shift = CCC(pred, actual)$s.shift,
            l.shift = CCC(pred, actual)$l.shift,
            C.b = CCC(pred, actual)$C.b,
            CCC = CCC(pred, actual)$rho.c$est,
            CIS = paste(
  round(CCC(pred, all_data_spread_calo$sev[-train])$rho.c[2],2),&quot;,&quot;,&quot; &quot;,
  round(CCC(pred, all_data_spread_calo$sev[-train])$rho.c[3],2),sep = &quot;&quot;
  ))
accuracy_calo</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["RMSE"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["r"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["s.shift"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["l.shift"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["C.b"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["CCC"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["CIS"],"name":[7],"type":["chr"],"align":["left"]}],"data":[{"1":"2.358233","2":"0.9936204","3":"1.047502","4":"0.02822577","5":"0.9985268","6":"0.9921566","7":"0.99, 1"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<div id="plot-4" class="section level4">
<h4>plot</h4>
<pre class="r"><code>conc_calo = data.frame(predict = pred, actual =all_data_spread_calo$sev[-train]) %&gt;% 
ggplot(aes(actual,predict))+
  geom_point(size =2, color = &quot;gray&quot;)+
  geom_abline(intercept = 0, slope= 1, size = .81, color = &quot;black&quot;, linetype = &quot;dashed&quot;)+
  geom_smooth(method = &quot;lm&quot;, 
              color = &quot;red&quot;,
              size =.81, se =F,
              fullrange=T)+
  theme_minimal_grid()+
  labs(x = &quot;Predicted Severity (%)&quot;,
       y = &quot;Actual Severity (%)&quot;)+
  coord_equal(xlim = c(0,100),
              ylim = c(0,100))+
  xlim(0,100)


# ggsave(&quot;figs/concordance.png&quot;, dpi = 600, height = 3.5, width = 4)</code></pre>
</div>
</div>
</div>
<div id="correlation" class="section level1">
<h1>Correlation</h1>
<pre class="r"><code>ind_order = c(&quot;Red&quot;,&quot;Green&quot;,&quot;Blue&quot;,&quot;BI&quot;,&quot;SCI&quot;,&quot;GLI&quot;,&quot;HI&quot;,&quot;NGRDI&quot;,&quot;SI&quot;,&quot;VARI&quot;,&quot;HUE&quot;,&quot;BGI&quot;,&quot;gray&quot;)
bind_rows(
cor_sbr %&gt;% mutate(disease=&quot;SBR&quot;),
cor_calo %&gt;% mutate(disease=&quot;CLB&quot;),
cor_xy %&gt;% mutate(disease=&quot;NtXf&quot;),
cor_wlb %&gt;% mutate(disease=&quot;WLB&quot;),
cor_PI %&gt;% mutate(disease=&quot;PLB&quot;)) %&gt;% 
  mutate(sig = case_when(P_value &lt;0.05 ~ &quot; &quot;,
                         P_value &gt;0.05 ~ &quot;P&gt;0.05&quot;)) %&gt;% 
  mutate(disease = factor(disease, levels = c(&quot;PLB&quot;, &quot;WLB&quot;,&quot;NtXf&quot;,&quot;CLB&quot;, &quot;SBR&quot;)),
         index = factor(index, levels = ind_order)) %&gt;% 
  ggplot(aes(index,disease, fill = cor, label = round(cor,3)))+
  geom_tile()+
  geom_text(size =3.5)+
  geom_point(aes(index,disease, color = sig), shape = &quot;X&quot;, size =8, alpha = 0.6)+
  # scale_fill_gradient2(low = &quot;darkred&quot;, mid = NA, high = &quot;darkgreen&quot;)+
  scale_fill_distiller(palette = &quot;RdBu&quot;, direction = 1)+
  scale_color_manual(values = c(NA,&quot;black&quot;))+
  theme_half_open()+
  labs(x = &quot;&quot;,
       y = &quot;&quot;, 
       fill = &quot;  r&quot;,
       color =&quot;&quot;)</code></pre>
<pre><code>## Warning: Removed 59 rows containing missing values (geom_point).</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-158-1.png" width="672" /></p>
<pre class="r"><code>ggsave(&quot;figs/corr.png&quot;,dpi = 600, height = 3.5, width =10)</code></pre>
<pre><code>## Warning: Removed 59 rows containing missing values (geom_point).</code></pre>
</div>
<div id="relative-influence-combo" class="section level1">
<h1>Relative influence combo</h1>
<pre class="r"><code># summary_gbm_sbr
# summary_gbm_calo
# summary_gbm_xy
# summary_gbm_wlb
# summary_gbm_plb</code></pre>
<pre class="r"><code>rel_sbr + labs(title = paste(&quot;Soybean rust&quot;))+
  rel_calo +labs(title = paste(&quot;Calonectria leaf blight&quot;))+
  rel_wlb +labs(title = paste(&quot;Wheat leaf blast&quot;))+
  rel_plb +labs(title = paste(&quot;Potato late blight&quot;))+
  rel_xy +labs(title = expression(bolditalic(&quot;N. tabacum-X. fastidiosa&quot;)))+guide_area()+
  plot_layout(ncol =3, guides = &quot;collect&quot;)+
  plot_annotation(tag_levels = &#39;A&#39;)&amp;
  theme_minimal_grid(font_size = 9)&amp;
  theme(plot.title = element_text(size =8))&amp;
  xlim(0,100)</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-160-1.png" width="672" /></p>
<pre class="r"><code>ggsave(&quot;figs/relative_influence_combo.png&quot;, dpi = 300, height = 5, width = 6)</code></pre>
<pre class="r"><code>biplot_ri = function(data_cor, data_ri, title, face=&quot;plain&quot;){

data_ri %&gt;% 
  rename(index = var) %&gt;% 
  full_join(data_cor) %&gt;% 
  ggplot(aes(rel.inf,abs(cor),label = index, color = index))+
  # geom_smooth(color = &quot;gray90&quot;,se = F)+
  geom_point(size = 3)+
  ggrepel::geom_text_repel(size=3)+
  coord_cartesian(xlim = c(0,100),
                  ylim = c(0,1))+
  theme_minimal()+
  theme(legend.position = &quot;none&quot;,
        panel.grid = element_blank(),
        plot.title = element_text(size = 10, face = face),
        axis.ticks = element_line(color = &quot;gray&quot;),
        axis.line = element_line(color = &quot;gray&quot;))+
  labs(y = &quot;Absolute Spearman&#39;s r&quot;,
       x = &quot;Relative Influence (%)&quot;,
       title  = paste(title))
}</code></pre>
<pre class="r"><code>biplot_ri(data_cor = cor_sbr, data_ri = summary_gbm_sbr, title = &quot;Soybean rust&quot;)+
biplot_ri(data_cor = cor_calo, data_ri = summary_gbm_calo, title = &quot;Calonectria leaf blight&quot;)+
  biplot_ri(data_cor = cor_xy, data_ri = summary_gbm_xy, title = &quot;N. tabacum-X. fastidiosa&quot;,face = &quot;italic&quot;)+
  biplot_ri(data_cor = cor_wlb, data_ri = summary_gbm_wlb, title = &quot;Wheat leaf blast&quot;)+
  biplot_ri(data_cor = cor_PI, data_ri = summary_gbm_plb, title = &quot;Potato late blight&quot;)+
  plot_layout(nrow = 3,
              ncol = 2)+
  plot_annotation(tag_levels = &quot;A&quot;)+
ggsave(&quot;figs/ri_cor.png&quot;,dpi = 300, height = 8, width =6)</code></pre>
<pre><code>## Joining, by = &quot;index&quot;
## Joining, by = &quot;index&quot;
## Joining, by = &quot;index&quot;
## Joining, by = &quot;index&quot;
## Joining, by = &quot;index&quot;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-162-1.png" width="672" /></p>
<div id="agreement" class="section level3">
<h3>Agreement</h3>
<pre class="r"><code> conc_sbr+labs(title = paste(&quot;Soybean rust&quot;),
               subtitle = paste(&quot;RMSE = &quot;,round(accuracy_sbr$RMSE,2),&quot;, &quot;,
                                &quot;CCC = &quot;,round(accuracy_sbr$CCC,3)))+
  conc_calo+labs(title = paste(&quot;Calonectria leaf blight&quot;),
               subtitle = paste(&quot;RMSE = &quot;,round(accuracy_calo$RMSE,2),&quot;, &quot;,
                                &quot;CCC = &quot;,round(accuracy_calo$CCC,3)))+
  conc_wlb+labs(title = paste(&quot;Wheat leaf blast&quot;),
               subtitle = paste(&quot;RMSE = &quot;,round(accuracy_wlb$RMSE,2),&quot;, &quot;,
                                &quot;CCC = &quot;,round(accuracy_wlb$CCC,3)))+
  conc_pi+labs(title = paste(&quot;Potato late blight&quot;),
               subtitle = paste(&quot;RMSE = &quot;,round(accuracy_pi$RMSE,2),&quot;, &quot;,
                                &quot;CCC = &quot;,round(accuracy_pi$CCC,3)))+
  conc_xy+labs(title = expression(bolditalic(&quot;N. tabacum-X. fastidiosa&quot;)),
               subtitle = paste(&quot;RMSE = &quot;,round(accuracy_xy$RMSE,2),&quot;, &quot;,
                                &quot;CCC = &quot;,round(accuracy_xy$CCC,3)))+
  
  
   plot_layout(ncol = 3,
               widths = c(1, 1,1),
               heights = c(1,1))+

  plot_annotation(tag_levels = &#39;A&#39;)&amp;
    theme_minimal_grid(font_size = 10)&amp;
  theme(plot.title = element_text(size =10, face =&quot;bold&quot;),
      plot.subtitle = element_text(size =10, face = &quot;plain&quot;))</code></pre>
<pre><code>## `geom_smooth()` using formula &#39;y ~ x&#39;
## `geom_smooth()` using formula &#39;y ~ x&#39;
## `geom_smooth()` using formula &#39;y ~ x&#39;
## `geom_smooth()` using formula &#39;y ~ x&#39;
## `geom_smooth()` using formula &#39;y ~ x&#39;</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-163-1.png" width="672" /></p>
<pre class="r"><code>ggsave(&quot;figs/concordance.png&quot;, dpi = 600, height = 6, width = 8)</code></pre>
<pre><code>## `geom_smooth()` using formula &#39;y ~ x&#39;
## `geom_smooth()` using formula &#39;y ~ x&#39;
## `geom_smooth()` using formula &#39;y ~ x&#39;
## `geom_smooth()` using formula &#39;y ~ x&#39;
## `geom_smooth()` using formula &#39;y ~ x&#39;</code></pre>
</div>
</div>
<div id="rgb-bands-by-leaf" class="section level1">
<h1>RGB bands by leaf</h1>
<div id="function" class="section level4">
<h4>Function</h4>
<pre class="r"><code>density_rgb2 = function(
file_low = &quot;./pics/01-soybean-rust-bg-blue/Ferrugem 52_Median.jpg&quot;,
file_high = &quot;./pics/01-soybean-rust-bg-blue/Ferrugem 49_Median.jpg&quot;,
limiar = 100,
index_cut = &quot;Blue&quot;,
cropAbove=T,
title = &quot;Soybean Rust&quot;,face = &quot;plain&quot;){

#-------------------------------------------------------------------------------------------------
SBR_low_EX.L1&lt;-stack(paste(file_low ))
SBR_low_EX.L1&lt;-aggregate(SBR_low_EX.L1, fact=5)

SBR_low_EX.L2&lt;-fieldMask(mosaic=SBR_low_EX.L1, myIndex = c(index_cut), cropValue=limiar, cropAbove=cropAbove, plot = F)

cut = mask(SBR_low_EX.L1, SBR_low_EX.L2$newMosaic)
SBR_low_EX.L4&lt;-fieldIndex(mosaic=cut,
                  # index =index,
                  plot =F)

SBR_low = RStoolbox::ggRGB(SBR_low_EX.L2$newMosaic,r = 1,g = 2,b = 3)+
  theme_map()+coord_fixed()+
  theme(panel.background = element_rect(color = NA, fill = NA),
        plot.title = element_text(size=8, face = &quot;plain&quot;))+
  labs(title = &quot;Low&quot;)

SBR_low_comb = data.frame(R = as.data.frame(SBR_low_EX.L4$Red),
           G = as.data.frame(SBR_low_EX.L4$Blue),
           B = as.data.frame(SBR_low_EX.L4$Green)) %&gt;%
  na.omit() %&gt;% 
  pivot_longer(1:3,names_to = &quot;band&quot;, values_to = &quot;value&quot;) %&gt;%
  mutate(sev=&quot;Low&quot;)
#-------------------------------------------------------------------------------------------------

SBR_high_EX.L1&lt;-stack(paste(file_high))
SBR_high_EX.L1&lt;-aggregate(SBR_high_EX.L1, fact=5)

SBR_high_EX.L2&lt;-fieldMask(mosaic=SBR_high_EX.L1,  myIndex = c(index_cut), cropValue=limiar, cropAbove=cropAbove, plot = F)

cut = mask(SBR_high_EX.L1, SBR_high_EX.L2$newMosaic)
SBR_high_EX.L4&lt;-fieldIndex(mosaic=cut,
                  # index =index,
                  plot =F)

SBR_high = RStoolbox::ggRGB(SBR_high_EX.L2$newMosaic,r = 1,g = 2,b = 3)+
  theme_map()+coord_fixed()+
  theme(panel.background = element_rect(color = NA, fill = NA),
        plot.title = element_text(size=8, face = &quot;plain&quot;))+
  labs(title = &quot;High&quot;)

SBR_high_comb = data.frame(R = as.data.frame(SBR_high_EX.L4$Red),
           G = as.data.frame(SBR_high_EX.L4$Blue),
           B = as.data.frame(SBR_high_EX.L4$Green)) %&gt;%
  na.omit() %&gt;% 
  pivot_longer(1:3,names_to = &quot;band&quot;, values_to = &quot;value&quot;) %&gt;%
  mutate(sev=&quot;High&quot;)

#-------------------------------------------------------------------------------------------------
all_comb = bind_rows(SBR_low_comb,SBR_high_comb) %&gt;% 
  mutate(sev =factor(sev, levels =c(&quot;Low&quot;,&quot;High&quot;)))
#-------------------------------------------------------------------------------------------------

all_comb %&gt;% 
  ggplot(aes(value,sev))+
  stat_slab(aes(fill = band), alpha = 0.7)+
   stat_pointinterval(aes(color = band),
                      position = position_dodge(width = .5, preserve = &quot;single&quot;),
                     # color = &quot;gray40&quot;,
                     .width = c(0,0.95))+
  
  scale_fill_manual(values = c(&quot;blue&quot;, &quot;green&quot;,&quot;red&quot; ))+
  scale_color_manual(values = c(&quot;blue&quot;, &quot;green&quot;,&quot;red&quot; ))+
  theme_minimal()+
  xlim(0,255)+
  theme(panel.grid = element_blank(),
        plot.title = element_text(size = 10, face = face),
        axis.ticks = element_line(color = &quot;gray&quot;),
        axis.line = element_line(color = &quot;gray&quot;))+
  labs(x = &quot;Pixel intensity&quot;,
       y = &quot;Severity&quot;,
       fill =&quot;&quot;,
       title = paste(title))+  
  guides(color =F)#+
  #SBR_low+SBR_high+
  #plot_layout(widths = c(1, .2,.2))
}</code></pre>
</div>
<div id="plots" class="section level3">
<h3>plots</h3>
<div id="combo" class="section level4">
<h4>combo</h4>
<pre class="r"><code>(SBR_dist+calo_dist+xy_dist+wlb_dist+plb_dist+guide_area())+
  plot_layout(nrow = 3,
              ncol = 2,
              tag_level = &quot;keep&quot;,
              # widths = c(1,1,1,1,1),
              guides = &#39;collect&#39;)+
  plot_annotation(tag_levels = &quot;A&quot;)+
  # plot_annotation(tag_levels = list(tags2))&amp;
  theme(legend.key.size = unit(5, &#39;mm&#39;),
        legend.position = &quot;none&quot;,
        legend.text = element_text(size =10))</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-166-1.png" width="576" /></p>
<pre class="r"><code>ggsave(&quot;figs/RGB_dens2.png&quot;,dpi = 600, height = 7, width =6)</code></pre>
<pre class="r"><code>density_rgb_images = function(
file_low = &quot;./pics/01-soybean-rust-bg-blue/Ferrugem 52_Median.jpg&quot;,
file_high = &quot;./pics/01-soybean-rust-bg-blue/Ferrugem 49_Median.jpg&quot;,
limiar = 100,
index_cut = &quot;Blue&quot;,
cropAbove=T,
title = &quot;Soybean Rust&quot;,face = &quot;plain&quot;){

#-------------------------------------------------------------------------------------------------
SBR_low_EX.L1&lt;-stack(paste(file_low ))
SBR_low_EX.L1&lt;-aggregate(SBR_low_EX.L1, fact=5)

SBR_low_EX.L2&lt;-fieldMask(mosaic=SBR_low_EX.L1, myIndex = c(index_cut), cropValue=limiar, cropAbove=cropAbove, plot = F)

cut = mask(SBR_low_EX.L1, SBR_low_EX.L2$newMosaic)
SBR_low_EX.L4&lt;-fieldIndex(mosaic=cut,
                  # index =index,
                  plot =F)

SBR_low = RStoolbox::ggRGB(SBR_low_EX.L2$newMosaic,r = 1,g = 2,b = 3)+
  theme_map()+coord_fixed()+
  theme(panel.background = element_rect(color = NA, fill = NA),
        plot.title = element_text(size=8, face = &quot;plain&quot;))#+
  # labs(title = &quot;Low&quot;)

SBR_low_comb = data.frame(R = as.data.frame(SBR_low_EX.L4$Red),
           G = as.data.frame(SBR_low_EX.L4$Blue),
           B = as.data.frame(SBR_low_EX.L4$Green)) %&gt;%
  na.omit() %&gt;% 
  pivot_longer(1:3,names_to = &quot;band&quot;, values_to = &quot;value&quot;) %&gt;%
  mutate(sev=&quot;Low&quot;)
#-------------------------------------------------------------------------------------------------

SBR_high_EX.L1&lt;-stack(paste(file_high))
SBR_high_EX.L1&lt;-aggregate(SBR_high_EX.L1, fact=5)

SBR_high_EX.L2&lt;-fieldMask(mosaic=SBR_high_EX.L1,  myIndex = c(index_cut), cropValue=limiar, cropAbove=cropAbove, plot = F)

cut = mask(SBR_high_EX.L1, SBR_high_EX.L2$newMosaic)
SBR_high_EX.L4&lt;-fieldIndex(mosaic=cut,
                  # index =index,
                  plot =F)

SBR_high = RStoolbox::ggRGB(SBR_high_EX.L2$newMosaic,r = 1,g = 2,b = 3)+
  theme_map()+coord_fixed()+
  theme(panel.background = element_rect(color = NA, fill = NA),
        plot.title = element_text(size=8, face = &quot;plain&quot;))#+
  # labs(title = &quot;High&quot;)

SBR_high_comb = data.frame(R = as.data.frame(SBR_high_EX.L4$Red),
           G = as.data.frame(SBR_high_EX.L4$Blue),
           B = as.data.frame(SBR_high_EX.L4$Green)) %&gt;%
  na.omit() %&gt;% 
  pivot_longer(1:3,names_to = &quot;band&quot;, values_to = &quot;value&quot;) %&gt;%
  mutate(sev=&quot;High&quot;)

#-------------------------------------------------------------------------------------------------
all_comb = bind_rows(SBR_low_comb,SBR_high_comb) %&gt;% 
  mutate(sev =factor(sev, levels =c(&quot;Low&quot;,&quot;High&quot;)))
#-------------------------------------------------------------------------------------------------

# all_comb %&gt;% 
#   ggplot(aes(value,sev))+
#   stat_slab(aes(fill = band), alpha = 0.7)+
#    stat_pointinterval(aes(color = band),
#                       position = position_dodge(width = .5, preserve = &quot;single&quot;),
#                      # color = &quot;gray40&quot;,
#                      .width = c(0,0.95))+
#   
#   scale_fill_manual(values = c(&quot;blue&quot;, &quot;green&quot;,&quot;red&quot; ))+
#   scale_color_manual(values = c(&quot;blue&quot;, &quot;green&quot;,&quot;red&quot; ))+
#   theme_minimal()+
#   xlim(0,255)+
#   theme(panel.grid = element_blank(),
#         plot.title = element_text(size = 10, face = face),
#         axis.ticks = element_line(color = &quot;gray&quot;),
#         axis.line = element_line(color = &quot;gray&quot;))+
#   labs(x = &quot;Pixel intensity&quot;,
#        y = &quot;Severity&quot;,
#        fill =&quot;&quot;,
#        title = paste(title))+  
#   guides(color =F)#+
  SBR_low|SBR_high
  #plot_layout(widths = c(1, .2,.2))
}</code></pre>
</div>
</div>
<div id="plots-1" class="section level3">
<h3>plots</h3>
<div id="combo-1" class="section level4">
<h4>combo</h4>
<pre class="r"><code>SBR_dist_img/calo_dist_img/xy_dist_img/wlb_dist_img/plb_dist_img+
  plot_layout(ncol = 1,
              nrow =5)+
  plot_annotation(tag_levels = &quot;A&quot;)&amp;
  theme(legend.text = element_text(size =10))</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-169-1.png" width="576" /></p>
<pre class="r"><code>ggsave(&quot;figs/RGB_dens_img.png&quot;,dpi = 900, height = 6, width =3)</code></pre>
</div>
</div>
<div id="principal-component-analysis" class="section level2">
<h2>Principal component analysis</h2>
<div id="sbr" class="section level3">
<h3>SBR</h3>
<pre class="r"><code>pca_sbr = PCA(all_data_spread_sbr[2:15], graph = F)
biplot_sbr = fviz_pca_biplot(pca_sbr, geom = &quot;point&quot;,
                geom.var = c(&quot;text&quot;,&quot;arrow&quot;),
                col.ind = all_data_spread_sbr$sev, 
                col.var = &quot;black&quot;,
                repel = T,
                labelsize = 2)+
  labs(title = &quot;Soybean rust&quot;)+
  scale_color_gradient(low = &quot;gray90&quot;, high = &quot;gray40&quot;, name = &quot;Severity (%)&quot;, limits =c(0,100))</code></pre>
<pre><code>## Registered S3 methods overwritten by &#39;car&#39;:
##   method                          from
##   influence.merMod                lme4
##   cooks.distance.influence.merMod lme4
##   dfbeta.influence.merMod         lme4
##   dfbetas.influence.merMod        lme4</code></pre>
</div>
<div id="calonectria" class="section level3">
<h3>Calonectria</h3>
<pre class="r"><code>pca_calo = PCA(all_data_spread_calo[2:15], graph = F)
biplot_calo = fviz_pca_biplot(pca_calo, geom = &quot;point&quot;,
                geom.var = c(&quot;text&quot;,&quot;arrow&quot;),
                col.ind = all_data_spread_calo$sev, 
                col.var = &quot;black&quot;,
                repel = T,
                labelsize = 2)+
  labs(title = &quot;Calonectria leaf blight&quot;)+
  scale_color_gradient(low = &quot;gray90&quot;, high = &quot;gray40&quot;, name = &quot;Severity (%)&quot;, limits =c(0,100))</code></pre>
</div>
<div id="ntxf" class="section level3">
<h3>NtXf</h3>
<pre class="r"><code>pca_xy = PCA(all_data_spread_xy[2:15], graph = F)
biplot_xy = fviz_pca_biplot(pca_xy,  geom = &quot;point&quot;,
                geom.var = c(&quot;text&quot;,&quot;arrow&quot;),
                col.ind = all_data_spread_xy$sev, 
                col.var = &quot;black&quot;,
                repel = T,
                labelsize = 2)+
  labs(title = expression(italic(&quot;N. tabacum-X.fastidiosa&quot;)))+
  scale_color_gradient(low = &quot;gray90&quot;, high = &quot;gray40&quot;, name = &quot;Severity (%)&quot;, limits =c(0,100))</code></pre>
</div>
<div id="wlb" class="section level3">
<h3>WLB</h3>
<pre class="r"><code>pca_wlb = PCA(all_data_spread_wlb[2:15], graph = F)

biplot_wlb = fviz_pca_biplot(pca_wlb, geom = &quot;point&quot;,
                geom.var = c(&quot;text&quot;,&quot;arrow&quot;),
                col.ind = all_data_spread_wlb$sev, 
                col.var = &quot;black&quot;,
                repel = T,
                labelsize = 2)+
  labs(title = &quot;Wheat leaf blast&quot;)+
  scale_color_gradient(low = &quot;gray90&quot;, high = &quot;gray40&quot;, name = &quot;Severity (%)&quot;, limits =c(0,100))</code></pre>
<p>###PLB</p>
<pre class="r"><code>pca_plb = PCA(all_data_spread_plb[2:15], graph = F)
biplot_plb = fviz_pca_biplot(pca_plb, geom = &quot;point&quot;,
                geom.var = c(&quot;text&quot;,&quot;arrow&quot;),
                col.ind = all_data_spread_plb$sev, 
                col.var = &quot;black&quot;,
                repel = T,
                labelsize = 2)+
  labs(title = &quot;Potato late blight&quot;)+
  scale_color_gradient(low = &quot;gray90&quot;, high = &quot;gray40&quot;, name = &quot;Severity (%)&quot;, limits =c(0,100))</code></pre>
</div>
<div id="section" class="section level3">
<h3></h3>
<pre class="r"><code>biplot_sbr+biplot_calo+biplot_xy+biplot_wlb+biplot_plb+guide_area()+
  plot_layout(ncol = 2,
              guides = &quot;collect&quot;)+
  plot_annotation(tag_levels = &quot;A&quot;)&amp;
  theme_minimal()+
  theme(#legend.position = &quot;none&quot;,
        axis.text = element_text(size=8),
        axis.title = element_text(size=8),
        plot.title = element_text(size=10),
        panel.grid = element_blank(),
        axis.ticks = element_line(color = &quot;gray&quot;),
        axis.line = element_line(color = &quot;gray&quot;))</code></pre>
<p><img src="main_code_RGB_index_files/figure-html/unnamed-chunk-175-1.png" width="576" /></p>
<pre class="r"><code>ggsave(&quot;figs/biplots.png&quot;,dpi = 600, height = 8, width =6)</code></pre>
</div>
</div>
</div>

<div id="rmd-source-code">JSBEYXRhIGFuYWx5c2lzDQoNCiMgTmVjZXNzYXJ5IHBhY2thZ2VzDQoNCmBgYHtyIG1lc3NhZ2U9RkFMU0UsIHdhcm5pbmc9RkFMU0V9DQpsaWJyYXJ5KHRpZHl2ZXJzZSkNCmxpYnJhcnkoRklFTERpbWFnZVIpDQpsaWJyYXJ5KHJhc3RlcikNCmxpYnJhcnkocmVhZHhsKQ0KbGlicmFyeShnc2hlZXQpDQpsaWJyYXJ5KGZvcmVhY2gpDQpsaWJyYXJ5KGFncmljb2xhZSkNCmxpYnJhcnkocmVzaGFwZTIpDQpsaWJyYXJ5KGNvd3Bsb3QpDQpsaWJyYXJ5KGdibSkNCmxpYnJhcnkobGltZSkNCmxpYnJhcnkobG1lNCkNCmxpYnJhcnkoRGVzY1Rvb2xzKQ0KbGlicmFyeShmYWN0b2V4dHJhKQ0KbGlicmFyeShGYWN0b01pbmVSKQ0KbGlicmFyeShjb3JycGxvdCkNCmxpYnJhcnkobWFnaWNrKQ0KbGlicmFyeShwYXRjaHdvcmspDQpsaWJyYXJ5KGZvcmNhdHMpDQpsaWJyYXJ5KGdnZGlzdCkNCmBgYA0KDQojIEV4YW1wbGUgb2YgUkdCIGluZGljZXMgZm9yIG9uZSBpbWFnZQ0KDQpMb2FkIHBpY3R1cmVzIG5hbWVzDQoNCmBgYHtyfQ0KcGljczwtbGlzdC5maWxlcygiLi9waWNzLzAxLXNveWJlYW4tcnVzdC1iZy1ibHVlIikNCmxlbmd0aChwaWNzKQ0KIyB3cml0ZShwaWNzLCAicGljc19uYW1lcy50eHQiKQ0KDQpgYGANCg0KTGlzdCBvZiBSR0ItYmFzZWQgc3BlY3RyYWwgaW5kaWNlcyB0byBiZSBjYWxjdWxhdGVkIGluIHRoZSBpbWFnZQ0KDQpgYGB7cn0NCiMgVmVnZXRhdGlvbiBpbmRpY2VzDQppbmRleCA9IGMoIkJJIiwiU0NJIiwiR0xJIiwiSEkiLCJTSSIsIlZBUkkiLCJIVUUiLCJCR0kiLCJOR1JESSIpDQpgYGANCg0KTG9hZCBhIHNpbmdsZSBpbWFnZQ0KDQpgYGB7cn0NCiNDaG9vc2Ugb25lIGltYWdlIHRvIHByZXBhcmUgdGhlIHBpcGVsaW5lDQpFWC5MMTwtc3RhY2socGFzdGUoIi4vcGljcy8wMS1zb3liZWFuLXJ1c3QtYmctYmx1ZS8iLHBpY3NbMTEwXSxzZXAgPSAiIikpDQpFWC5MMTwtYWdncmVnYXRlKEVYLkwxLCBmYWN0PTcpDQpFWC5MLlNoYXBlPC1maWVsZFBvbHlnb24obW9zYWljPUVYLkwxLCBleHRlbnQ9VCwgcGxvdCA9VCkNCiMgcGxvdFJHQihFWC5MLlNoYXBlKQ0KYGBgDQoNCmBgYHtyfQ0KRVgxLkluZGljZXM8LSBmaWVsZEluZGV4KG1vc2FpYyA9IEVYLkwxLA0KICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaW5kZXgsIA0KICAgICAgICAgICAgICAgICAgICAgICAgIG15SW5kZXggPSBjKCJCbHVlIiksIHBsb3QgPSBUKQ0KYGBgDQoNCmBgYHtyfQ0KcGxvdChFWDEuSW5kaWNlcyRCbHVlKQ0KaGlzdChFWDEuSW5kaWNlcyRCbHVlKQ0KYGBgDQoNCiMjIyBtYXNrDQoNCmBgYHtyfQ0KIyBFWC5MMjwtZmllbGRNYXNrKG1vc2FpYz1FWC5MMSwgbXlJbmRleCA9ICJSZWQiLCBjcm9wVmFsdWU9MjAwLCBjcm9wQWJvdmU9VCwgcGxvdCA9IFQpDQojIEVYLkwyPC1maWVsZE1hc2sobW9zYWljPUVYLkwxLCBpbmRleCA9ICJCSSIsIGNyb3BWYWx1ZT0xLCBjcm9wQWJvdmU9RiwgcGxvdCA9IFQpDQpFWC5MMjwtZmllbGRNYXNrKG1vc2FpYz1FWC5MMSwgbXlJbmRleCA9IGMoIkJsdWUiKSwgY3JvcFZhbHVlPTkwLCBjcm9wQWJvdmU9VCwgcGxvdCA9IFQpDQojIHBsb3RSR0IoRVguTDIkbmV3TW9zYWljKQ0KcGxvdFJHQihFWC5MMiRuZXdNb3NhaWMpDQoNCg0KY2xhc3MoRVguTDIkbWFzaykNCmBgYA0KDQpgYGB7cn0NCnJnYl9maWcgPSBSU3Rvb2xib3g6OmdnUkdCKEVYLkwyJG5ld01vc2FpYywNCiAgICAgICAgICAgICAgICAgciA9IDEsDQogICAgICAgICAgICAgICAgIGcgPSAyLA0KICAgICAgICAgICAgICAgICBiID0gMykrDQogIHRoZW1lX3ZvaWQoKSsNCiAgY29vcmRfZml4ZWQoKQ0KYGBgDQoNCmBgYHtyfQ0KY3V0ID0gbWFzayhFWC5MMSwgRVguTDIkbmV3TW9zYWljKQ0KcGxvdChjdXQpDQoNCkVYLkw0PC1maWVsZEluZGV4KG1vc2FpYz1jdXQsDQogICAgICAgICAgICAgICAgICBpbmRleCA9IGluZGV4KQ0KDQoNCg0KcGxvdChFWC5MNCRCR0kpDQpgYGANCg0KYGBge3J9DQpnbGlfZmlnID0gYXMuZGF0YS5mcmFtZShFWC5MNCROR1JESSwgeHk9VFJVRSwgbmEucm0gPVQpICU+JSANCiAgZ2dwbG90KGFlcyh4LCB5LCBmaWxsID0gTkdSREkpKSsNCiAgZ2VvbV90aWxlKCkrDQogICMgc2NhbGVfZmlsbF9kaXN0aWxsZXIocGFsZXR0ZSA9ICJTcGVjdHJhbCIsIGRpcmVjdGlvbiA9IDEpKw0KICBzY2FsZV9maWxsX2dyYWRpZW50Mihsb3cgPSAicmVkIiwgbWlkID0iZ3JlZW4iLCBoaWdoID0gImdyZWVuIiwgbWlkcG9pbnQgPSAwLjIpKw0KICAjIHNjYWxlX2ZpbGxfdmlyaWRpc19jKG9wdGlvbiA9ICJCIixkaXJlY3Rpb24gPSAtMSkrDQogIHRoZW1lX3ZvaWQoKSsNCiAgY29vcmRfZml4ZWQoKQ0KYGBgDQoNCmBgYHtyfQ0KcGxvdF9ncmlkKHJnYl9maWcsIGdsaV9maWcsIGF4aXMgPSAiYiIsDQogICAgICAgICAgcmVsX3dpZHRocyA9IGMoMC45LDEpLA0KICAgICAgICAgIGxhYmVscyA9IGMoIlJHQiIsICJOR1JESSIpLA0KICAgICAgICAgIHNjYWxlID0gMC45MCkNCiMgZ2dzYXZlKCJmaWdzL2xlYWZfZ2xpLnBuZyIsZHBpID0gNjAwLCBoZWlnaHQgPSAzLCB3aWR0aCA9MTAgKQ0KYGBgDQoNCmBgYHtyfQ0KDQpkZiA9IGFzKEVYLkw0LCAiU3BhdGlhbFBpeGVsc0RhdGFGcmFtZSIpDQpkZmYgPSBhcy5kYXRhLmZyYW1lKGRmKSAlPiUgDQogIGdhdGhlcigxOigzK2xlbmd0aChpbmRleCkpLCBrZXkgPSAiaW5kZXgiLCB2YWx1ZSA9ICJ2YWx1ZSIgKSAlPiUNCiAgZmlsdGVyKCFpcy5uYSh2YWx1ZSksDQogICAgICAgICAhaXMuaW5maW5pdGUodmFsdWUpKSAlPiUgDQogIGdyb3VwX2J5KGluZGV4KSAlPiUgDQogIHN1bW1hcmlzZShtZWFuID0gbWVhbih2YWx1ZSwgbmEucm0gPSBUKSwNCiAgICAgICAgICAgIHN0ZCA9IHNkKHZhbHVlKSwNCiAgICAgICAgICAgIFEyNSA9IHF1YW50aWxlKHZhbHVlLDAuMjUpLA0KICAgICAgICAgICAgUTUwID0gcXVhbnRpbGUodmFsdWUsMC41MCksDQogICAgICAgICAgICBRNzUgPSBxdWFudGlsZSh2YWx1ZSwwLjc1KSkgJT4lIA0KICBtdXRhdGUobGVhZiA9IHBpY3NbMzBdKQ0KYGBgDQoNCiMgV2hlYXQgbGVhZiBibGFzdA0KDQpgYGB7ciBldmFsPUZBTFNFLCBpbmNsdWRlPVRSVUV9DQpwaWNzPC1saXN0LmZpbGVzKCIuL3BpY3MvMDEtV2hlYXRfbGVhZl9ibGFzdCIpDQojIGxlbmd0aChwaWNzKQ0KI2luZGljZXMNCmluZGV4ID0gYygiQkkiLCJTQ0kiLCJHTEkiLCJISSIsIlNJIiwiVkFSSSIsIkhVRSIsIkJHSSIsIk5HUkRJIikNCg0KDQpib3ggPSBkYXRhLmZyYW1lKCkNCg0KZm9yKGkgaW4gMTpsZW5ndGgocGljcykpew0KDQpFWC5MMTwtc3RhY2socGFzdGUoIi4vcGljcy8wMS1XaGVhdF9sZWFmX2JsYXN0LyIscGljc1tpXSxzZXAgPSAiIikpDQpFWC5MMTwtYWdncmVnYXRlKEVYLkwxLCBmYWN0PTEwKQ0KRVguTC5TaGFwZTwtZmllbGRQb2x5Z29uKG1vc2FpYz1FWC5MMSwgZXh0ZW50PVQsIHBsb3QgPSBGKQ0KDQpFWDEuSW5kaWNlczwtIGZpZWxkSW5kZXgobW9zYWljID0gRVguTDEsDQogICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpbmRleCwgDQogICAgICAgICAgICAgICAgICAgICAgICAgbXlJbmRleCA9IGMoIkdyZWVuIiksIHBsb3QgPSBGKQ0KDQpFWC5MMjwtZmllbGRNYXNrKG1vc2FpYz1FWC5MMSwgIG15SW5kZXggPSBjKCJCbHVlIiksIGNyb3BWYWx1ZT0xODAsIGNyb3BBYm92ZT1ULCBwbG90ID0gRikNCg0KY3V0ID0gbWFzayhFWC5MMSwgRVguTDIkbmV3TW9zYWljKQ0KRVguTDQ8LWZpZWxkSW5kZXgobW9zYWljPWN1dCwNCiAgICAgICAgICAgICAgICAgIGluZGV4ID1pbmRleCwNCiAgICAgICAgICAgICAgICAgIHBsb3QgPUYpDQoNCg0KZGYgPSBhcyhFWC5MNCwgIlNwYXRpYWxQaXhlbHNEYXRhRnJhbWUiKQ0KZGZmID0gYXMuZGF0YS5mcmFtZShkZikgJT4lIA0KICBtdXRhdGUoZ3JheSA9IDAuMjk5KlJlZCswLjU4NypHcmVlbiswLjExNCpCbHVlKSAlPiUgDQogIGdhdGhlcihjKDE6KDMrbGVuZ3RoKGluZGV4KSksMTUpLCBrZXkgPSAiaW5kZXgiLCB2YWx1ZSA9ICJ2YWx1ZSIgKSAlPiUNCiAgZmlsdGVyKCFpcy5uYSh2YWx1ZSksDQogICAgICAgICAhaXMuaW5maW5pdGUodmFsdWUpKSAlPiUgDQogIGdyb3VwX2J5KGluZGV4KSAlPiUgDQogIGRwbHlyOjpzdW1tYXJpc2UobWVhbiA9IG1lYW4odmFsdWUsIG5hLnJtID0gVCksDQogICAgICAgICAgICBzdGQgPSBzZCh2YWx1ZSksDQogICAgICAgICAgICBRMjUgPSBxdWFudGlsZSh2YWx1ZSwwLjI1KSwNCiAgICAgICAgICAgIFE1MCA9IHF1YW50aWxlKHZhbHVlLDAuNTApLA0KICAgICAgICAgICAgUTc1ID0gcXVhbnRpbGUodmFsdWUsMC43NSkpICU+JSANCiAgbXV0YXRlKGxlYWYgPSBwaWNzW2ldKQ0KDQoNCmJveCA9IGJveCAlPiUgDQogIGJpbmRfcm93cyhkZmYpfQ0KbGVuZ3RoKHVuaXF1ZShib3gkbGVhZikpDQp3cml0ZS50YWJsZShib3gsImRhdGEvaW5kZXhlc19XTEIudHh0IikNCmBgYA0KDQpgYGB7cn0NCmJveCA9IHJlYWQudGFibGUoImRhdGEvaW5kZXhlc19XTEIudHh0IikNCmBgYA0KDQojIExvYWQgc2V2ZXJpdHkgZGF0YQ0KDQpgYGB7cn0NCiMgc2V2X2RhdGEgPSBnc2hlZXQydGJsKCJodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9zcHJlYWRzaGVldHMvZC8xMDZzZ19POERlQUxacFdueEVSUU5nazhVS2dzRmJob2JXd3JsNEpYT3piby9lZGl0I2dpZD0wIikNCg0KDQpzZXYgPSBnc2hlZXQydGJsKCJodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9zcHJlYWRzaGVldHMvZC8xMDZzZ19POERlQUxacFdueEVSUU5nazhVS2dzRmJob2JXd3JsNEpYT3piby9lZGl0I2dpZD0wIikNCiMgc2V2DQoNCg0KYmxhc3RfZGF0YSA9IGdzaGVldDJ0YmwoImh0dHBzOi8vZG9jcy5nb29nbGUuY29tL3NwcmVhZHNoZWV0cy9kLzFLbko5TjhqcUtQTWpDdDhqQ0x2N09xWUw5aEx5WWVLOHdrR0VCbWxHU1ZJL2VkaXQ/dXNwPXNoYXJpbmciKSAlPiUgDQogIGRwbHlyOjpzZWxlY3QoY29kZSwgY2l0eSwgcmVnaW9uLCBwb3NpdGlvbl93aGVhdCwgaG9zdCxzcGVjaWVzKQ0KIyBibGFzdF9kYXRhDQoNCnNldl9kYXRhID0gZnVsbF9qb2luKHNldiwgYmxhc3RfZGF0YSwgYnkgPSAiY29kZSIpICU+JSANCiAgbXV0YXRlKG4gPSBzZXEoMToxMTIzKSkgJT4lIA0KICBmaWx0ZXIobjwyMDEpICU+JSANCiAgZHBseXI6OnNlbGVjdCgtbikgJT4lIA0KICANCiAgZHBseXI6OnNlbGVjdChwaWNfbmFtZSwgc2V2KQ0KIyBzZXZfZGF0YQ0KDQoNCmxlbmd0aCh1bmlxdWUoc2V2JHBpY19uYW1lKSkNCmBgYA0KDQpgYGB7cn0NCmFsbF9kYXRhID0gYm94ICU+JQ0KICBzZXBhcmF0ZShsZWFmLCBpbnRvID0gYygicGljX25hbWUiLCAianBnIiksIHNlcCA9ICIuanBnIikgJT4lDQogICMgc2VwYXJhdGUocGljX25hbWUsIGludG8gPSBjKCJoaCIsICJpc29sYXRlIiwicmVwcCIpLCBzZXAgPSAiXyIsIHJlbW92ZSA9IEYpICU+JQ0KICBkcGx5cjo6c2VsZWN0KC1qcGcpICU+JSANCiAgZnVsbF9qb2luKHNldl9kYXRhKSAlPiUgDQogICMgZmlsdGVyKHNldj4wKSAlPiUgDQogIG11dGF0ZShzZXYgPSBjYXNlX3doZW4oc2V2PT0wIH4wLjAxLA0KICAgICAgICAgICAgICAgICAgICAgICAgIHNldiA+MCB+c2V2KSkgJT4lIA0KICBmaWx0ZXIoIWlzLm5hKGluZGV4KSkgJT4lIA0KICBtdXRhdGUoc2V2ID0gc2V2KQ0KbGVuZ3RoKHVuaXF1ZShhbGxfZGF0YSRwaWNfbmFtZSkpDQojIGxlbmd0aCh1bmlxdWUoYm94JGxlYWYpKQ0KYGBgDQpgYGB7cn0NCnN1bW1hcnkoc2V2JHNldikNCmBgYA0KDQojIyMgSW1hZ2VzDQoNCmBgYHtyfQ0KaGlzdF9zZXZfV0xCID0gIHNldiAlPiUgDQogIGdncGxvdChhZXMoc2V2KSkrDQogIGdlb21faGlzdG9ncmFtKGNvbG9yID0gIndoaXRlIiwgZmlsbCA9ICJibGFjayIsIGJpbnMgPSAyMCkrDQogIHRoZW1lX21pbmltYWxfaGdyaWQoZm9udF9zaXplID0gMTApKw0KICBsYWJzKHggPSAiU2V2ZXJpdHkgKCUpIiwNCiAgICAgICB5ID0gIkZyZXF1ZW5jeSIpKw0KICBzY2FsZV94X2NvbnRpbnVvdXMobGltaXRzID0gYygtNSwxMDUpLCBicmVha3MgPSBzZXEoMCwxMDAsMjUpKSsNCiAgIyB0aGVtZV92b2lkKCkrDQogICMgY29vcmRfZml4ZWQoKSsNCiAgdGhlbWUocGFuZWwuYmFja2dyb3VuZCA9IGVsZW1lbnRfcmVjdChjb2xvciA9ICJibGFjayIpLA0KICAgICAgICBheGlzLnRpdGxlLnkgPSBlbGVtZW50X3RleHQoc2l6ZT04KSkNCmhpc3Rfc2V2X1dMQg0KDQoNCmBgYA0KDQpgYGB7cn0NCkVYLkwxPC1zdGFjayhwYXN0ZSgiLi9waWNzLzAxLVdoZWF0X2xlYWZfYmxhc3QvIiwiR183NThfUjIuanBnIixzZXAgPSAiIikpDQpFWC5MMTwtYWdncmVnYXRlKEVYLkwxLCBmYWN0PTEwKQ0KRVguTC5TaGFwZTwtZmllbGRQb2x5Z29uKG1vc2FpYz1FWC5MMSwgZXh0ZW50PVQsIHBsb3QgPSBGKQ0KDQpFWDEuSW5kaWNlczwtIGZpZWxkSW5kZXgobW9zYWljID0gRVguTDEsDQogICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpbmRleCwgDQogICAgICAgICAgICAgICAgICAgICAgICAgbXlJbmRleCA9IGMoIkdyZWVuIiksIHBsb3QgPSBGKQ0KDQpFWC5MMjwtZmllbGRNYXNrKG1vc2FpYz1FWC5MMSwgIG15SW5kZXggPSBjKCJCbHVlIiksIGNyb3BWYWx1ZT0xODAsIGNyb3BBYm92ZT1ULCBwbG90ID0gRikNCg0KY3V0ID0gbWFzayhFWC5MMSwgRVguTDIkbmV3TW9zYWljKQ0KRVguTDQ8LWZpZWxkSW5kZXgobW9zYWljPWN1dCwNCiAgICAgICAgICAgICAgICAgIGluZGV4ID1pbmRleCwNCiAgICAgICAgICAgICAgICAgIHBsb3QgPUYpDQojIHBsb3QoRVguTDQkTkdSREkpDQoNCmBgYA0KDQpgYGB7cn0NCnJnYl9maWdfd2xiID0gUlN0b29sYm94OjpnZ1JHQihFWC5MMiRuZXdNb3NhaWMsDQogICAgICAgICAgICAgICAgIHIgPSAxLA0KICAgICAgICAgICAgICAgICBnID0gMiwNCiAgICAgICAgICAgICAgICAgYiA9IDMpKw0KICB0aGVtZV9tYXAoKSsNCiAgY29vcmRfZml4ZWQoKSsNCiAgdGhlbWUocGFuZWwuYmFja2dyb3VuZCA9IGVsZW1lbnRfcmVjdChjb2xvciA9ICJ3aGl0ZSIpKQ0KDQoNCmdsaV9maWdfd2xiID0gYXMuZGF0YS5mcmFtZShFWC5MNCRWQVJJLCB4eT1UUlVFLCBuYS5ybSA9VCkgJT4lIA0KICBnZ3Bsb3QoYWVzKHgsIHksIGZpbGwgPSBWQVJJKSkrDQogIGdlb21fdGlsZSgpKw0KICBzY2FsZV9maWxsX3ZpcmlkaXNfYyhvcHRpb24gPSAiQiIsZGlyZWN0aW9uID0gLTEpKw0KICB0aGVtZV9tYXAoKSsNCiAgY29vcmRfZml4ZWQoKSsNCiAgdGhlbWUocGFuZWwuYmFja2dyb3VuZCA9IGVsZW1lbnRfcmVjdChjb2xvciA9ICJ3aGl0ZSIpLA0KICAgICAgICBsZWdlbmQudGl0bGUgPSBlbGVtZW50X3RleHQoc2l6ZSA9IDgpLA0KICAgICAgICBsZWdlbmQudGV4dCA9IGVsZW1lbnRfdGV4dChzaXplID0gOCkpDQpgYGANCg0KYGBge3J9DQojIHBsb3RfZ3JpZChyZ2JfZmlnLCBnbGlfZmlnLCBheGlzID0gImIiLA0KIyAgICAgICAgICAgcmVsX3dpZHRocyA9IGMoMC45LDEpLA0KIyAgICAgICAgICAgbGFiZWxzID0gYygiUkdCIiwgIk5HUkRJIiksDQojICAgICAgICAgICBzY2FsZSA9IDAuOTApDQoNCnJnYl9maWdfd2xiICsgZ2xpX2ZpZ193bGIgKyBoaXN0X3Nldl9XTEINCg0KIyBnZ3NhdmUoImZpZ3MvbGVhZl9nbGlfd2xiLnBuZyIsZHBpID0gNjAwLCBoZWlnaHQgPSA0LCB3aWR0aCA9MTIpDQpgYGANCg0KIyMjIFJlbGF0aW9uc2hpcCBzZXYgaW5kaWNlcw0KDQpgYGB7cn0NCnJnYl9nZyA9IGFsbF9kYXRhICU+JSANCiAgZmlsdGVyKGluZGV4ICVpbiUgYygiUmVkIiwgIkJsdWUiLCAiR3JlZW4iKSkgJT4lIA0KICAgIGdncGxvdChhZXMobWVhbiwgc2V2LCBjb2xvciA9IGluZGV4KSkgKyANCiAgIyBnZW9tX3RleHQoKSsNCiAgZ2VvbV9wb2ludChjb2xvciA9ICJncmF5Iiwgc2l6ZSAgPTMpKw0KICBnZW9tX3Ntb290aChzZSA9IEYsIHNpemUgPSAyKSsNCiAgZmFjZXRfd3JhcCh+aW5kZXgsIHNjYWxlcyA9ICJmcmVlX3giLCBucm93ID0xKSsNCiAgc2NhbGVfY29sb3JfbWFudWFsKHZhbHVlcyA9IGMoInN0ZWVsYmx1ZSIsImRhcmtncmVlbiIsICJkYXJrcmVkIikpKw0KICB0aGVtZV9taW5pbWFsX2hncmlkKCkrDQogIGxhYnMoeCA9ICJNZWFuIHZhbHVlIGluIHRoZSBpbWFnZSIsDQogICAgICAgeSA9ICJEaXNlYXNlIHNldmVyaXR5ICglKSIpKw0KICB0aGVtZShwYW5lbC5ib3JkZXIgPSBlbGVtZW50X3JlY3QoY29sb3IgPSAiZ3JheSIpKSsNCiAgdGhlbWUobGVnZW5kLnBvc2l0aW9uID0gIm5vbmUiKQ0KcmdiX2dnDQpgYGANCg0KYGBge3J9DQppbmRleF9nZyA9IGFsbF9kYXRhICU+JSANCiAgZmlsdGVyKCFpbmRleCAlaW4lIGMoIlJlZCIsICJCbHVlIiwgIkdyZWVuIikpICU+JSANCiAgICBnZ3Bsb3QoYWVzKG1lYW4sIHNldikpICsgDQogICMgZ2VvbV90ZXh0KCkrDQogIGdlb21fcG9pbnQoY29sb3IgPSAiZ3JheSIsIHNpemUgID0zKSsNCiAgZ2VvbV9zbW9vdGgoY29sb3IgPSAiYmxhY2siLCBzZSA9IEYsIHNpemUgPSAyKSsNCiAgZmFjZXRfd3JhcCh+aW5kZXgsIHNjYWxlcyA9ICJmcmVlX3giLCBucm93ID0yKSsNCiAgdGhlbWVfbWluaW1hbF9oZ3JpZCgpKw0KICBsYWJzKHggPSAiTWVhbiBpbmRleCB2YWx1ZSBpbiB0aGUgaW1hZ2UiLA0KICAgICAgIHkgPSAiRGlzZWFzZSBzZXZlcml0eSAoJSkiKSsNCiAgdGhlbWUocGFuZWwuYm9yZGVyID0gZWxlbWVudF9yZWN0KGNvbG9yID0gImdyYXkiKSkNCmluZGV4X2dnDQpgYGANCg0KYGBge3J9DQpwbG90X2dyaWQoDQogIHBsb3RfZ3JpZChOVUxMLHJnYl9nZyxOVUxMLCByZWxfd2lkdGhzID1jKDAuMTgsMSwwLjIpLCBucm93ID0gMSksDQogICAgICAgICAgaW5kZXhfZ2csDQogICAgICAgICAgbnJvdyA9IDIsDQogICAgICAgICAgcmVsX2hlaWdodHMgPSBjKDAuNSwxKSkNCmdnc2F2ZSgiZmlncy9pbmRleF9zZXZfV0xCLnBuZyIsIGRwaSA9IDUwMCwgaGVpZ2h0ID0gOCwgd2lkdGggPSAxMCkNCmBgYA0KDQpgYGB7cn0NCmNvcl93bGIgPSBhbGxfZGF0YSAlPiUgDQogIGdyb3VwX2J5KGluZGV4KSAlPiUgDQogIGRwbHlyOjpzdW1tYXJpc2UoY29yID0gcm91bmQoICBjb3IudGVzdChtZWFuLHNldiwgbWV0aG9kID0gInNwZWFybWFuIikkZXN0aW1hdGUsMyksDQogICAgICAgICAgICAgICAgICAgUF92YWx1ZSA9IGNvci50ZXN0KG1lYW4sc2V2LCBtZXRob2QgPSAic3BlYXJtYW4iKSRwLnZhbHVlKSAlPiUgDQogIGFycmFuZ2UoLWNvcikNCmNvcl93bGINCmBgYA0KDQojIyMgU3ByZWFkDQoNCmBgYHtyfQ0KYWxsX2RhdGFfc3ByZWFkX3dsYiA9IGFsbF9kYXRhICU+JSANCiAgIyBtdXRhdGUobm49MTpsZW5ndGgoYWxsX2RhdGEkcGljX25hbWUpKSAlPiUgDQogIHBpdm90X3dpZGVyKGlkX2NvbCA9IGMocGljX25hbWUsc2V2KSwNCiAgICAgICAgICAgICAgbmFtZXNfZnJvbSA9IGluZGV4LCANCiAgICAgICAgICAgICAgdmFsdWVzX2Zyb20gPSAgbWVhbikgICANCmhlYWQoYWxsX2RhdGFfc3ByZWFkX3dsYikNCmBgYA0KDQojIyBHQk0NCg0KYGBge3J9DQp0cmFpbj1zYW1wbGUoeCA9IDE6bGVuZ3RoKGFsbF9kYXRhX3NwcmVhZF93bGIkc2V2KSwgDQogICAgICAgICAgICAgc2l6ZSA9IHJvdW5kKDAuNzUqbGVuZ3RoKGFsbF9kYXRhX3NwcmVhZF93bGIkc2V2KSwxKSkNCiMgbGVuZ3RoKHRyYWluKQ0KZ2JtLmZpdCA9IGdibShzZXYgfkJHSStCSStHTEkrSEkrSFVFK05HUkRJK1ZBUkkrZ3JheSsgUmVkK0dyZWVuK0JsdWUgICsgU0kgKyBTQ0ksDQogICAgICAgICAgICAgZGF0YSA9IGFsbF9kYXRhX3NwcmVhZF93bGJbdHJhaW4sXSwNCiAgICAgICAgICAgICBkaXN0cmlidXRpb24gPSAiZ2F1c3NpYW4iLA0KICAgICAgICAgICAgICBuLnRyZWVzID0gMTAwMCwNCiAgICAgICAgICAgICBpbnRlcmFjdGlvbi5kZXB0aCA9IDMsDQogICAgICAgICAgICAgc2hyaW5rYWdlID0gMC4xLA0KICAgICAgICAgICAgIGN2LmZvbGRzID0gNSwNCiAgICAgICAgICAgICBuLmNvcmVzID0gTlVMTCwgIyB3aWxsIHVzZSBhbGwgY29yZXMgYnkgZGVmYXVsdA0KICAgICAgICAgICAgIHZlcmJvc2UgPSBGQUxTRSkNCnByaW50KGdibS5maXQpDQpzcXJ0KG1pbihnYm0uZml0JGN2LmVycm9yKSkNCmBgYA0KDQpgYGB7cn0NCmdibS5wZXJmKGdibS5maXQsIG1ldGhvZCA9ICJjdiIpDQojIGZpbmQgaW5kZXggZm9yIG4gdHJlZXMgd2l0aCBtaW5pbXVtIENWIGVycm9yDQpgYGANCg0KYGBge3J9DQptaW5fTVNFIDwtIHdoaWNoLm1pbihnYm0uZml0JGN2LmVycm9yKQ0Kc3FydChnYm0uZml0JGN2LmVycm9yW21pbl9NU0VdKQ0KDQpgYGANCg0KYGBge3J9DQojIGJlc3QuaXRlciA8LSBnYm0ucGVyZihtb2RlbDEsIG1ldGhvZCA9ICJ0ZXN0IikNCiMgcHJpbnQoYmVzdC5pdGVyKQ0KDQpwcmVkID0gcHJlZGljdChnYm0uZml0LCBuZXdkYXRhID0gYWxsX2RhdGFfc3ByZWFkX3dsYlstdHJhaW4sLTFdLCBudHJlZXMgPSA1MDAwICkNCg0Kc3FydChtZWFuKCgocHJlZCktYWxsX2RhdGFfc3ByZWFkX3dsYiRzZXZbLXRyYWluXSleMikpDQpDQ0MoKHByZWQpLCBhbGxfZGF0YV9zcHJlYWRfd2xiJHNldlstdHJhaW5dKSRyaG8uYyRlc3QNCg0KcGxvdCgocHJlZCksIChwcmVkKS1hbGxfZGF0YV9zcHJlYWRfd2xiJHNldlstdHJhaW5dKQ0KYWJsaW5lKGE9MCxiPTApDQpgYGANCg0KIyMjIFRlc3RpbmcgdmFyaW91cyBoeXBlcnBhcmFtZXRlcnMNCg0KQ3JlYXRlIGh5cGVycGFyYW1ldGVyIGdyaWQNCg0KYGBge3J9DQoNCmh5cGVyX2dyaWQgPC0gZXhwYW5kLmdyaWQoDQogIHNocmlua2FnZSA9IGMoLjAwMSwgLjAxLCAuMSwgLjMpLA0KICBpbnRlcmFjdGlvbi5kZXB0aCA9IGMoMSwgMywgNSwgNiksDQogIG4ubWlub2JzaW5ub2RlID0gYyg1LCAxMCwgMTUpLA0KICBiYWcuZnJhY3Rpb24gPSBjKC41LC42NSwgLjgsIDEpLCANCiAgb3B0aW1hbF90cmVlcyA9IDAsICAgICAgICAgICAgICAgIyBhIHBsYWNlIHRvIGR1bXAgcmVzdWx0cw0KICBtaW5fUk1TRSA9IDAsDQogIENDQyA9MCAjIGEgcGxhY2UgdG8gZHVtcCByZXN1bHRzDQopDQojIHRvdGFsIG51bWJlciBvZiBjb21iaW5hdGlvbnMNCm5yb3coaHlwZXJfZ3JpZCkNCmBgYA0KDQpgYGB7ciBtZXNzYWdlPUZBTFNFLCB3YXJuaW5nPUZBTFNFfQ0KIyByYW5kb21pemUgZGF0YQ0Kc2V0LnNlZWQoMTIzNCkNCnRyYWluPXNhbXBsZSh4ID0gMTpsZW5ndGgoYWxsX2RhdGFfc3ByZWFkX3dsYiRzZXYpLCANCiAgICAgICAgICAgICBzaXplID0gcm91bmQoMC44MCpsZW5ndGgoYWxsX2RhdGFfc3ByZWFkX3dsYiRzZXYpLDEpKQ0KDQojIGdyaWQgc2VhcmNoIA0KZm9yKGkgaW4gMTpucm93KGh5cGVyX2dyaWQpKSB7DQoNCiMgcmVwcm9kdWNpYmlsaXR5DQpzZXQuc2VlZCgxMjMpDQoNCg0KICMgdHJhaW4gbW9kZWwNCmdibS50dW5lIDwtIGdibSgNCiAgZm9ybXVsYSA9IChzZXYpIH5CR0krQkkrR0xJK0hJK0hVRStOR1JESStWQVJJK2dyYXkgK1JlZCtHcmVlbitCbHVlICsgU0kgKyBTQ0ksICM8PDw8PA0KICBkYXRhID0gYWxsX2RhdGFfc3ByZWFkX3dsYlt0cmFpbixdLA0KICBkaXN0cmlidXRpb24gPSAiZ2F1c3NpYW4iLA0KICBuLnRyZWVzID0gNTAwMCwNCiAgaW50ZXJhY3Rpb24uZGVwdGggPSBoeXBlcl9ncmlkJGludGVyYWN0aW9uLmRlcHRoW2ldLA0KICBzaHJpbmthZ2UgPSBoeXBlcl9ncmlkJHNocmlua2FnZVtpXSwNCiAgbi5taW5vYnNpbm5vZGUgPSBoeXBlcl9ncmlkJG4ubWlub2JzaW5ub2RlW2ldLA0KICBiYWcuZnJhY3Rpb24gPSBoeXBlcl9ncmlkJGJhZy5mcmFjdGlvbltpXSwNCiAgdHJhaW4uZnJhY3Rpb24gPSAuNzUsDQogIG4uY29yZXMgPSBOVUxMLCAjIHdpbGwgdXNlIGFsbCBjb3JlcyBieSBkZWZhdWx0DQogIHZlcmJvc2UgPSBGQUxTRSkNCg0KcHJlZCA9IHByZWRpY3QoZ2JtLnR1bmUsIG5ld2RhdGEgPSBhbGxfZGF0YV9zcHJlYWRfd2xiWy10cmFpbiwtMV0sIG50cmVlcyA9IDUwMDAgKQ0KICMgYWRkIG1pbiB0cmFpbmluZyBlcnJvciBhbmQgdHJlZXMgdG8gZ3JpZA0KICBoeXBlcl9ncmlkJG9wdGltYWxfdHJlZXNbaV0gPC0gd2hpY2gubWluKGdibS50dW5lJHZhbGlkLmVycm9yKQ0KICBoeXBlcl9ncmlkJG1pbl9STVNFW2ldIDwtIHNxcnQobWluKGdibS50dW5lJHZhbGlkLmVycm9yKSkNCiAgaHlwZXJfZ3JpZCRDQ0NbaV0gPSBDQ0MocHJlZCwgYWxsX2RhdGFfc3ByZWFkX3dsYiRzZXZbLXRyYWluXSkkcmhvLmMkZXN0Izw8PDw8DQogIA0KfQ0KDQpiZXN0X3BhciA9IGh5cGVyX2dyaWQgJT4lIA0KICBkcGx5cjo6YXJyYW5nZSgtQ0NDKSAlPiUNCiAgaGVhZCgxMCkNCmJlc3RfcGFyDQoNCg0KDQojIGdibS50dW5lJGZpdA0KYGBgDQoNCiMjIyBCZXN0IG1vZGVsDQoNCmBgYHtyfQ0KIyBmb3IgcmVwcm9kdWNpYmlsaXR5DQpzZXQuc2VlZCgxMjMpDQoNCiMgdHJhaW4gR0JNIG1vZGVsDQpnYm0uZml0LmZpbmFsX3dsYiA8LSBnYm0oDQogIGZvcm11bGEgPSAoc2V2KSB+QkdJK0JJK0dMSStISStIVUUrTkdSREkrVkFSSStSZWQrR3JlZW4rQmx1ZStncmF5K1NJK1NDSSwNCiAgZGF0YSA9IGFsbF9kYXRhX3NwcmVhZF93bGJbdHJhaW4sXSwNCiAgZGlzdHJpYnV0aW9uID0gImdhdXNzaWFuIiwNCiAgbi50cmVlcyA9IGJlc3RfcGFyJG9wdGltYWxfdHJlZXNbMV0sDQogIGludGVyYWN0aW9uLmRlcHRoID0gYmVzdF9wYXIkaW50ZXJhY3Rpb24uZGVwdGhbMV0sDQogIHNocmlua2FnZSA9IGJlc3RfcGFyJHNocmlua2FnZVsxXSwNCiAgbi5taW5vYnNpbm5vZGUgPSBiZXN0X3BhciRuLm1pbm9ic2lubm9kZVsxXSwNCiAgYmFnLmZyYWN0aW9uID0gYmVzdF9wYXIkYmFnLmZyYWN0aW9uWzFdLCANCiAgdHJhaW4uZnJhY3Rpb24gPTAuNzUsDQogIG4uY29yZXMgPSBOVUxMLCAjIHdpbGwgdXNlIGFsbCBjb3JlcyBieSBkZWZhdWx0DQogIHZlcmJvc2UgPSBGQUxTRQ0KICApDQoNCg0KYGBgDQoNCiMjIyBSZWxhdGl2ZSBpbmZsdWVuY2UNCg0KYGBge3J9DQpwYXIobWFyID0gYyg1LCA4LCAxLCAxKSkNCnN1bW1hcnlfZ2JtX3dsYiA9IHN1bW1hcnkoDQogIGdibS5maXQuZmluYWxfd2xiLCANCiAgY0JhcnMgPSAxNSwNCiAgbWV0aG9kID0gcmVsYXRpdmUuaW5mbHVlbmNlLCAjIGFsc28gY2FuIHVzZSBwZXJtdXRhdGlvbi50ZXN0LmdibQ0KICBsYXMgPSAyDQogICkNCg0KcmVsX3dsYiA9IHN1bW1hcnlfZ2JtX3dsYiAlPiUgDQogIHJvd25hbWVzX3RvX2NvbHVtbigiaW5kZXgiKSAlPiUgDQogIGdncGxvdChhZXMocmVsLmluZiwgcmVvcmRlcih2YXIsIHJlbC5pbmYpKSkrDQogIGdlb21fY29sKGFlcyhmaWxsID1yZWwuaW5mPjEsIGNvbG9yID1yZWwuaW5mPjEgKSwgd2lkdGggPSAwLjg1KSsNCiAgdGhlbWVfbWluaW1hbF92Z3JpZCgpKw0KICBsYWJzKHggPSAiUmVsYXRpdmUgaW5mbHVlbmNlICglKSIsDQogICAgICAgeSA9ICJNb2RlbCBwcmVkaWN0b3JzIiwNCiAgICAgICBmaWxsID0gIlJJID4gMSUiLA0KICAgICAgIGNvbG9yID0gIlJJID4gMSUiKQ0KcmVsX3dsYg0KIyBnZ3NhdmUoImZpZ3MvdmFyX2luZmx1ZW5jZS5wbmciLGRwaSA9IDYwMCwgaGVpZ2h0ID0gNCwgd2lkdGggPSA2KQ0KYGBgDQoNClBhcnRpYWwgZGVwZW5kZW5jZSBwbG90cw0KDQpgYGB7cn0NCmdibS5maXQuZmluYWxfd2xiICU+JQ0KICBwZHA6OnBhcnRpYWwocHJlZC52YXIgPSAiTkdSREkiLCBuLnRyZWVzID0gZ2JtLmZpdC5maW5hbF93bGIkbi50cmVlcywgZ3JpZC5yZXNvbHV0aW9uID0gMTAwKSAlPiUNCiAgZ2dwbG90KGFlcyggTkdSREksKHloYXQpKSkrDQogIGdlb21fbGluZSgpDQpgYGANCg0KTElNRQ0KDQpgYGB7cn0NCm1vZGVsX3R5cGUuZ2JtIDwtIGZ1bmN0aW9uKHgsIC4uLikgew0KICByZXR1cm4oInJlZ3Jlc3Npb24iKQ0KfQ0KDQpwcmVkaWN0X21vZGVsLmdibSA8LSBmdW5jdGlvbih4LCBuZXdkYXRhLCAuLi4pIHsNCiAgcHJlZCA8LSBwcmVkaWN0KHgsIG5ld2RhdGEsIG4udHJlZXMgPSB4JG4udHJlZXMpDQogIHJldHVybihhcy5kYXRhLmZyYW1lKHByZWQpKQ0KfQ0KYGBgDQoNCmBgYHtyfQ0KIyBnZXQgYSBmZXcgb2JzZXJ2YXRpb25zIHRvIHBlcmZvcm0gbG9jYWwgaW50ZXJwcmV0YXRpb24gb24NCmxvY2FsX29icyA8LSAoYWxsX2RhdGFfc3ByZWFkX3dsYlstdHJhaW4sXSlbMTo0LCBdDQoNCiMgYXBwbHkgTElNRQ0KZXhwbGFpbmVyIDwtIGxpbWUoYWxsX2RhdGFfc3ByZWFkX3dsYlt0cmFpbixdLCBnYm0uZml0LmZpbmFsX3dsYikNCmV4cGxhbmF0aW9uIDwtIGxpbWU6OmV4cGxhaW4obG9jYWxfb2JzLCBleHBsYWluZXIsIG5fZmVhdHVyZXMgPSA3LCBuLnRyZWVzID0xKQ0KcGxvdF9mZWF0dXJlcyhleHBsYW5hdGlvbikNCg0KDQpgYGANCg0KIyMgUHJlZGljdGlvbg0KDQpgYGB7cn0NCiMgcHJlZGljdCB2YWx1ZXMgZm9yIHRlc3QgZGF0YQ0KcHJlZCA8LSBwcmVkaWN0KGdibS5maXQuZmluYWxfd2xiLA0KICAgICAgICAgICAgICAgIG4udHJlZXMgPSBnYm0uZml0LmZpbmFsX3dsYiRuLnRyZWVzLA0KICAgICAgICAgICAgICAgIGFsbF9kYXRhX3NwcmVhZF93bGJbLXRyYWluLF0pDQoNCiMgcmVzdWx0cw0KY2FyZXQ6OlJNU0UoKHByZWQpLCBhbGxfZGF0YV9zcHJlYWRfd2xiWy10cmFpbixdJHNldikNCkNDQygocHJlZCksIGFsbF9kYXRhX3NwcmVhZF93bGIkc2V2Wy10cmFpbl0pJHJoby5jJGVzdA0KY29yKChwcmVkKSwgYWxsX2RhdGFfc3ByZWFkX3dsYiRzZXZbLXRyYWluXSleMg0KDQpgYGANCg0KYGBge3J9DQphY2N1cmFjeV93bGIgPWRhdGEuZnJhbWUocHJlZGk9cHJlZCwgYWN0dWFsID0gYWxsX2RhdGFfc3ByZWFkX3dsYiRzZXZbLXRyYWluXSkgJT4lIA0KICBzdW1tYXJpc2UoUk1TRSA9IGNhcmV0OjpSTVNFKHByZWQsIGFjdHVhbCksDQogICAgICAgICAgICByID0gY29yKHByZWQsIGFjdHVhbCksDQogICAgICAgICAgICBzLnNoaWZ0ID0gQ0NDKHByZWQsIGFjdHVhbCkkcy5zaGlmdCwNCiAgICAgICAgICAgIGwuc2hpZnQgPSBDQ0MocHJlZCwgYWN0dWFsKSRsLnNoaWZ0LA0KICAgICAgICAgICAgQy5iID0gQ0NDKHByZWQsIGFjdHVhbCkkQy5iLA0KICAgICAgICAgICAgQ0NDID0gQ0NDKHByZWQsIGFjdHVhbCkkcmhvLmMkZXN0LA0KICAgICAgICAgICAgQ0lTID0gcGFzdGUoDQogIHJvdW5kKENDQyhwcmVkLCBhbGxfZGF0YV9zcHJlYWRfd2xiJHNldlstdHJhaW5dKSRyaG8uY1syXSwyKSwiLCIsIiAiLA0KICByb3VuZChDQ0MocHJlZCwgYWxsX2RhdGFfc3ByZWFkX3dsYiRzZXZbLXRyYWluXSkkcmhvLmNbM10sMiksc2VwID0gIiINCiAgKSkNCmFjY3VyYWN5X3dsYg0KYGBgDQoNCiMjIyMgcGxvdA0KYGBge3J9DQoNCiMgcGxvdF9ncmlkKA0KY29uY193bGIgPSBkYXRhLmZyYW1lKHByZWRpY3QgPSBwcmVkLCBhY3R1YWwgPWFsbF9kYXRhX3NwcmVhZF93bGIkc2V2Wy10cmFpbl0pICU+JSANCmdncGxvdChhZXMoYWN0dWFsLHByZWRpY3QpKSsNCiAgZ2VvbV9wb2ludChzaXplID0yLCBjb2xvciA9ICJncmF5IikrDQogIGdlb21fYWJsaW5lKGludGVyY2VwdCA9IDAsIHNsb3BlPSAxLCBzaXplID0gLjgxLCBjb2xvciA9ICJibGFjayIsIGxpbmV0eXBlID0gImRhc2hlZCIpKw0KICBnZW9tX3Ntb290aChtZXRob2QgPSAibG0iLCANCiAgICAgICAgICAgICAgY29sb3IgPSAicmVkIiwNCiAgICAgICAgICAgICAgc2l6ZSA9LjgxLCBzZSA9RiwNCiAgICAgICAgICAgICAgZnVsbHJhbmdlPVQpKw0KICB0aGVtZV9taW5pbWFsX2dyaWQoKSsNCiAgbGFicyh4ID0gIlByZWRpY3RlZCBTZXZlcml0eSAoJSkiLA0KICAgICAgIHkgPSAiQWN0dWFsIFNldmVyaXR5ICglKSIpKw0KICBjb29yZF9lcXVhbCh4bGltID0gYygwLDEwMCksDQogICAgICAgICAgICAgIHlsaW0gPSBjKDAsMTAwKSkrDQogIHhsaW0oMCwxMDApDQoNCmdnc2F2ZSgiZmlncy9jb25jb3JkYW5jZS5wbmciLCBkcGkgPSA2MDAsIGhlaWdodCA9IDMuNSwgd2lkdGggPSA0KQ0KDQpgYGANCg0KIyBTb3liZWFuIFJ1c3QNCg0KYGBge3IgZXZhbD1GQUxTRSwgaW5jbHVkZT1UUlVFfQ0KcGljczwtbGlzdC5maWxlcygiLi9waWNzLzAxLXNveWJlYW4tcnVzdC1iZy1ibHVlIikNCiMgbGVuZ3RoKHBpY3MpDQojaW5kaWNlcw0KaW5kZXggPSBjKCJCSSIsIlNDSSIsIkdMSSIsIkhJIiwiU0kiLCJWQVJJIiwiSFVFIiwiQkdJIiwiTkdSREkiKQ0KDQoNCmJveCA9IGRhdGEuZnJhbWUoKQ0KDQpmb3IoaSBpbiAxOmxlbmd0aChwaWNzKSl7DQoNCkVYLkwxPC1zdGFjayhwYXN0ZSgiLi9waWNzLzAxLXNveWJlYW4tcnVzdC1iZy1ibHVlLyIscGljc1tpXSxzZXAgPSAiIikpDQpFWC5MMTwtYWdncmVnYXRlKEVYLkwxLCBmYWN0PTcpDQpFWC5MLlNoYXBlPC1maWVsZFBvbHlnb24obW9zYWljPUVYLkwxLCBleHRlbnQ9VCwgcGxvdCA9IEYpDQoNCkVYMS5JbmRpY2VzPC0gZmllbGRJbmRleChtb3NhaWMgPSBFWC5MMSwNCiAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGluZGV4LCANCiAgICAgICAgICAgICAgICAgICAgICAgICBteUluZGV4ID0gYygiR3JlZW4iKSwgcGxvdCA9IEYpDQoNCkVYLkwyPC1maWVsZE1hc2sobW9zYWljPUVYLkwxLCAgbXlJbmRleCA9IGMoIkJsdWUiKSwgY3JvcFZhbHVlPTEwMCwgY3JvcEFib3ZlPVQsIHBsb3QgPSBGKQ0KDQpjdXQgPSBtYXNrKEVYLkwxLCBFWC5MMiRuZXdNb3NhaWMpDQpFWC5MNDwtZmllbGRJbmRleChtb3NhaWM9Y3V0LA0KICAgICAgICAgICAgICAgICAgaW5kZXggPWluZGV4LA0KICAgICAgICAgICAgICAgICAgcGxvdCA9RikNCg0KDQpkZiA9IGFzKEVYLkw0LCAiU3BhdGlhbFBpeGVsc0RhdGFGcmFtZSIpDQpkZmYgPSBhcy5kYXRhLmZyYW1lKGRmKSAlPiUgDQogIG11dGF0ZShncmF5ID0gMC4yOTkqUmVkKzAuNTg3KkdyZWVuKzAuMTE0KkJsdWUpICU+JSANCiAgZ2F0aGVyKGMoMTooMytsZW5ndGgoaW5kZXgpKSwxNSksIGtleSA9ICJpbmRleCIsIHZhbHVlID0gInZhbHVlIiApICU+JQ0KICBmaWx0ZXIoIWlzLm5hKHZhbHVlKSwNCiAgICAgICAgICFpcy5pbmZpbml0ZSh2YWx1ZSkpICU+JSANCiAgZ3JvdXBfYnkoaW5kZXgpICU+JSANCiAgZHBseXI6OnN1bW1hcmlzZShtZWFuID0gbWVhbih2YWx1ZSwgbmEucm0gPSBUKSwNCiAgICAgICAgICAgIHN0ZCA9IHNkKHZhbHVlKSwNCiAgICAgICAgICAgIFEyNSA9IHF1YW50aWxlKHZhbHVlLDAuMjUpLA0KICAgICAgICAgICAgUTUwID0gcXVhbnRpbGUodmFsdWUsMC41MCksDQogICAgICAgICAgICBRNzUgPSBxdWFudGlsZSh2YWx1ZSwwLjc1KSkgJT4lIA0KICBtdXRhdGUobGVhZiA9IHBpY3NbaV0pDQoNCg0KYm94ID0gYm94ICU+JSANCiAgYmluZF9yb3dzKGRmZil9DQpsZW5ndGgodW5pcXVlKGJveCRsZWFmKSkNCndyaXRlLnRhYmxlKGJveCwiZGF0YS9pbmRleGVzX1NCUi50eHQiKQ0KYGBgDQoNCmBgYHtyfQ0KYm94ID0gcmVhZC50YWJsZSgiZGF0YS9pbmRleGVzX1NCUi50eHQiKQ0KYGBgDQoNCiMjIyBsb2FkIFNCUiBzZXZlcml0eQ0KDQpgYGB7cn0NCnNicl9sb2FkID0gZ3NoZWV0MnRibCgiaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vc3ByZWFkc2hlZXRzL2QvMTNUVktCUWdmQ0FyN1VHaWVfTEhURl9rd1BIQzFYSV9Ba0xLb1JZdGpQclEvZWRpdD91c3A9c2hhcmluZyIpDQpgYGANCg0KYGBge3J9DQphbGxfZGF0YV9zYnIgPSBib3ggJT4lIA0KICBzZXBhcmF0ZShsZWFmLCBpbnRvPWMoImZpbGUiLCJmb3JtYXQiKSwgc2VwID0iXyIpICU+JSANCiAgZHBseXI6OnNlbGVjdCgtZm9ybWF0KSAlPiUgDQogIGZ1bGxfam9pbihzYnJfbG9hZCkgJT4lIA0KICBuYS5vbWl0KCkNCg0KbGVuZ3RoKHVuaXF1ZShhbGxfZGF0YV9zYnIkZmlsZSkpDQoNCg0KaGVhZChhbGxfZGF0YV9zYnIpDQpgYGANCg0KYGBge3J9DQpzdW1tYXJ5KGFsbF9kYXRhX3NiciRzZXYpDQpgYGANCg0KDQojIyMgSW1hZ2VzDQoNCmBgYHtyfQ0KaGlzdF9zZXZfc2JyID0gIGFsbF9kYXRhX3NiciAlPiUNCiAgcGl2b3Rfd2lkZXIoaWRfY29sID0gYyhmaWxlLHNldiksDQogICAgICAgICAgICAgIG5hbWVzX2Zyb20gPSBpbmRleCwgDQogICAgICAgICAgICAgIHZhbHVlc19mcm9tID0gIG1lYW4pICU+JQ0KICBnZ3Bsb3QoYWVzKHNldikpKw0KICBnZW9tX2hpc3RvZ3JhbShjb2xvciA9ICJ3aGl0ZSIsIGZpbGwgPSAiYmxhY2siLCBiaW5zID0gMjApKw0KICB0aGVtZV9taW5pbWFsX2hncmlkKGZvbnRfc2l6ZSA9IDEwKSsNCiAgbGFicyh4ID0gIlNldmVyaXR5ICglKSIsDQogICAgICAgeSA9ICJGcmVxdWVuY3kiKSsNCiAgc2NhbGVfeF9jb250aW51b3VzKGxpbWl0cyA9IGMoLTUsMTA1KSwgYnJlYWtzID0gc2VxKDAsMTAwLDI1KSkrDQogICMgdGhlbWVfdm9pZCgpKw0KICAjIGNvb3JkX2ZpeGVkKCkrDQogIHRoZW1lKHBhbmVsLmJhY2tncm91bmQgPSBlbGVtZW50X3JlY3QoY29sb3IgPSAiYmxhY2siKSwNCiAgICAgICAgYXhpcy50aXRsZS55ID0gZWxlbWVudF90ZXh0KHNpemU9OCkpDQoNCmBgYA0KDQpgYGB7cn0NCkVYLkwxPC1zdGFjayhwYXN0ZSgiLi9waWNzLzAxLXNveWJlYW4tcnVzdC1iZy1ibHVlLyIsIkZlcnJ1Z2VtIDJfTWVkaWFuLmpwZyIsc2VwID0gIiIpKQ0KRVguTDE8LWFnZ3JlZ2F0ZShFWC5MMSwgZmFjdD03KQ0KRVguTC5TaGFwZTwtZmllbGRQb2x5Z29uKG1vc2FpYz1FWC5MMSwgZXh0ZW50PVQsIHBsb3QgPSBGKQ0KDQpFWDEuSW5kaWNlczwtIGZpZWxkSW5kZXgobW9zYWljID0gRVguTDEsDQogICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpbmRleCwgDQogICAgICAgICAgICAgICAgICAgICAgICAgbXlJbmRleCA9IGMoIkdyZWVuIiksIHBsb3QgPSBGKQ0KDQpFWC5MMjwtZmllbGRNYXNrKG1vc2FpYz1FWC5MMSwgIG15SW5kZXggPSBjKCJCbHVlIiksIGNyb3BWYWx1ZT0xMDAsIGNyb3BBYm92ZT1ULCBwbG90ID0gRikNCg0KY3V0ID0gbWFzayhFWC5MMSwgRVguTDIkbmV3TW9zYWljKQ0KRVguTDQ8LWZpZWxkSW5kZXgobW9zYWljPWN1dCwNCiAgICAgICAgICAgICAgICAgIGluZGV4ID1pbmRleCwNCiAgICAgICAgICAgICAgICAgIHBsb3QgPUYpDQojIHBsb3QoRVguTDQkSFVFKQ0KYGBgDQoNCmBgYHtyfQ0KcmdiX2ZpZ19zYnIgPSBSU3Rvb2xib3g6OmdnUkdCKEVYLkwyJG5ld01vc2FpYywNCiAgICAgICAgICAgICAgICAgciA9IDEsDQogICAgICAgICAgICAgICAgIGcgPSAyLA0KICAgICAgICAgICAgICAgICBiID0gMykrDQogIHRoZW1lX21hcCgpKw0KICBjb29yZF9maXhlZCgpKw0KICB0aGVtZShwYW5lbC5iYWNrZ3JvdW5kID0gZWxlbWVudF9yZWN0KGNvbG9yID0gIndoaXRlIikpDQoNCg0KZ2xpX2ZpZ19zYnIgPSBhcy5kYXRhLmZyYW1lKEVYLkw0JEhVRSwgeHk9VFJVRSwgbmEucm0gPVQpICU+JSANCiAgZ2dwbG90KGFlcyh4LCB5LCBmaWxsID0gSFVFKSkrDQogIGdlb21fdGlsZSgpKw0KICBzY2FsZV9maWxsX3ZpcmlkaXNfYyhvcHRpb24gPSAiQiIsZGlyZWN0aW9uID0gLTEpKw0KICB0aGVtZV9tYXAoKSsNCiAgY29vcmRfZml4ZWQoKSsNCiAgdGhlbWUocGFuZWwuYmFja2dyb3VuZCA9IGVsZW1lbnRfcmVjdChjb2xvciA9ICJ3aGl0ZSIpLA0KICAgICAgICBsZWdlbmQudGl0bGUgPSBlbGVtZW50X3RleHQoc2l6ZSA9IDgpLA0KICAgICAgICBsZWdlbmQudGV4dCA9IGVsZW1lbnRfdGV4dChzaXplID0gOCkpDQoNCmBgYA0KDQpgYGB7cn0NCnJnYl9maWdfc2JyICsgZ2xpX2ZpZ19zYnIgKyBoaXN0X3Nldl9zYnIgIysNCiAgIyByZ2JfZmlnX3dsYiArIGdsaV9maWdfd2xiICsgaGlzdF9zZXZfV0xCKw0KICAjICBwbG90X2xheW91dCh3aWR0aHMgPSBjKDEsIDEsIDEpLA0KICAjICAgICAgICAgICAgICBoZWlnaHRzID0gYygxLDEpKQ0KDQojIGdnc2F2ZSgiZmlncy9sZWFmX2dsaS5wbmciLGRwaSA9IDYwMCwgaGVpZ2h0ID0gNiwgd2lkdGggPTEwKQ0KYGBgDQoNCiMjIyBSZWxhdGlvbnNoaXAgc2V2IGluZGljZXMNCg0KYGBge3J9DQpyZ2JfZ2dfc2JyID0gYWxsX2RhdGFfc2JyICU+JSANCiAgZmlsdGVyKGluZGV4ICVpbiUgYygiUmVkIiwgIkJsdWUiLCAiR3JlZW4iKSkgJT4lIA0KICAgIGdncGxvdChhZXMobWVhbiwgc2V2LCBjb2xvciA9IGluZGV4KSkgKyANCiAgIyBnZW9tX3RleHQoKSsNCiAgZ2VvbV9wb2ludChjb2xvciA9ICJncmF5Iiwgc2l6ZSAgPTMpKw0KICBnZW9tX3Ntb290aChzZSA9IEYsIHNpemUgPSAyKSsNCiAgZmFjZXRfd3JhcCh+aW5kZXgsIHNjYWxlcyA9ICJmcmVlX3giLCBucm93ID0xKSsNCiAgc2NhbGVfY29sb3JfbWFudWFsKHZhbHVlcyA9IGMoInN0ZWVsYmx1ZSIsImRhcmtncmVlbiIsICJkYXJrcmVkIikpKw0KICB0aGVtZV9taW5pbWFsX2hncmlkKCkrDQogIGxhYnMoeCA9ICJNZWFuIHZhbHVlIGluIHRoZSBpbWFnZSIsDQogICAgICAgeSA9ICJEaXNlYXNlIHNldmVyaXR5ICglKSIpKw0KICB0aGVtZShwYW5lbC5ib3JkZXIgPSBlbGVtZW50X3JlY3QoY29sb3IgPSAiZ3JheSIpKSsNCiAgdGhlbWUobGVnZW5kLnBvc2l0aW9uID0gIm5vbmUiKQ0KcmdiX2dnX3Nicg0KYGBgDQoNCmBgYHtyfQ0KaW5kZXhfZ2dfc2JyID0gYWxsX2RhdGFfc2JyICU+JSANCiAgZmlsdGVyKCFpbmRleCAlaW4lIGMoIlJlZCIsICJCbHVlIiwgIkdyZWVuIikpICU+JSANCiAgICBnZ3Bsb3QoYWVzKG1lYW4sIHNldikpICsgDQogICMgZ2VvbV90ZXh0KCkrDQogIGdlb21fcG9pbnQoY29sb3IgPSAiZ3JheSIsIHNpemUgID0zKSsNCiAgZ2VvbV9zbW9vdGgoY29sb3IgPSAiYmxhY2siLCBzZSA9IEYsIHNpemUgPSAyKSsNCiAgZmFjZXRfd3JhcCh+aW5kZXgsIHNjYWxlcyA9ICJmcmVlX3giLCBucm93ID0yKSsNCiAgdGhlbWVfbWluaW1hbF9oZ3JpZCgpKw0KICBsYWJzKHggPSAiTWVhbiBpbmRleCB2YWx1ZSBpbiB0aGUgaW1hZ2UiLA0KICAgICAgIHkgPSAiRGlzZWFzZSBzZXZlcml0eSAoJSkiKSsNCiAgdGhlbWUocGFuZWwuYm9yZGVyID0gZWxlbWVudF9yZWN0KGNvbG9yID0gImdyYXkiKSkNCmluZGV4X2dnX3Nicg0KYGBgDQoNCmBgYHtyfQ0KcGxvdF9ncmlkKA0KICBwbG90X2dyaWQoTlVMTCxyZ2JfZ2dfc2JyLE5VTEwsIHJlbF93aWR0aHMgPWMoMC4xOCwxLDAuMiksIG5yb3cgPSAxKSwNCiAgICAgICAgICBpbmRleF9nZ19zYnIsDQogICAgICAgICAgbnJvdyA9IDIsDQogICAgICAgICAgcmVsX2hlaWdodHMgPSBjKDAuNSwxKSkNCmdnc2F2ZSgiZmlncy9pbmRleF9zZXZfU0JSLnBuZyIsIGRwaSA9IDUwMCwgaGVpZ2h0ID0gOCwgd2lkdGggPSAxMCkNCmBgYA0KDQpgYGB7cn0NCmNvcl9zYnIgPSBhbGxfZGF0YV9zYnIgJT4lIA0KICBncm91cF9ieShpbmRleCkgJT4lIA0KICBkcGx5cjo6c3VtbWFyaXNlKGNvciA9IHJvdW5kKCAgY29yLnRlc3QobWVhbixzZXYsIG1ldGhvZCA9ICJzcGVhcm1hbiIpJGVzdGltYXRlLDMpLA0KICAgICAgICAgICAgICAgICAgIFBfdmFsdWUgPSBjb3IudGVzdChtZWFuLHNldiwgbWV0aG9kID0gInNwZWFybWFuIikkcC52YWx1ZSkgJT4lIA0KICBhcnJhbmdlKC1jb3IpDQpjb3Jfc2JyDQpgYGANCg0KIyMjIFNwcmVhZCBkZg0KDQpgYGB7cn0NCmFsbF9kYXRhX3NwcmVhZF9zYnIgPSBhbGxfZGF0YV9zYnIgJT4lIA0KICBwaXZvdF93aWRlcihpZF9jb2wgPSBjKGZpbGUsc2V2KSwNCiAgICAgICAgICAgICAgbmFtZXNfZnJvbSA9IGluZGV4LCANCiAgICAgICAgICAgICAgdmFsdWVzX2Zyb20gPSAgbWVhbikgICANCg0KaGVhZChhbGxfZGF0YV9zcHJlYWRfc2JyKQ0KYGBgDQoNCiMjIEdCTQ0KDQpgYGB7cn0NCnRyYWluPXNhbXBsZSh4ID0gMTpsZW5ndGgoYWxsX2RhdGFfc3ByZWFkX3NiciRzZXYpLCANCiAgICAgICAgICAgICBzaXplID0gcm91bmQoMC43NSpsZW5ndGgoYWxsX2RhdGFfc3ByZWFkX3NiciRzZXYpLDEpKQ0KIyBsZW5ndGgodHJhaW4pDQpnYm0uZml0ID0gZ2JtKHNldiB+QkdJK0JJK0dMSStISStIVUUrTkdSREkrVkFSSStncmF5KyBSZWQrR3JlZW4rQmx1ZSAgKyBTSSArIFNDSSwNCiAgICAgICAgICAgICBkYXRhID0gYWxsX2RhdGFfc3ByZWFkX3Niclt0cmFpbixdLA0KICAgICAgICAgICAgIGRpc3RyaWJ1dGlvbiA9ICJnYXVzc2lhbiIsDQogICAgICAgICAgICAgIG4udHJlZXMgPSAxMDAwLA0KICAgICAgICAgICAgIGludGVyYWN0aW9uLmRlcHRoID0gMywNCiAgICAgICAgICAgICBzaHJpbmthZ2UgPSAwLjEsDQogICAgICAgICAgICAgY3YuZm9sZHMgPSA1LA0KICAgICAgICAgICAgIG4uY29yZXMgPSBOVUxMLCAjIHdpbGwgdXNlIGFsbCBjb3JlcyBieSBkZWZhdWx0DQogICAgICAgICAgICAgdmVyYm9zZSA9IEZBTFNFKQ0KcHJpbnQoZ2JtLmZpdCkNCnNxcnQobWluKGdibS5maXQkY3YuZXJyb3IpKQ0KYGBgDQoNCmBgYHtyfQ0KZ2JtLnBlcmYoZ2JtLmZpdCwgbWV0aG9kID0gImN2IikNCiMgZmluZCBpbmRleCBmb3IgbiB0cmVlcyB3aXRoIG1pbmltdW0gQ1YgZXJyb3INCmBgYA0KDQpgYGB7cn0NCm1pbl9NU0UgPC0gd2hpY2gubWluKGdibS5maXQkY3YuZXJyb3IpDQpzcXJ0KGdibS5maXQkY3YuZXJyb3JbbWluX01TRV0pDQoNCmBgYA0KDQpgYGB7cn0NCiMgYmVzdC5pdGVyIDwtIGdibS5wZXJmKG1vZGVsMSwgbWV0aG9kID0gInRlc3QiKQ0KIyBwcmludChiZXN0Lml0ZXIpDQoNCnByZWQgPSBwcmVkaWN0KGdibS5maXQsIG5ld2RhdGEgPSBhbGxfZGF0YV9zcHJlYWRfc2JyWy10cmFpbiwtMV0sIG50cmVlcyA9IDUwMDAgKQ0KDQpzcXJ0KG1lYW4oKChwcmVkKS1hbGxfZGF0YV9zcHJlYWRfc2JyJHNldlstdHJhaW5dKV4yKSkNCkNDQygocHJlZCksIGFsbF9kYXRhX3NwcmVhZF9zYnIkc2V2Wy10cmFpbl0pJHJoby5jJGVzdA0KDQpwbG90KChwcmVkKSwgKHByZWQpLWFsbF9kYXRhX3NwcmVhZF9zYnIkc2V2Wy10cmFpbl0pDQphYmxpbmUoYT0wLGI9MCkNCmBgYA0KDQojIyMgVGVzdGluZyB2YXJpb3VzIGh5cGVycGFyYW1ldGVycw0KDQpDcmVhdGUgaHlwZXJwYXJhbWV0ZXIgZ3JpZA0KDQpgYGB7cn0NCg0KaHlwZXJfZ3JpZCA8LSBleHBhbmQuZ3JpZCgNCiAgc2hyaW5rYWdlID0gYyguMDAxLCAuMDEsIC4xLCAuMyksDQogIGludGVyYWN0aW9uLmRlcHRoID0gYygxLCAzLCA1LCA2KSwNCiAgbi5taW5vYnNpbm5vZGUgPSBjKDUsIDEwLCAxNSksDQogIGJhZy5mcmFjdGlvbiA9IGMoLjUsLjY1LCAuOCwgMSksIA0KICBvcHRpbWFsX3RyZWVzID0gMCwgICAgICAgICAgICAgICAjIGEgcGxhY2UgdG8gZHVtcCByZXN1bHRzDQogIG1pbl9STVNFID0gMCwNCiAgQ0NDID0wICMgYSBwbGFjZSB0byBkdW1wIHJlc3VsdHMNCikNCiMgdG90YWwgbnVtYmVyIG9mIGNvbWJpbmF0aW9ucw0KbnJvdyhoeXBlcl9ncmlkKQ0KYGBgDQoNCmBgYHtyIG1lc3NhZ2U9RkFMU0UsIHdhcm5pbmc9RkFMU0V9DQojIHJhbmRvbWl6ZSBkYXRhDQpzZXQuc2VlZCgxMjMpDQp0cmFpbj1zYW1wbGUoeCA9IDE6bGVuZ3RoKGFsbF9kYXRhX3NwcmVhZF9zYnIkc2V2KSwgDQogICAgICAgICAgICAgc2l6ZSA9IHJvdW5kKDAuOCpsZW5ndGgoYWxsX2RhdGFfc3ByZWFkX3NiciRzZXYpLDEpKQ0KDQojIGdyaWQgc2VhcmNoIA0KZm9yKGkgaW4gMTpucm93KGh5cGVyX2dyaWQpKSB7DQoNCiMgcmVwcm9kdWNpYmlsaXR5DQpzZXQuc2VlZCgxMjMpDQoNCg0KICMgdHJhaW4gbW9kZWwNCmdibS50dW5lIDwtIGdibSgNCiAgZm9ybXVsYSA9IChzZXYpIH5CR0krQkkrR0xJK0hJK0hVRStOR1JESStWQVJJK2dyYXkgK1JlZCtHcmVlbitCbHVlICsgU0kgKyBTQ0ksICM8PDw8PA0KICBkYXRhID0gYWxsX2RhdGFfc3ByZWFkX3Niclt0cmFpbixdLA0KICBkaXN0cmlidXRpb24gPSAiZ2F1c3NpYW4iLA0KICBuLnRyZWVzID0gNTAwMCwNCiAgaW50ZXJhY3Rpb24uZGVwdGggPSBoeXBlcl9ncmlkJGludGVyYWN0aW9uLmRlcHRoW2ldLA0KICBzaHJpbmthZ2UgPSBoeXBlcl9ncmlkJHNocmlua2FnZVtpXSwNCiAgbi5taW5vYnNpbm5vZGUgPSBoeXBlcl9ncmlkJG4ubWlub2JzaW5ub2RlW2ldLA0KICBiYWcuZnJhY3Rpb24gPSBoeXBlcl9ncmlkJGJhZy5mcmFjdGlvbltpXSwNCiAgdHJhaW4uZnJhY3Rpb24gPSAuNzUsDQogIG4uY29yZXMgPSBOVUxMLCAjIHdpbGwgdXNlIGFsbCBjb3JlcyBieSBkZWZhdWx0DQogIHZlcmJvc2UgPSBGQUxTRSkNCg0KcHJlZCA9IHByZWRpY3QoZ2JtLnR1bmUsIG5ld2RhdGEgPSBhbGxfZGF0YV9zcHJlYWRfc2JyWy10cmFpbiwtMV0sIG50cmVlcyA9IDUwMDAgKQ0KICMgYWRkIG1pbiB0cmFpbmluZyBlcnJvciBhbmQgdHJlZXMgdG8gZ3JpZA0KICBoeXBlcl9ncmlkJG9wdGltYWxfdHJlZXNbaV0gPC0gd2hpY2gubWluKGdibS50dW5lJHZhbGlkLmVycm9yKQ0KICBoeXBlcl9ncmlkJG1pbl9STVNFW2ldIDwtIHNxcnQobWluKGdibS50dW5lJHZhbGlkLmVycm9yKSkNCiAgaHlwZXJfZ3JpZCRDQ0NbaV0gPSBDQ0MocHJlZCwgYWxsX2RhdGFfc3ByZWFkX3NiciRzZXZbLXRyYWluXSkkcmhvLmMkZXN0Izw8PDw8DQogIA0KfQ0KDQpiZXN0X3BhciA9IGh5cGVyX2dyaWQgJT4lIA0KICBkcGx5cjo6YXJyYW5nZSgtQ0NDKSAlPiUNCiAgaGVhZCgxMCkNCmJlc3RfcGFyDQoNCg0KDQojIGdibS50dW5lJGZpdA0KYGBgDQoNCiMjIyBCZXN0IG1vZGVsDQoNCmBgYHtyfQ0KIyBmb3IgcmVwcm9kdWNpYmlsaXR5DQpzZXQuc2VlZCgxMjMpDQoNCiMgdHJhaW4gR0JNIG1vZGVsDQpnYm0uZml0LmZpbmFsX3NiciA8LSBnYm0oDQogIGZvcm11bGEgPSAoc2V2KSB+QkdJK0JJK0dMSStISStIVUUrTkdSREkrVkFSSStSZWQrR3JlZW4rQmx1ZStncmF5K1NJK1NDSSwNCiAgZGF0YSA9IGFsbF9kYXRhX3NwcmVhZF9zYnJbdHJhaW4sXSwNCiAgZGlzdHJpYnV0aW9uID0gImdhdXNzaWFuIiwNCiAgbi50cmVlcyA9IGJlc3RfcGFyJG9wdGltYWxfdHJlZXNbMV0sDQogIGludGVyYWN0aW9uLmRlcHRoID0gYmVzdF9wYXIkaW50ZXJhY3Rpb24uZGVwdGhbMV0sDQogIHNocmlua2FnZSA9IGJlc3RfcGFyJHNocmlua2FnZVsxXSwNCiAgbi5taW5vYnNpbm5vZGUgPSBiZXN0X3BhciRuLm1pbm9ic2lubm9kZVsxXSwNCiAgYmFnLmZyYWN0aW9uID0gYmVzdF9wYXIkYmFnLmZyYWN0aW9uWzFdLCANCiAgdHJhaW4uZnJhY3Rpb24gPTAuNzUsDQogIG4uY29yZXMgPSBOVUxMLCAjIHdpbGwgdXNlIGFsbCBjb3JlcyBieSBkZWZhdWx0DQogIHZlcmJvc2UgPSBGQUxTRQ0KICApDQoNCg0KYGBgDQoNCiMjIyBSZWxhdGl2ZSBpbmZsdWVuY2UNCg0KYGBge3J9DQpwYXIobWFyID0gYyg1LCA4LCAxLCAxKSkNCnN1bW1hcnlfZ2JtX3NiciA9IHN1bW1hcnkoDQogIGdibS5maXQuZmluYWxfc2JyLCANCiAgY0JhcnMgPSAxNSwNCiAgbWV0aG9kID0gcmVsYXRpdmUuaW5mbHVlbmNlLCAjIGFsc28gY2FuIHVzZSBwZXJtdXRhdGlvbi50ZXN0LmdibQ0KICBsYXMgPSAyDQogICkNCg0KcmVsX3NiciA9IHN1bW1hcnlfZ2JtX3NiciAlPiUgDQogIHJvd25hbWVzX3RvX2NvbHVtbigiaW5kZXgiKSAlPiUgDQogIGdncGxvdChhZXMocmVsLmluZiwgcmVvcmRlcih2YXIsIHJlbC5pbmYpKSkrDQogIGdlb21fY29sKGFlcyhmaWxsID1yZWwuaW5mPjEsIGNvbG9yID1yZWwuaW5mPjEgKSwgd2lkdGggPSAwLjg1KSsNCiAgdGhlbWVfbWluaW1hbF92Z3JpZCgpKw0KICBsYWJzKHggPSAiUmVsYXRpdmUgaW5mbHVlbmNlICglKSIsDQogICAgICAgeSA9ICJNb2RlbCBwcmVkaWN0b3JzIiwNCiAgICAgICBmaWxsID0gIlJJID4gMSUiLA0KICAgICAgIGNvbG9yID0gIlJJID4gMSUiKQ0KcmVsX3Nicg0KIyBnZ3NhdmUoImZpZ3MvdmFyX2luZmx1ZW5jZS5wbmciLGRwaSA9IDYwMCwgaGVpZ2h0ID0gNCwgd2lkdGggPSA2KQ0KYGBgDQoNClBhcnRpYWwgZGVwZW5kZW5jZSBwbG90cw0KDQpgYGB7cn0NCmdibS5maXQuZmluYWxfc2JyICU+JQ0KICBwZHA6OnBhcnRpYWwocHJlZC52YXIgPSAiSFVFIiwgbi50cmVlcyA9IGdibS5maXQuZmluYWxfc2JyJG4udHJlZXMsIGdyaWQucmVzb2x1dGlvbiA9IDEwMCkgJT4lDQogIGdncGxvdChhZXMoIEhVRSwoeWhhdCkpKSsNCiAgZ2VvbV9saW5lKCkNCmBgYA0KDQpMSU1FDQoNCmBgYHtyfQ0KbGlicmFyeShsaW1lKQ0KYGBgDQoNCmBgYHtyfQ0KbW9kZWxfdHlwZS5nYm0gPC0gZnVuY3Rpb24oeCwgLi4uKSB7DQogIHJldHVybigicmVncmVzc2lvbiIpDQp9DQoNCnByZWRpY3RfbW9kZWwuZ2JtIDwtIGZ1bmN0aW9uKHgsIG5ld2RhdGEsIC4uLikgew0KICBwcmVkIDwtIHByZWRpY3QoeCwgbmV3ZGF0YSwgbi50cmVlcyA9IHgkbi50cmVlcykNCiAgcmV0dXJuKGFzLmRhdGEuZnJhbWUocHJlZCkpDQp9DQpgYGANCg0KYGBge3J9DQojIGdldCBhIGZldyBvYnNlcnZhdGlvbnMgdG8gcGVyZm9ybSBsb2NhbCBpbnRlcnByZXRhdGlvbiBvbg0KbG9jYWxfb2JzIDwtIChhbGxfZGF0YV9zcHJlYWRfc2JyWy10cmFpbixdKVsxOjQsIF0NCg0KIyBhcHBseSBMSU1FDQpleHBsYWluZXIgPC0gbGltZShhbGxfZGF0YV9zcHJlYWRfc2JyW3RyYWluLF0sIGdibS5maXQuZmluYWxfc2JyKQ0KZXhwbGFuYXRpb24gPC0gbGltZTo6ZXhwbGFpbihsb2NhbF9vYnMsIGV4cGxhaW5lciwgbl9mZWF0dXJlcyA9IDcsIG4udHJlZXMgPTEpDQpwbG90X2ZlYXR1cmVzKGV4cGxhbmF0aW9uKQ0KDQoNCmBgYA0KDQojIyBQcmVkaWN0aW9uDQoNCmBgYHtyfQ0KIyBwcmVkaWN0IHZhbHVlcyBmb3IgdGVzdCBkYXRhDQpwcmVkIDwtIHByZWRpY3QoZ2JtLmZpdC5maW5hbF9zYnIsDQogICAgICAgICAgICAgICAgbi50cmVlcyA9IGdibS5maXQuZmluYWxfc2JyJG4udHJlZXMsDQogICAgICAgICAgICAgICAgYWxsX2RhdGFfc3ByZWFkX3NiclstdHJhaW4sXSkNCg0KIyByZXN1bHRzDQpjYXJldDo6Uk1TRSgocHJlZCksIGFsbF9kYXRhX3NwcmVhZF9zYnJbLXRyYWluLF0kc2V2KQ0KQ0NDKHByZWQsIGFsbF9kYXRhX3NwcmVhZF9zYnIkc2V2Wy10cmFpbl0pJHJoby5jJGVzdA0KY29yKHByZWQsIGFsbF9kYXRhX3NwcmVhZF9zYnIkc2V2Wy10cmFpbl0pXjINCg0KYGBgDQoNCmBgYHtyfQ0KYWNjdXJhY3lfc2JyID1kYXRhLmZyYW1lKHByZWRpPXByZWQsIGFjdHVhbCA9IGFsbF9kYXRhX3NwcmVhZF9zYnIkc2V2Wy10cmFpbl0pICU+JSANCiAgc3VtbWFyaXNlKFJNU0UgPSBjYXJldDo6Uk1TRShwcmVkLCBhY3R1YWwpLA0KICAgICAgICAgICAgciA9IGNvcihwcmVkLCBhY3R1YWwpLA0KICAgICAgICAgICAgcy5zaGlmdCA9IENDQyhwcmVkLCBhY3R1YWwpJHMuc2hpZnQsDQogICAgICAgICAgICBsLnNoaWZ0ID0gQ0NDKHByZWQsIGFjdHVhbCkkbC5zaGlmdCwNCiAgICAgICAgICAgIEMuYiA9IENDQyhwcmVkLCBhY3R1YWwpJEMuYiwNCiAgICAgICAgICAgIENDQyA9IENDQyhwcmVkLCBhY3R1YWwpJHJoby5jJGVzdCwNCiAgICAgICAgICAgIENJUyA9IHBhc3RlKA0KICByb3VuZChDQ0MocHJlZCwgYWxsX2RhdGFfc3ByZWFkX3NiciRzZXZbLXRyYWluXSkkcmhvLmNbMl0sMiksIiwiLCIgIiwNCiAgcm91bmQoQ0NDKHByZWQsIGFsbF9kYXRhX3NwcmVhZF9zYnIkc2V2Wy10cmFpbl0pJHJoby5jWzNdLDIpLHNlcCA9ICIiDQogICkpDQphY2N1cmFjeV9zYnINCmBgYA0KDQoNCiMjIyMgcGxvdA0KYGBge3J9DQoNCmNvbmNfc2JyID0gZGF0YS5mcmFtZShwcmVkaWN0ID0gcHJlZCwgYWN0dWFsID1hbGxfZGF0YV9zcHJlYWRfc2JyJHNldlstdHJhaW5dKSAlPiUgDQpnZ3Bsb3QoYWVzKGFjdHVhbCwgcHJlZGljdCApKSsNCiAgZ2VvbV9wb2ludChzaXplID0yLCBjb2xvciA9ICJncmF5IikrDQogIGdlb21fYWJsaW5lKGludGVyY2VwdCA9IDAsIHNsb3BlPSAxLCBzaXplID0gLjgxLCBjb2xvciA9ICJibGFjayIsIGxpbmV0eXBlID0gImRhc2hlZCIpKw0KICBnZW9tX3Ntb290aChtZXRob2QgPSAibG0iLCANCiAgICAgICAgICAgICAgY29sb3IgPSAicmVkIiwNCiAgICAgICAgICAgICAgc2l6ZSA9LjgxLCBzZSA9RiwNCiAgICAgICAgICAgICAgZnVsbHJhbmdlPVQpKw0KICB0aGVtZV9taW5pbWFsX2dyaWQoKSsNCiAgbGFicyh4ID0gIlByZWRpY3RlZCBTZXZlcml0eSAoJSkiLA0KICAgICAgIHkgPSAiQWN0dWFsIFNldmVyaXR5ICglKSIpKw0KICBjb29yZF9lcXVhbCh4bGltID0gYygwLDEwMCksDQogICAgICAgICAgICAgIHlsaW0gPSBjKDAsMTAwKSkrDQogIHhsaW0oMCwxMDApDQoNCg0KZ2dzYXZlKCJmaWdzL2NvbmNvcmRhbmNlLnBuZyIsIGRwaSA9IDYwMCwgaGVpZ2h0ID0gMy41LCB3aWR0aCA9IDQpDQoNCmBgYA0KDQojIFh5bGVsbGENCg0KYGBge3IgZXZhbD1GQUxTRSwgaW5jbHVkZT1UUlVFfQ0KcGljczwtbGlzdC5maWxlcygiLi9waWNzLzAxLVh5bGVsbGEtdG9iYWNjby1iZy13aGl0ZSIpDQojIGxlbmd0aChwaWNzKQ0KI2luZGljZXMNCmluZGV4ID0gYygiQkkiLCJTQ0kiLCJHTEkiLCJISSIsIlNJIiwiVkFSSSIsIkhVRSIsIkJHSSIsIk5HUkRJIikNCg0KDQpib3ggPSBkYXRhLmZyYW1lKCkNCg0KZm9yKGkgaW4gMTpsZW5ndGgocGljcykpew0KDQpFWC5MMTwtc3RhY2socGFzdGUoIi4vcGljcy8wMS1YeWxlbGxhLXRvYmFjY28tYmctd2hpdGUvIixwaWNzW2ldLHNlcCA9ICIiKSkNCkVYLkwxPC1hZ2dyZWdhdGUoRVguTDEsIGZhY3Q9NykNCkVYLkwuU2hhcGU8LWZpZWxkUG9seWdvbihtb3NhaWM9RVguTDEsIGV4dGVudD1ULCBwbG90ID0gRikNCg0KRVgxLkluZGljZXM8LSBmaWVsZEluZGV4KG1vc2FpYyA9IEVYLkwxLA0KICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaW5kZXgsIA0KICAgICAgICAgICAgICAgICAgICAgICAgIG15SW5kZXggPSBjKCJHcmVlbiIpLCBwbG90ID0gRikNCg0KRVguTDI8LWZpZWxkTWFzayhtb3NhaWM9RVguTDEsICBteUluZGV4ID0gYygiQmx1ZSIpLCBjcm9wVmFsdWU9MjAwLCBjcm9wQWJvdmU9VCwgcGxvdCA9IEYpDQoNCmN1dCA9IG1hc2soRVguTDEsIEVYLkwyJG5ld01vc2FpYykNCkVYLkw0PC1maWVsZEluZGV4KG1vc2FpYz1jdXQsDQogICAgICAgICAgICAgICAgICBpbmRleCA9aW5kZXgsDQogICAgICAgICAgICAgICAgICBwbG90ID1GKQ0KDQoNCmRmID0gYXMoRVguTDQsICJTcGF0aWFsUGl4ZWxzRGF0YUZyYW1lIikNCmRmZiA9IGFzLmRhdGEuZnJhbWUoZGYpICU+JSANCiAgbXV0YXRlKGdyYXkgPSAwLjI5OSpSZWQrMC41ODcqR3JlZW4rMC4xMTQqQmx1ZSkgJT4lIA0KICBnYXRoZXIoYygxOigzK2xlbmd0aChpbmRleCkpLDE1KSwga2V5ID0gImluZGV4IiwgdmFsdWUgPSAidmFsdWUiICkgJT4lDQogIGZpbHRlcighaXMubmEodmFsdWUpLA0KICAgICAgICAgIWlzLmluZmluaXRlKHZhbHVlKSkgJT4lIA0KICBncm91cF9ieShpbmRleCkgJT4lIA0KICBkcGx5cjo6c3VtbWFyaXNlKG1lYW4gPSBtZWFuKHZhbHVlLCBuYS5ybSA9IFQpLA0KICAgICAgICAgICAgc3RkID0gc2QodmFsdWUpLA0KICAgICAgICAgICAgUTI1ID0gcXVhbnRpbGUodmFsdWUsMC4yNSksDQogICAgICAgICAgICBRNTAgPSBxdWFudGlsZSh2YWx1ZSwwLjUwKSwNCiAgICAgICAgICAgIFE3NSA9IHF1YW50aWxlKHZhbHVlLDAuNzUpKSAlPiUgDQogIG11dGF0ZShsZWFmID0gcGljc1tpXSkNCg0KDQpib3ggPSBib3ggJT4lIA0KICBiaW5kX3Jvd3MoZGZmKX0NCmxlbmd0aCh1bmlxdWUoYm94JGxlYWYpKQ0Kd3JpdGUudGFibGUoYm94LCJkYXRhL2luZGV4ZXNfWHlsZWxsYS50eHQiKQ0KYGBgDQoNCmBgYHtyfQ0KYm94ID0gcmVhZC50YWJsZSgiZGF0YS9pbmRleGVzX1h5bGVsbGEudHh0IikNCmBgYA0KDQojIyBMb2FkDQpgYGB7cn0NCmRhdGFfeHlfbG9hZCA9IHJlYWRfY3N2KCJkYXRhX3BpY3MvMDEtWHlsZWxsYS10b2JhY2NvLXNldmVyaXR5LmNzdiIpICU+JSANCiAgbXV0YXRlKGZpbGUgPSBhcy5jaGFyYWN0ZXIoRmlsZSkpICU+JSANCiAgZHBseXI6OnNlbGVjdCgtRmlsZSkNCmBgYA0KDQpgYGB7cn0NCmRhdGFfeHkgPSBib3ggJT4lIA0KICBzZXBhcmF0ZShsZWFmLCBpbnRvPWMoImZpbGUiLCJmb3JtYXQiKSwgc2VwID0iLmpwZyIpICU+JSANCiAgZHBseXI6OnNlbGVjdCgtZm9ybWF0KSAlPiUgDQogIGZ1bGxfam9pbihkYXRhX3h5X2xvYWQsIGJ5PSJmaWxlIikgJT4lIA0KICBtdXRhdGUoc2V2PUltYWdlSikNCmhlYWQoZGF0YV94eSkNCg0KIyBsZW5ndGgodW5pcXVlKGRhdGFfeHkkc2V2KSkNCmBgYA0KDQpgYGB7cn0NCnN1bW1hcnkoZGF0YV94eSRzZXYpDQpgYGANCg0KDQojIyMgSW1hZ2VzDQoNCmBgYHtyfQ0KaGlzdF9zZXZfeHkgPSAgZGF0YV94eSAlPiUgDQogIHBpdm90X3dpZGVyKGlkX2NvbCA9IGMoZmlsZSxzZXYpLA0KICAgICAgICAgICAgICBuYW1lc19mcm9tID0gaW5kZXgsIA0KICAgICAgICAgICAgICB2YWx1ZXNfZnJvbSA9ICBtZWFuKSAlPiUNCiAgZ2dwbG90KGFlcyhzZXYpKSsNCiAgZ2VvbV9oaXN0b2dyYW0oY29sb3IgPSAid2hpdGUiLCBmaWxsID0gImJsYWNrIiwgYmlucyA9IDIwKSsNCiAgdGhlbWVfbWluaW1hbF9oZ3JpZChmb250X3NpemUgPSAxMCkrDQogIGxhYnMoeCA9ICJTZXZlcml0eSAoJSkiLA0KICAgICAgIHkgPSAiRnJlcXVlbmN5IikrDQogIHNjYWxlX3hfY29udGludW91cyhsaW1pdHMgPSBjKC01LDEwNSksIGJyZWFrcyA9IHNlcSgwLDEwMCwyNSkpKw0KICAjIHRoZW1lX3ZvaWQoKSsNCiAgIyBjb29yZF9maXhlZCgpKw0KICB0aGVtZShwYW5lbC5iYWNrZ3JvdW5kID0gZWxlbWVudF9yZWN0KGNvbG9yID0gImJsYWNrIikpDQoNCmBgYA0KDQpgYGB7cn0NCkVYLkwxPC1zdGFjayhwYXN0ZSgiLi9waWNzLzAxLVh5bGVsbGEtdG9iYWNjby1iZy13aGl0ZS8iLCI3NS5qcGciLHNlcCA9ICIiKSkNCkVYLkwxPC1hZ2dyZWdhdGUoRVguTDEsIGZhY3Q9NykNCkVYLkwuU2hhcGU8LWZpZWxkUG9seWdvbihtb3NhaWM9RVguTDEsIGV4dGVudD1ULCBwbG90ID0gRikNCg0KRVgxLkluZGljZXM8LSBmaWVsZEluZGV4KG1vc2FpYyA9IEVYLkwxLA0KICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaW5kZXgsIA0KICAgICAgICAgICAgICAgICAgICAgICAgIG15SW5kZXggPSBjKCJHcmVlbiIpLCBwbG90ID0gRikNCg0KRVguTDI8LWZpZWxkTWFzayhtb3NhaWM9RVguTDEsICBteUluZGV4ID0gYygiQmx1ZSIpLCBjcm9wVmFsdWU9MjAwLCBjcm9wQWJvdmU9VCwgcGxvdCA9IEYpDQoNCmN1dCA9IG1hc2soRVguTDEsIEVYLkwyJG5ld01vc2FpYykNCkVYLkw0PC1maWVsZEluZGV4KG1vc2FpYz1jdXQsDQogICAgICAgICAgICAgICAgICBpbmRleCA9aW5kZXgsDQogICAgICAgICAgICAgICAgICBwbG90ID1GKQ0KIyBwbG90KEVYLkw0JEhVRSkNCmBgYA0KDQpgYGB7cn0NCnJnYl9maWdfeHkgPSBSU3Rvb2xib3g6OmdnUkdCKEVYLkwyJG5ld01vc2FpYywNCiAgICAgICAgICAgICAgICAgciA9IDEsDQogICAgICAgICAgICAgICAgIGcgPSAyLA0KICAgICAgICAgICAgICAgICBiID0gMykrDQogIHRoZW1lX21hcCgpKw0KICBjb29yZF9maXhlZCgpKw0KICB0aGVtZShwYW5lbC5iYWNrZ3JvdW5kID0gZWxlbWVudF9yZWN0KGNvbG9yID0gIndoaXRlIikpDQoNCg0KZ2xpX2ZpZ194eSA9IGFzLmRhdGEuZnJhbWUoRVguTDQkSFVFLCB4eT1UUlVFLCBuYS5ybSA9VCkgJT4lIA0KICBnZ3Bsb3QoYWVzKHgsIHksIGZpbGwgPSBIVUUpKSsNCiAgZ2VvbV90aWxlKCkrDQogIHNjYWxlX2ZpbGxfdmlyaWRpc19jKG9wdGlvbiA9ICJCIixkaXJlY3Rpb24gPSAtMSkrDQogIHRoZW1lX21hcCgpKw0KICBjb29yZF9maXhlZCgpKw0KICB0aGVtZShwYW5lbC5iYWNrZ3JvdW5kID0gZWxlbWVudF9yZWN0KGNvbG9yID0gIndoaXRlIiksDQogICAgICAgIGxlZ2VuZC50aXRsZSA9IGVsZW1lbnRfdGV4dChzaXplID0gOCksDQogICAgICAgIGxlZ2VuZC50ZXh0ID0gZWxlbWVudF90ZXh0KHNpemUgPSA4KSkNCg0KIyByZ2JfZmlnX3h5KyBnbGlfZmlnX3h5DQpgYGANCg0KYGBge3J9DQojIHJnYl9maWdfc2JyICsgZ2xpX2ZpZ19zYnIgKyBoaXN0X3Nldl9zYnIgIysNCiMgICByZ2JfZmlnX3dsYiArIGdsaV9maWdfd2xiICsgaGlzdF9zZXZfV0xCKw0KICByZ2JfZmlnX3h5ICsgZ2xpX2ZpZ194eSAraGlzdF9zZXZfeHkNCiMgICAgcGxvdF9sYXlvdXQod2lkdGhzID0gYygxLCAxLCAxKSwNCiMgICAgICAgICAgICAgICAgaGVpZ2h0cyA9IGMoMSwxLDEpKQ0KIyANCiMgZ2dzYXZlKCJmaWdzL2xlYWZfZ2xpLnBuZyIsZHBpID0gNjAwLCBoZWlnaHQgPSA3LCB3aWR0aCA9OCkNCmBgYA0KDQojIyMgUmVsYXRpb25zaGlwIHNldiBpbmRpY2VzDQoNCmBgYHtyfQ0KcmdiX2dnX3h5ID0gZGF0YV94eSAlPiUgDQogIGZpbHRlcihpbmRleCAlaW4lIGMoIlJlZCIsICJCbHVlIiwgIkdyZWVuIikpICU+JSANCiAgICBnZ3Bsb3QoYWVzKG1lYW4sIHNldiwgY29sb3IgPSBpbmRleCkpICsgDQogICMgZ2VvbV90ZXh0KCkrDQogIGdlb21fcG9pbnQoY29sb3IgPSAiZ3JheSIsIHNpemUgID0zKSsNCiAgZ2VvbV9zbW9vdGgoc2UgPSBGLCBzaXplID0gMikrDQogIGZhY2V0X3dyYXAofmluZGV4LCBzY2FsZXMgPSAiZnJlZV94IiwgbnJvdyA9MSkrDQogIHNjYWxlX2NvbG9yX21hbnVhbCh2YWx1ZXMgPSBjKCJzdGVlbGJsdWUiLCJkYXJrZ3JlZW4iLCAiZGFya3JlZCIpKSsNCiAgdGhlbWVfbWluaW1hbF9oZ3JpZCgpKw0KICBsYWJzKHggPSAiTWVhbiB2YWx1ZSBpbiB0aGUgaW1hZ2UiLA0KICAgICAgIHkgPSAiRGlzZWFzZSBzZXZlcml0eSAoJSkiKSsNCiAgdGhlbWUocGFuZWwuYm9yZGVyID0gZWxlbWVudF9yZWN0KGNvbG9yID0gImdyYXkiKSkrDQogIHRoZW1lKGxlZ2VuZC5wb3NpdGlvbiA9ICJub25lIikNCnJnYl9nZ194eQ0KYGBgDQoNCmBgYHtyfQ0KaW5kZXhfZ2dfeHkgPSBkYXRhX3h5ICU+JSANCiAgZmlsdGVyKCFpbmRleCAlaW4lIGMoIlJlZCIsICJCbHVlIiwgIkdyZWVuIikpICU+JSANCiAgICBnZ3Bsb3QoYWVzKG1lYW4sIHNldikpICsgDQogICMgZ2VvbV90ZXh0KCkrDQogIGdlb21fcG9pbnQoY29sb3IgPSAiZ3JheSIsIHNpemUgID0zKSsNCiAgZ2VvbV9zbW9vdGgoY29sb3IgPSAiYmxhY2siLCBzZSA9IEYsIHNpemUgPSAyKSsNCiAgZmFjZXRfd3JhcCh+aW5kZXgsIHNjYWxlcyA9ICJmcmVlX3giLCBucm93ID0yKSsNCiAgdGhlbWVfbWluaW1hbF9oZ3JpZCgpKw0KICBsYWJzKHggPSAiTWVhbiBpbmRleCB2YWx1ZSBpbiB0aGUgaW1hZ2UiLA0KICAgICAgIHkgPSAiRGlzZWFzZSBzZXZlcml0eSAoJSkiKSsNCiAgdGhlbWUocGFuZWwuYm9yZGVyID0gZWxlbWVudF9yZWN0KGNvbG9yID0gImdyYXkiKSkNCmluZGV4X2dnX3h5DQpgYGANCg0KYGBge3J9DQpwbG90X2dyaWQoDQogIHBsb3RfZ3JpZChOVUxMLHJnYl9nZ194eSxOVUxMLCByZWxfd2lkdGhzID1jKDAuMTgsMSwwLjIpLCBucm93ID0gMSksDQogICAgICAgICAgaW5kZXhfZ2dfeHksDQogICAgICAgICAgbnJvdyA9IDIsDQogICAgICAgICAgcmVsX2hlaWdodHMgPSBjKDAuNSwxKSkNCmdnc2F2ZSgiZmlncy9pbmRleF9zZXZfWFkucG5nIiwgZHBpID0gNTAwLCBoZWlnaHQgPSA4LCB3aWR0aCA9IDEwKQ0KYGBgDQoNCmBgYHtyfQ0KY29yX3h5ID0gZGF0YV94eSAlPiUgDQogIGdyb3VwX2J5KGluZGV4KSAlPiUgDQogIGRwbHlyOjpzdW1tYXJpc2UoY29yID0gcm91bmQoICBjb3IudGVzdChtZWFuLHNldiwgbWV0aG9kID0gInNwZWFybWFuIikkZXN0aW1hdGUsMyksDQogICAgICAgICAgICAgICAgICAgUF92YWx1ZSA9IHJvdW5kKGNvci50ZXN0KG1lYW4sc2V2LCBtZXRob2QgPSAic3BlYXJtYW4iKSRwLnZhbHVlLDQpKSAlPiUgDQogIGFycmFuZ2UoLWNvcikNCmNvcl94eQ0KYGBgDQoNCiMjIyBTcHJlYWQgZGYNCg0KYGBge3J9DQphbGxfZGF0YV9zcHJlYWRfeHkgPSBkYXRhX3h5ICU+JSANCiAgcGl2b3Rfd2lkZXIoaWRfY29sID0gYyhmaWxlLHNldiksDQogICAgICAgICAgICAgIG5hbWVzX2Zyb20gPSBpbmRleCwgDQogICAgICAgICAgICAgIHZhbHVlc19mcm9tID0gIG1lYW4pICAgDQoNCmhlYWQoYWxsX2RhdGFfc3ByZWFkX3h5KQ0KYGBgDQoNCiMjIEdCTQ0KDQpgYGB7cn0NCnRyYWluPXNhbXBsZSh4ID0gMTpsZW5ndGgoYWxsX2RhdGFfc3ByZWFkX3h5JHNldiksIA0KICAgICAgICAgICAgIHNpemUgPSByb3VuZCgwLjc1Kmxlbmd0aChhbGxfZGF0YV9zcHJlYWRfeHkkc2V2KSwxKSkNCiMgbGVuZ3RoKHRyYWluKQ0KZ2JtLmZpdCA9IGdibShzZXYgfkJHSStCSStHTEkrSEkrSFVFK05HUkRJK1ZBUkkrZ3JheSsgUmVkK0dyZWVuK0JsdWUgICsgU0kgKyBTQ0ksDQogICAgICAgICAgICAgZGF0YSA9IGFsbF9kYXRhX3NwcmVhZF94eVt0cmFpbixdLA0KICAgICAgICAgICAgIGRpc3RyaWJ1dGlvbiA9ICJnYXVzc2lhbiIsDQogICAgICAgICAgICAgIG4udHJlZXMgPSAxMDAwLA0KICAgICAgICAgICAgIGludGVyYWN0aW9uLmRlcHRoID0gMywNCiAgICAgICAgICAgICBzaHJpbmthZ2UgPSAwLjEsDQogICAgICAgICAgICAgY3YuZm9sZHMgPSA1LA0KICAgICAgICAgICAgIG4uY29yZXMgPSBOVUxMLCAjIHdpbGwgdXNlIGFsbCBjb3JlcyBieSBkZWZhdWx0DQogICAgICAgICAgICAgdmVyYm9zZSA9IEZBTFNFKQ0KcHJpbnQoZ2JtLmZpdCkNCnNxcnQobWluKGdibS5maXQkY3YuZXJyb3IpKQ0KYGBgDQoNCmBgYHtyfQ0KZ2JtLnBlcmYoZ2JtLmZpdCwgbWV0aG9kID0gImN2IikNCiMgZmluZCBpbmRleCBmb3IgbiB0cmVlcyB3aXRoIG1pbmltdW0gQ1YgZXJyb3INCmBgYA0KDQpgYGB7cn0NCm1pbl9NU0UgPC0gd2hpY2gubWluKGdibS5maXQkY3YuZXJyb3IpDQpzcXJ0KGdibS5maXQkY3YuZXJyb3JbbWluX01TRV0pDQoNCmBgYA0KDQpgYGB7cn0NCiMgYmVzdC5pdGVyIDwtIGdibS5wZXJmKG1vZGVsMSwgbWV0aG9kID0gInRlc3QiKQ0KIyBwcmludChiZXN0Lml0ZXIpDQoNCnByZWQgPSBwcmVkaWN0KGdibS5maXQsIG5ld2RhdGEgPSBhbGxfZGF0YV9zcHJlYWRfeHlbLXRyYWluLC0xXSwgbnRyZWVzID0gNTAwMCApDQoNCnNxcnQobWVhbigoKHByZWQpLWFsbF9kYXRhX3NwcmVhZF94eSRzZXZbLXRyYWluXSleMikpDQpDQ0MoKHByZWQpLCBhbGxfZGF0YV9zcHJlYWRfeHkkc2V2Wy10cmFpbl0pJHJoby5jJGVzdA0KDQpwbG90KChwcmVkKSwgKHByZWQpLWFsbF9kYXRhX3NwcmVhZF94eSRzZXZbLXRyYWluXSkNCmFibGluZShhPTAsYj0wKQ0KYGBgDQoNCiMjIyBUZXN0aW5nIHZhcmlvdXMgaHlwZXJwYXJhbWV0ZXJzDQoNCkNyZWF0ZSBoeXBlcnBhcmFtZXRlciBncmlkDQoNCmBgYHtyfQ0KDQpoeXBlcl9ncmlkIDwtIGV4cGFuZC5ncmlkKA0KICBzaHJpbmthZ2UgPSBjKC4wMDEsIC4wMSwgLjEsIC4zKSwNCiAgaW50ZXJhY3Rpb24uZGVwdGggPSBjKDEsIDMsIDUsIDYpLA0KICBuLm1pbm9ic2lubm9kZSA9IGMoNSwgMTAsIDE1KSwNCiAgYmFnLmZyYWN0aW9uID0gYyguNSwuNjUsIC44LCAxKSwgDQogIG9wdGltYWxfdHJlZXMgPSAwLCAgICAgICAgICAgICAgICMgYSBwbGFjZSB0byBkdW1wIHJlc3VsdHMNCiAgbWluX1JNU0UgPSAwLA0KICBDQ0MgPTAgIyBhIHBsYWNlIHRvIGR1bXAgcmVzdWx0cw0KKQ0KIyB0b3RhbCBudW1iZXIgb2YgY29tYmluYXRpb25zDQpucm93KGh5cGVyX2dyaWQpDQpgYGANCg0KYGBge3IgbWVzc2FnZT1GQUxTRSwgd2FybmluZz1GQUxTRX0NCiMgcmFuZG9taXplIGRhdGENCnNldC5zZWVkKDEyMykNCnRyYWluPXNhbXBsZSh4ID0gMTpsZW5ndGgoYWxsX2RhdGFfc3ByZWFkX3h5JHNldiksIA0KICAgICAgICAgICAgIHNpemUgPSByb3VuZCgwLjgwKmxlbmd0aChhbGxfZGF0YV9zcHJlYWRfeHkkc2V2KSwxKSkNCg0KIyBncmlkIHNlYXJjaCANCmZvcihpIGluIDE6bnJvdyhoeXBlcl9ncmlkKSkgew0KDQojIHJlcHJvZHVjaWJpbGl0eQ0Kc2V0LnNlZWQoMTIzKQ0KDQoNCiAjIHRyYWluIG1vZGVsDQpnYm0udHVuZSA8LSBnYm0oDQogIGZvcm11bGEgPSAoc2V2KSB+QkdJK0JJK0dMSStISStIVUUrTkdSREkrVkFSSStncmF5ICtSZWQrR3JlZW4rQmx1ZSArIFNJICsgU0NJLCAjPDw8PDwNCiAgZGF0YSA9IGFsbF9kYXRhX3NwcmVhZF94eVt0cmFpbixdLA0KICBkaXN0cmlidXRpb24gPSAiZ2F1c3NpYW4iLA0KICBuLnRyZWVzID0gNTAwMCwNCiAgaW50ZXJhY3Rpb24uZGVwdGggPSBoeXBlcl9ncmlkJGludGVyYWN0aW9uLmRlcHRoW2ldLA0KICBzaHJpbmthZ2UgPSBoeXBlcl9ncmlkJHNocmlua2FnZVtpXSwNCiAgbi5taW5vYnNpbm5vZGUgPSBoeXBlcl9ncmlkJG4ubWlub2JzaW5ub2RlW2ldLA0KICBiYWcuZnJhY3Rpb24gPSBoeXBlcl9ncmlkJGJhZy5mcmFjdGlvbltpXSwNCiAgdHJhaW4uZnJhY3Rpb24gPSAuNzUsDQogIG4uY29yZXMgPSBOVUxMLCAjIHdpbGwgdXNlIGFsbCBjb3JlcyBieSBkZWZhdWx0DQogIHZlcmJvc2UgPSBGQUxTRSkNCg0KcHJlZCA9IHByZWRpY3QoZ2JtLnR1bmUsIG5ld2RhdGEgPSBhbGxfZGF0YV9zcHJlYWRfeHlbLXRyYWluLC0xXSwgbnRyZWVzID0gNTAwMCApDQogIyBhZGQgbWluIHRyYWluaW5nIGVycm9yIGFuZCB0cmVlcyB0byBncmlkDQogIGh5cGVyX2dyaWQkb3B0aW1hbF90cmVlc1tpXSA8LSB3aGljaC5taW4oZ2JtLnR1bmUkdmFsaWQuZXJyb3IpDQogIGh5cGVyX2dyaWQkbWluX1JNU0VbaV0gPC0gc3FydChtaW4oZ2JtLnR1bmUkdmFsaWQuZXJyb3IpKQ0KICBoeXBlcl9ncmlkJENDQ1tpXSA9IENDQyhwcmVkLCBhbGxfZGF0YV9zcHJlYWRfeHkkc2V2Wy10cmFpbl0pJHJoby5jJGVzdCM8PDw8PA0KICANCn0NCg0KYmVzdF9wYXIgPSBoeXBlcl9ncmlkICU+JSANCiAgZHBseXI6OmFycmFuZ2UoLUNDQykgJT4lDQogIGhlYWQoMTApDQpiZXN0X3Bhcg0KDQoNCg0KIyBnYm0udHVuZSRmaXQNCmBgYA0KDQojIyMgQmVzdCBtb2RlbA0KDQpgYGB7cn0NCiMgZm9yIHJlcHJvZHVjaWJpbGl0eQ0Kc2V0LnNlZWQoMTIzKQ0KDQojIHRyYWluIEdCTSBtb2RlbA0KZ2JtLmZpdC5maW5hbF94eSA8LSBnYm0oDQogIGZvcm11bGEgPSAoc2V2KSB+QkdJK0JJK0dMSStISStIVUUrTkdSREkrVkFSSStSZWQrR3JlZW4rQmx1ZStncmF5K1NJK1NDSSwNCiAgZGF0YSA9IGFsbF9kYXRhX3NwcmVhZF94eVt0cmFpbixdLA0KICBkaXN0cmlidXRpb24gPSAiZ2F1c3NpYW4iLA0KICBuLnRyZWVzID0gYmVzdF9wYXIkb3B0aW1hbF90cmVlc1sxXSwNCiAgaW50ZXJhY3Rpb24uZGVwdGggPSBiZXN0X3BhciRpbnRlcmFjdGlvbi5kZXB0aFsxXSwNCiAgc2hyaW5rYWdlID0gYmVzdF9wYXIkc2hyaW5rYWdlWzFdLA0KICBuLm1pbm9ic2lubm9kZSA9IGJlc3RfcGFyJG4ubWlub2JzaW5ub2RlWzFdLA0KICBiYWcuZnJhY3Rpb24gPSBiZXN0X3BhciRiYWcuZnJhY3Rpb25bMV0sIA0KICB0cmFpbi5mcmFjdGlvbiA9MC43NSwNCiAgbi5jb3JlcyA9IE5VTEwsICMgd2lsbCB1c2UgYWxsIGNvcmVzIGJ5IGRlZmF1bHQNCiAgdmVyYm9zZSA9IEZBTFNFDQogICkNCg0KDQpgYGANCg0KIyMjIFJlbGF0aXZlIGluZmx1ZW5jZQ0KDQpgYGB7cn0NCnBhcihtYXIgPSBjKDUsIDgsIDEsIDEpKQ0Kc3VtbWFyeV9nYm1feHkgPSBzdW1tYXJ5KA0KICBnYm0uZml0LmZpbmFsX3h5LCANCiAgY0JhcnMgPSAxNSwNCiAgbWV0aG9kID0gcmVsYXRpdmUuaW5mbHVlbmNlLCAjIGFsc28gY2FuIHVzZSBwZXJtdXRhdGlvbi50ZXN0LmdibQ0KICBsYXMgPSAyDQogICkNCg0KcmVsX3h5ID0gc3VtbWFyeV9nYm1feHkgJT4lIA0KICByb3duYW1lc190b19jb2x1bW4oImluZGV4IikgJT4lIA0KICBnZ3Bsb3QoYWVzKHJlbC5pbmYsIHJlb3JkZXIodmFyLCByZWwuaW5mKSkpKw0KICBnZW9tX2NvbChhZXMoZmlsbCA9cmVsLmluZj4xLCBjb2xvciA9cmVsLmluZj4xICksIHdpZHRoID0gMC44NSkrDQogIHRoZW1lX21pbmltYWxfdmdyaWQoKSsNCiAgbGFicyh4ID0gIlJlbGF0aXZlIGluZmx1ZW5jZSAoJSkiLA0KICAgICAgIHkgPSAiTW9kZWwgcHJlZGljdG9ycyIsDQogICAgICAgZmlsbCA9ICJSSSA+IDElIiwNCiAgICAgICBjb2xvciA9ICJSSSA+IDElIikNCnJlbF94eQ0KIyBnZ3NhdmUoImZpZ3MvdmFyX2luZmx1ZW5jZS5wbmciLGRwaSA9IDYwMCwgaGVpZ2h0ID0gNCwgd2lkdGggPSA2KQ0KYGBgDQoNClBhcnRpYWwgZGVwZW5kZW5jZSBwbG90cw0KDQpgYGB7cn0NCmdibS5maXQuZmluYWxfeHkgJT4lDQogIHBkcDo6cGFydGlhbChwcmVkLnZhciA9ICJIVUUiLCBuLnRyZWVzID0gZ2JtLmZpdC5maW5hbF94eSRuLnRyZWVzLCBncmlkLnJlc29sdXRpb24gPSAxMDApICU+JQ0KICBnZ3Bsb3QoYWVzKCBIVUUsKHloYXQpKSkrDQogIGdlb21fbGluZSgpDQpgYGANCg0KTElNRQ0KDQpgYGB7cn0NCmxpYnJhcnkobGltZSkNCmBgYA0KDQpgYGB7cn0NCm1vZGVsX3R5cGUuZ2JtIDwtIGZ1bmN0aW9uKHgsIC4uLikgew0KICByZXR1cm4oInJlZ3Jlc3Npb24iKQ0KfQ0KDQpwcmVkaWN0X21vZGVsLmdibSA8LSBmdW5jdGlvbih4LCBuZXdkYXRhLCAuLi4pIHsNCiAgcHJlZCA8LSBwcmVkaWN0KHgsIG5ld2RhdGEsIG4udHJlZXMgPSB4JG4udHJlZXMpDQogIHJldHVybihhcy5kYXRhLmZyYW1lKHByZWQpKQ0KfQ0KYGBgDQoNCmBgYHtyfQ0KIyBnZXQgYSBmZXcgb2JzZXJ2YXRpb25zIHRvIHBlcmZvcm0gbG9jYWwgaW50ZXJwcmV0YXRpb24gb24NCmxvY2FsX29icyA8LSAoYWxsX2RhdGFfc3ByZWFkX3h5Wy10cmFpbixdKVsxOjQsIF0NCg0KIyBhcHBseSBMSU1FDQpleHBsYWluZXIgPC0gbGltZShhbGxfZGF0YV9zcHJlYWRfeHlbdHJhaW4sXSwgZ2JtLmZpdC5maW5hbF94eSkNCmV4cGxhbmF0aW9uIDwtIGxpbWU6OmV4cGxhaW4obG9jYWxfb2JzLCBleHBsYWluZXIsIG5fZmVhdHVyZXMgPSA3LCBuLnRyZWVzID0xKQ0KcGxvdF9mZWF0dXJlcyhleHBsYW5hdGlvbikNCg0KDQpgYGANCg0KIyMgUHJlZGljdGlvbg0KDQpgYGB7cn0NCiMgcHJlZGljdCB2YWx1ZXMgZm9yIHRlc3QgZGF0YQ0KcHJlZCA8LSBwcmVkaWN0KGdibS5maXQuZmluYWxfeHksDQogICAgICAgICAgICAgICAgbi50cmVlcyA9IGdibS5maXQuZmluYWxfeHkkbi50cmVlcywNCiAgICAgICAgICAgICAgICBhbGxfZGF0YV9zcHJlYWRfeHlbLXRyYWluLF0pDQoNCiMgcmVzdWx0cw0KY2FyZXQ6OlJNU0UoKHByZWQpLCBhbGxfZGF0YV9zcHJlYWRfeHlbLXRyYWluLF0kc2V2KQ0KQ0NDKChwcmVkKSwgYWxsX2RhdGFfc3ByZWFkX3h5JHNldlstdHJhaW5dKSRyaG8uYyRlc3QNCmNvcigocHJlZCksIGFsbF9kYXRhX3NwcmVhZF94eSRzZXZbLXRyYWluXSleMg0KDQpgYGANCg0KYGBge3J9DQphY2N1cmFjeV94eSA9ZGF0YS5mcmFtZShwcmVkaT1wcmVkLCBhY3R1YWwgPSBhbGxfZGF0YV9zcHJlYWRfeHkkc2V2Wy10cmFpbl0pICU+JSANCiAgc3VtbWFyaXNlKFJNU0UgPSBjYXJldDo6Uk1TRShwcmVkLCBhY3R1YWwpLA0KICAgICAgICAgICAgciA9IGNvcihwcmVkLCBhY3R1YWwpLA0KICAgICAgICAgICAgcy5zaGlmdCA9IENDQyhwcmVkLCBhY3R1YWwpJHMuc2hpZnQsDQogICAgICAgICAgICBsLnNoaWZ0ID0gQ0NDKHByZWQsIGFjdHVhbCkkbC5zaGlmdCwNCiAgICAgICAgICAgIEMuYiA9IENDQyhwcmVkLCBhY3R1YWwpJEMuYiwNCiAgICAgICAgICAgIENDQyA9IENDQyhwcmVkLCBhY3R1YWwpJHJoby5jJGVzdCwNCiAgICAgICAgICAgIENJUyA9IHBhc3RlKA0KICByb3VuZChDQ0MocHJlZCwgYWxsX2RhdGFfc3ByZWFkX3h5JHNldlstdHJhaW5dKSRyaG8uY1syXSwyKSwiLCIsIiAiLA0KICByb3VuZChDQ0MocHJlZCwgYWxsX2RhdGFfc3ByZWFkX3h5JHNldlstdHJhaW5dKSRyaG8uY1szXSwyKSxzZXAgPSAiIg0KICApKQ0KYWNjdXJhY3lfeHkNCmBgYA0KDQoNCiMjIyMgcGxvdA0KYGBge3J9DQoNCmNvbmNfeHkgPSBkYXRhLmZyYW1lKHByZWRpY3QgPSBwcmVkLCBhY3R1YWwgPWFsbF9kYXRhX3NwcmVhZF94eSRzZXZbLXRyYWluXSkgJT4lIA0KZ2dwbG90KGFlcyhhY3R1YWwscHJlZGljdCkpKw0KICBnZW9tX3BvaW50KHNpemUgPTIsIGNvbG9yID0gImdyYXkiKSsNCiAgZ2VvbV9hYmxpbmUoaW50ZXJjZXB0ID0gMCwgc2xvcGU9IDEsIHNpemUgPSAuODEsIGNvbG9yID0gImJsYWNrIiwgbGluZXR5cGUgPSAiZGFzaGVkIikrDQogIGdlb21fc21vb3RoKG1ldGhvZCA9ICJsbSIsIA0KICAgICAgICAgICAgICBjb2xvciA9ICJyZWQiLA0KICAgICAgICAgICAgICBzaXplID0uODEsIHNlID1GLA0KICAgICAgICAgICAgICBmdWxscmFuZ2U9VCkrDQogIHRoZW1lX21pbmltYWxfZ3JpZCgpKw0KICBsYWJzKHggPSAiUHJlZGljdGVkIFNldmVyaXR5ICglKSIsDQogICAgICAgeSA9ICJBY3R1YWwgU2V2ZXJpdHkgKCUpIikrDQogIGNvb3JkX2VxdWFsKHhsaW0gPSBjKDAsMTAwKSwNCiAgICAgICAgICAgICAgeWxpbSA9IGMoMCwxMDApKSsNCiAgeGxpbSgwLDEwMCkNCg0KDQpnZ3NhdmUoImZpZ3MvY29uY29yZGFuY2UucG5nIiwgZHBpID0gNjAwLCBoZWlnaHQgPSAzLjUsIHdpZHRoID0gNCkNCg0KYGBgDQoNCiMgTGF0ZSBibGlnaHQNCg0KYGBge3IgZXZhbD1GQUxTRSwgaW5jbHVkZT1UUlVFfQ0KcGljczwtbGlzdC5maWxlcygiLi9waWNzLzAxIC0gUExCIikNCiMgbGVuZ3RoKHBpY3MpDQojaW5kaWNlcw0KaW5kZXggPSBjKCJCSSIsIlNDSSIsIkdMSSIsIkhJIiwiU0kiLCJWQVJJIiwiSFVFIiwiQkdJIiwiTkdSREkiKQ0KDQoNCmJveCA9IGRhdGEuZnJhbWUoKQ0KDQpmb3IoaSBpbiAxOmxlbmd0aChwaWNzKSl7DQoNCkVYLkwxPC1zdGFjayhwYXN0ZSgiLi9waWNzLzAxIC0gUExCLyIscGljc1tpXSxzZXAgPSAiIikpDQpFWC5MMTwtYWdncmVnYXRlKEVYLkwxLCBmYWN0PTQpDQpFWC5MLlNoYXBlPC1maWVsZFBvbHlnb24obW9zYWljPUVYLkwxLCBleHRlbnQ9VCwgcGxvdCA9IEYpDQoNCiMgRVgxLkluZGljZXM8LSBmaWVsZEluZGV4KG1vc2FpYyA9IEVYLkwxLA0KIyAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBjKCJOR1JESSIsIkJHSSIsIkdMSSIsICJTQ0kiLCJISSIsICJTSSIpLCANCiMgICAgICAgICAgICAgICAgICAgICAgICAgIG15SW5kZXggPSBjKCIoUmVkLUJsdWUpL0dyZWVuIiksIHBsb3QgPSBGKQ0KDQpFWC5MMjwtZmllbGRNYXNrKG1vc2FpYz1FWC5MMSwgbXlJbmRleCA9IlJlZCIsIGNyb3BWYWx1ZT0xLCBjcm9wQWJvdmU9RiwgcGxvdCA9IEYpDQoNCmN1dCA9IG1hc2soRVguTDEsIEVYLkwyJG1hc2spDQpFWC5MNDwtZmllbGRJbmRleChtb3NhaWM9Y3V0LA0KICAgICAgICAgICAgICAgICAgaW5kZXggPWluZGV4LA0KICAgICAgICAgICAgICAgICAgcGxvdCA9RikNCg0KDQpkZiA9IGFzKEVYLkw0LCAiU3BhdGlhbFBpeGVsc0RhdGFGcmFtZSIpDQpkZmYgPSBhcy5kYXRhLmZyYW1lKGRmKSAlPiUgDQogIG11dGF0ZShncmF5ID0gMC4yOTkqUmVkKzAuNTg3KkdyZWVuKzAuMTE0KkJsdWUpICU+JSANCiAgZ2F0aGVyKGMoMTooMytsZW5ndGgoaW5kZXgpKSwxNSksIGtleSA9ICJpbmRleCIsIHZhbHVlID0gInZhbHVlIiApICU+JQ0KICBmaWx0ZXIoIWlzLm5hKHZhbHVlKSwNCiAgICAgICAgICFpcy5pbmZpbml0ZSh2YWx1ZSkpICU+JSANCiAgZ3JvdXBfYnkoaW5kZXgpICU+JSANCiAgZHBseXI6OnN1bW1hcmlzZShtZWFuID0gbWVhbih2YWx1ZSwgbmEucm0gPSBUKSwNCiAgICAgICAgICAgIHN0ZCA9IHNkKHZhbHVlKSwNCiAgICAgICAgICAgIFEyNSA9IHF1YW50aWxlKHZhbHVlLDAuMjUpLA0KICAgICAgICAgICAgUTUwID0gcXVhbnRpbGUodmFsdWUsMC41MCksDQogICAgICAgICAgICBRNzUgPSBxdWFudGlsZSh2YWx1ZSwwLjc1KSkgJT4lIA0KICBtdXRhdGUobGVhZiA9IHBpY3NbaV0pDQoNCg0KYm94ID0gYm94ICU+JSANCiAgYmluZF9yb3dzKGRmZil9DQpsZW5ndGgodW5pcXVlKGJveCRsZWFmKSkNCndyaXRlLnRhYmxlKGJveCwiZGF0YS9pbmRleGVzX1BMQi50eHQiKQ0KYGBgDQoNCmBgYHtyfQ0KYm94ID0gcmVhZC50YWJsZSgiZGF0YS9pbmRleGVzX1BMQi50eHQiKQ0KYGBgDQoNCiMjIExvYWQgc2V2ZXJpdHkgZGF0YQ0KDQpgYGB7cn0NCmxpYnJhcnkoZ3NoZWV0KQ0KDQoNCnNldl9kYXRhX3BsYjIgPSBnc2hlZXQydGJsKCJodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9zcHJlYWRzaGVldHMvZC8xY254R1BYQllWUjlscTBJbktoaE1NanItY1EyMXZDZjNxNml3OFZFaTZwWS9lZGl0I2dpZD00NDUwNzQ0NzYiKSAlPiUgDQogIHVuaXRlKCJmaWxlIiwxOjIsIHNlcCA9ICIuIikNCg0KDQoNCmxlbmd0aCh1bmlxdWUoc2V2X2RhdGFfcGxiMiRmaWxlKSkNCmBgYA0KDQpgYGB7cn0NCiNuZXcgZXZhbHVhdGlvbg0KYWxsX2RhdGFfUEkgPSBib3ggJT4lIA0KICBtdXRhdGUoZmlsZSA9IGxlYWYpICU+JSANCiAgZHBseXI6OnNlbGVjdCgtbGVhZikgJT4lIA0KICAjIHNlcGFyYXRlKGZpbGUsIGludG8gPSBjKCJmaWxlIiwgImZvcm1hdCIpLCBzZXAgPSAiLiIpICU+JSANCiAgIyBkcGx5cjo6c2VsZWN0KC1mb3JtYXQpICU+JQ0KICByaWdodF9qb2luKHNldl9kYXRhX3BsYjIpDQpgYGANCg0KYGBge3J9DQojIGFsbF9kYXRhX1BJID0gYm94ICU+JSANCiMgICBtdXRhdGUoZmlsZSA9IGxlYWYpICU+JSANCiMgICBkcGx5cjo6c2VsZWN0KC1sZWFmKSAlPiUgDQojICAgcmlnaHRfam9pbihzZXZfZGF0YSkgIyU+JSANCiMgICAjIGZpbHRlcihzZXY+MCkgJT4lIA0KIyAgICMgbXV0YXRlKHNldiA9IGNhc2Vfd2hlbihzZXY9PTAgfjAuMDAxLA0KIyAgICMgICAgICAgICAgICAgICAgICAgICAgICBzZXYgPjAgfnNldikpDQpgYGANCg0KYGBge3J9DQpzdW1tYXJ5KGFsbF9kYXRhX1BJJHNldikNCmBgYA0KDQojIyMgSW1hZ2VzDQoNCmBgYHtyfQ0KaGlzdF9zZXZfcGkgPSAgYWxsX2RhdGFfUEkgJT4lIA0KICBwaXZvdF93aWRlcihpZF9jb2wgPSBjKGZpbGUsc2V2KSwNCiAgICAgICAgICAgICAgbmFtZXNfZnJvbSA9IGluZGV4LCANCiAgICAgICAgICAgICAgdmFsdWVzX2Zyb20gPSAgbWVhbikgJT4lIA0KICBnZ3Bsb3QoYWVzKHNldikpKw0KICBnZW9tX2hpc3RvZ3JhbShjb2xvciA9ICJ3aGl0ZSIsIGZpbGwgPSAiYmxhY2siLCBiaW5zID0yMCkrDQogIHRoZW1lX21pbmltYWxfaGdyaWQoZm9udF9zaXplID0gMTApKw0KICBsYWJzKHggPSAiU2V2ZXJpdHkgKCUpIiwNCiAgICAgICB5ID0gIkZyZXF1ZW5jeSIpKw0KICBzY2FsZV94X2NvbnRpbnVvdXMobGltaXRzID0gYygtNSwxMDUpLCBicmVha3MgPSBzZXEoMCwxMDAsMjUpKSsNCiAgIyB0aGVtZV92b2lkKCkrDQogICMgY29vcmRfZml4ZWQoKSsNCiAgdGhlbWUocGFuZWwuYmFja2dyb3VuZCA9IGVsZW1lbnRfcmVjdChjb2xvciA9ICJibGFjayIpLA0KICAgICAgICBheGlzLnRpdGxlLnkgPSBlbGVtZW50X3RleHQoc2l6ZT04KSkNCg0KYGBgDQoNCmBgYHtyfQ0KRVguTDE8LXN0YWNrKHBhc3RlKCIuL3BpY3MvMDEtcG90YXRvX2xhdGVfYmxpZ2gvIiwiUEkyMV8yRC5wbmciLHNlcCA9ICIiKSkNCkVYLkwxPC1hZ2dyZWdhdGUoRVguTDEsIGZhY3Q9MTApDQpFWC5MLlNoYXBlPC1maWVsZFBvbHlnb24obW9zYWljPUVYLkwxLCBleHRlbnQ9VCwgcGxvdCA9IEYpDQoNCkVYMS5JbmRpY2VzPC0gZmllbGRJbmRleChtb3NhaWMgPSBFWC5MMSwNCiAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGluZGV4LCANCiAgICAgICAgICAgICAgICAgICAgICAgICBteUluZGV4ID0gYygiR3JlZW4iKSwgcGxvdCA9IEYpDQoNCkVYLkwyPC1maWVsZE1hc2sobW9zYWljPUVYLkwxLCAgbXlJbmRleCA9IGMoIlJlZCIpLCBjcm9wVmFsdWU9MSwgY3JvcEFib3ZlPUYsIHBsb3QgPSBGKQ0KDQpjdXQgPSBtYXNrKEVYLkwxLCBFWC5MMiRuZXdNb3NhaWMpDQpFWC5MNDwtZmllbGRJbmRleChtb3NhaWM9Y3V0LA0KICAgICAgICAgICAgICAgICAgaW5kZXggPWluZGV4LA0KICAgICAgICAgICAgICAgICAgcGxvdCA9IEYpDQojIHBsb3QoRVguTDQkSFVFKQ0KYGBgDQoNCmBgYHtyfQ0KcmdiX2ZpZ19waSA9IFJTdG9vbGJveDo6Z2dSR0IoRVguTDIkbmV3TW9zYWljLA0KICAgICAgICAgICAgICAgICByID0gMSwNCiAgICAgICAgICAgICAgICAgZyA9IDIsDQogICAgICAgICAgICAgICAgIGIgPSAzKSsNCiAgdGhlbWVfbWFwKCkrDQogIGNvb3JkX2ZpeGVkKCkrDQogIHhsaW0oMjUwLDE1MDApKw0KICB5bGltKDUwLDEzMDApKw0KICB0aGVtZShwYW5lbC5iYWNrZ3JvdW5kID0gZWxlbWVudF9yZWN0KGNvbG9yID0gIndoaXRlIikpDQoNCg0KZ2xpX2ZpZ19waSA9IGFzLmRhdGEuZnJhbWUoRVguTDQkQkdJLCB4eT1UUlVFLCBuYS5ybSA9VCkgJT4lIA0KICBnZ3Bsb3QoYWVzKHgsIHksIGZpbGwgPSBCR0kpKSsNCiAgZ2VvbV90aWxlKCkrDQogIHNjYWxlX2ZpbGxfdmlyaWRpc19jKG9wdGlvbiA9ICJCIixkaXJlY3Rpb24gPSAtMSkrDQogIHRoZW1lX21hcCgpKw0KICBjb29yZF9maXhlZCgpKw0KICB4bGltKDI1MCwxNTAwKSsNCiAgeWxpbSg1MCwxMzAwKSsNCiAgdGhlbWUocGFuZWwuYmFja2dyb3VuZCA9IGVsZW1lbnRfcmVjdChjb2xvciA9ICJ3aGl0ZSIpLA0KICAgICAgICBsZWdlbmQudGl0bGUgPSBlbGVtZW50X3RleHQoc2l6ZSA9IDgpLA0KICAgICAgICBsZWdlbmQudGV4dCA9IGVsZW1lbnRfdGV4dChzaXplID0gOCkpDQoNCiMgcmdiX2ZpZ19waSArIGdsaV9maWdfcGkNCg0KYGBgDQoNCmBgYHtyfQ0KIyByZ2JfZmlnX3NiciArIGdsaV9maWdfc2JyICsgaGlzdF9zZXZfc2JyICMrDQojICAgcmdiX2ZpZ193bGIgKyBnbGlfZmlnX3dsYiArIGhpc3Rfc2V2X1dMQisNCiMgICByZ2JfZmlnX3h5ICsgZ2xpX2ZpZ194eSAraGlzdF9zZXZfeHkrDQogIHJnYl9maWdfcGkgKyBnbGlfZmlnX3BpICtoaXN0X3Nldl9waQ0KIyAgICBwbG90X2xheW91dCh3aWR0aHMgPSBjKDEsIDEsIDEpLA0KIyAgICAgICAgICAgICAgICBoZWlnaHRzID0gYygxLDEsMSwxKSkrDQojICAgcGxvdF9hbm5vdGF0aW9uKHRhZ19sZXZlbHMgPSAnQScpDQoNCiMgZ2dzYXZlKCJmaWdzL2xlYWZfZ2xpLnBuZyIsZHBpID0gNjAwLCBoZWlnaHQgPSA4LCB3aWR0aCA9OCkNCmBgYA0KDQojIyMgUmVsYXRpb25zaGlwIHNldiBpbmRpY2VzDQoNCmBgYHtyfQ0KcmdiX2dnX3BpID0gYWxsX2RhdGFfUEkgJT4lIA0KICBmaWx0ZXIoaW5kZXggJWluJSBjKCJSZWQiLCAiQmx1ZSIsICJHcmVlbiIpKSAlPiUgDQogICAgZ2dwbG90KGFlcyhtZWFuLCBzZXYsIGNvbG9yID0gaW5kZXgpKSArIA0KICAjIGdlb21fdGV4dCgpKw0KICBnZW9tX3BvaW50KGNvbG9yID0gImdyYXkiLCBzaXplICA9MykrDQogIGdlb21fc21vb3RoKHNlID0gRiwgc2l6ZSA9IDIpKw0KICBmYWNldF93cmFwKH5pbmRleCwgc2NhbGVzID0gImZyZWVfeCIsIG5yb3cgPTEpKw0KICBzY2FsZV9jb2xvcl9tYW51YWwodmFsdWVzID0gYygic3RlZWxibHVlIiwiZGFya2dyZWVuIiwgImRhcmtyZWQiKSkrDQogIHRoZW1lX21pbmltYWxfaGdyaWQoKSsNCiAgbGFicyh4ID0gIk1lYW4gdmFsdWUgaW4gdGhlIGltYWdlIiwNCiAgICAgICB5ID0gIkRpc2Vhc2Ugc2V2ZXJpdHkgKCUpIikrDQogIHRoZW1lKHBhbmVsLmJvcmRlciA9IGVsZW1lbnRfcmVjdChjb2xvciA9ICJncmF5IikpKw0KICB0aGVtZShsZWdlbmQucG9zaXRpb24gPSAibm9uZSIpDQpyZ2JfZ2dfcGkNCmBgYA0KDQpgYGB7cn0NCmluZGV4X2dnX3BpID0gYWxsX2RhdGFfUEkgJT4lIA0KICBmaWx0ZXIoIWluZGV4ICVpbiUgYygiUmVkIiwgIkJsdWUiLCAiR3JlZW4iKSkgJT4lIA0KICAgIGdncGxvdChhZXMobWVhbiwgc2V2KSkgKyANCiAgIyBnZW9tX3RleHQoKSsNCiAgZ2VvbV9wb2ludChjb2xvciA9ICJncmF5Iiwgc2l6ZSAgPTMpKw0KICBnZW9tX3Ntb290aChjb2xvciA9ICJibGFjayIsIHNlID0gRiwgc2l6ZSA9IDIpKw0KICBmYWNldF93cmFwKH5pbmRleCwgc2NhbGVzID0gImZyZWVfeCIsIG5yb3cgPTIpKw0KICB0aGVtZV9taW5pbWFsX2hncmlkKCkrDQogIGxhYnMoeCA9ICJNZWFuIGluZGV4IHZhbHVlIGluIHRoZSBpbWFnZSIsDQogICAgICAgeSA9ICJEaXNlYXNlIHNldmVyaXR5ICglKSIpKw0KICB0aGVtZShwYW5lbC5ib3JkZXIgPSBlbGVtZW50X3JlY3QoY29sb3IgPSAiZ3JheSIpKQ0KaW5kZXhfZ2dfcGkNCmBgYA0KDQpgYGB7cn0NCnBsb3RfZ3JpZCgNCiAgcGxvdF9ncmlkKE5VTEwscmdiX2dnX3BpLE5VTEwsIHJlbF93aWR0aHMgPWMoMC4xOCwxLDAuMiksIG5yb3cgPSAxKSwNCiAgICAgICAgICBpbmRleF9nZ19waSwNCiAgICAgICAgICBucm93ID0gMiwNCiAgICAgICAgICByZWxfaGVpZ2h0cyA9IGMoMC41LDEpKQ0KZ2dzYXZlKCJmaWdzL2luZGV4X3Nldl9waS5wbmciLCBkcGkgPSA1MDAsIGhlaWdodCA9IDgsIHdpZHRoID0gMTApDQpgYGANCg0KYGBge3J9DQpjb3JfUEkgPSBhbGxfZGF0YV9QSSAlPiUgDQogIGdyb3VwX2J5KGluZGV4KSAlPiUgDQogIGRwbHlyOjpzdW1tYXJpc2UoY29yID0gcm91bmQoICBjb3IudGVzdChtZWFuLHNldiwgbWV0aG9kID0gInNwZWFybWFuIikkZXN0aW1hdGUsMyksDQogICAgICAgICAgICAgICAgICAgUF92YWx1ZSA9IHJvdW5kKGNvci50ZXN0KG1lYW4sc2V2LCBtZXRob2QgPSAic3BlYXJtYW4iKSRwLnZhbHVlLDQpKSAlPiUgDQogIGFycmFuZ2UoLWNvcikNCmNvcl9QSQ0KYGBgDQoNCiMjIyBTcHJlYWQgZGYNCg0KYGBge3J9DQphbGxfZGF0YV9zcHJlYWRfcGxiID0gYWxsX2RhdGFfUEkgJT4lIA0KICBwaXZvdF93aWRlcihpZF9jb2wgPSBjKGZpbGUsc2V2KSwNCiAgICAgICAgICAgICAgbmFtZXNfZnJvbSA9IGluZGV4LCANCiAgICAgICAgICAgICAgdmFsdWVzX2Zyb20gPSAgbWVhbikgICANCg0KaGVhZChhbGxfZGF0YV9zcHJlYWRfcGxiKQ0KYGBgDQoNCiMjIyBHQk0NCg0KYGBge3J9DQp0cmFpbj1zYW1wbGUoeCA9IDE6bGVuZ3RoKGFsbF9kYXRhX3NwcmVhZF9wbGIkc2V2KSwgDQogICAgICAgICAgICAgc2l6ZSA9IHJvdW5kKDAuNzUqbGVuZ3RoKGFsbF9kYXRhX3NwcmVhZF9wbGIkc2V2KSwxKSkNCiMgbGVuZ3RoKHRyYWluKQ0KZ2JtLmZpdCA9IGdibShzZXYgfkJHSStCSStHTEkrSEkrSFVFK05HUkRJK1ZBUkkrZ3JheSsgUmVkK0dyZWVuK0JsdWUgICsgU0kgKyBTQ0ksDQogICAgICAgICAgICAgZGF0YSA9IGFsbF9kYXRhX3NwcmVhZF9wbGJbdHJhaW4sXSwNCiAgICAgICAgICAgICBkaXN0cmlidXRpb24gPSAiZ2F1c3NpYW4iLA0KICAgICAgICAgICAgICBuLnRyZWVzID0gMTAwMCwNCiAgICAgICAgICAgICBpbnRlcmFjdGlvbi5kZXB0aCA9IDMsDQogICAgICAgICAgICAgc2hyaW5rYWdlID0gMC4xLA0KICAgICAgICAgICAgIGN2LmZvbGRzID0gNSwNCiAgICAgICAgICAgICBuLmNvcmVzID0gTlVMTCwgIyB3aWxsIHVzZSBhbGwgY29yZXMgYnkgZGVmYXVsdA0KICAgICAgICAgICAgIHZlcmJvc2UgPSBGQUxTRSkNCnByaW50KGdibS5maXQpDQpzcXJ0KG1pbihnYm0uZml0JGN2LmVycm9yKSkNCmBgYA0KDQpgYGB7cn0NCmdibS5wZXJmKGdibS5maXQsIG1ldGhvZCA9ICJjdiIpDQojIGZpbmQgaW5kZXggZm9yIG4gdHJlZXMgd2l0aCBtaW5pbXVtIENWIGVycm9yDQpgYGANCg0KYGBge3J9DQptaW5fTVNFIDwtIHdoaWNoLm1pbihnYm0uZml0JGN2LmVycm9yKQ0Kc3FydChnYm0uZml0JGN2LmVycm9yW21pbl9NU0VdKQ0KYGBgDQoNCmBgYHtyfQ0KIyBiZXN0Lml0ZXIgPC0gZ2JtLnBlcmYobW9kZWwxLCBtZXRob2QgPSAidGVzdCIpDQojIHByaW50KGJlc3QuaXRlcikNCg0KcHJlZCA9IHByZWRpY3QoZ2JtLmZpdCwgbmV3ZGF0YSA9IGFsbF9kYXRhX3NwcmVhZF9wbGJbLXRyYWluLC0xXSwgbnRyZWVzID0gNTAwMCApDQoNCnNxcnQobWVhbigoKHByZWQpLWFsbF9kYXRhX3NwcmVhZF9wbGIkc2V2Wy10cmFpbl0pXjIpKQ0KQ0NDKChwcmVkKSwgYWxsX2RhdGFfc3ByZWFkX3BsYiRzZXZbLXRyYWluXSkkcmhvLmMkZXN0DQoNCnBsb3QoKHByZWQpLCAocHJlZCktYWxsX2RhdGFfc3ByZWFkX3BsYiRzZXZbLXRyYWluXSkNCmFibGluZShhPTAsYj0wKQ0KYGBgDQoNCiMjIyBUZXN0aW5nIHZhcmlvdXMgaHlwZXJwYXJhbWV0ZXJzDQoNCkNyZWF0ZSBoeXBlcnBhcmFtZXRlciBncmlkDQoNCmBgYHtyfQ0KDQpoeXBlcl9ncmlkIDwtIGV4cGFuZC5ncmlkKA0KICBzaHJpbmthZ2UgPSBjKC4wMDEsIC4wMSwgLjEsIC4zKSwNCiAgaW50ZXJhY3Rpb24uZGVwdGggPSBjKDEsIDMsIDUsIDYpLA0KICBuLm1pbm9ic2lubm9kZSA9IGMoNSwgMTAsIDE1KSwNCiAgYmFnLmZyYWN0aW9uID0gYyguNSwuNjUsIC44LCAxKSwgDQogIG9wdGltYWxfdHJlZXMgPSAwLCAgICAgICAgICAgICAgICMgYSBwbGFjZSB0byBkdW1wIHJlc3VsdHMNCiAgbWluX1JNU0UgPSAwLA0KICBDQ0MgPTAgIyBhIHBsYWNlIHRvIGR1bXAgcmVzdWx0cw0KKQ0KIyB0b3RhbCBudW1iZXIgb2YgY29tYmluYXRpb25zDQpucm93KGh5cGVyX2dyaWQpDQpgYGANCg0KYGBge3IgbWVzc2FnZT1GQUxTRSwgd2FybmluZz1GQUxTRX0NCiMgcmFuZG9taXplIGRhdGENCnNldC5zZWVkKDEyMykNCnRyYWluPXNhbXBsZSh4ID0gMTpsZW5ndGgoYWxsX2RhdGFfc3ByZWFkX3BsYiRzZXYpLCANCiAgICAgICAgICAgICBzaXplID0gcm91bmQoMC44MCpsZW5ndGgoYWxsX2RhdGFfc3ByZWFkX3BsYiRzZXYpLDEpKQ0KDQojIGdyaWQgc2VhcmNoIA0KZm9yKGkgaW4gMTpucm93KGh5cGVyX2dyaWQpKSB7DQoNCiMgcmVwcm9kdWNpYmlsaXR5DQpzZXQuc2VlZCgxMjMpDQoNCg0KICMgdHJhaW4gbW9kZWwNCmdibS50dW5lIDwtIGdibSgNCiAgZm9ybXVsYSA9IHNldiB+QkdJK0JJK0dMSStISStIVUUrTkdSREkrVkFSSStncmF5KyBSZWQrR3JlZW4rQmx1ZSAgKyBTSSArIFNDSSwgDQogIGRhdGEgPSBhbGxfZGF0YV9zcHJlYWRfcGxiW3RyYWluLF0sDQogIGRpc3RyaWJ1dGlvbiA9ICJnYXVzc2lhbiIsDQogIG4udHJlZXMgPSA1MDAwLA0KICBpbnRlcmFjdGlvbi5kZXB0aCA9IGh5cGVyX2dyaWQkaW50ZXJhY3Rpb24uZGVwdGhbaV0sDQogIHNocmlua2FnZSA9IGh5cGVyX2dyaWQkc2hyaW5rYWdlW2ldLA0KICBuLm1pbm9ic2lubm9kZSA9IGh5cGVyX2dyaWQkbi5taW5vYnNpbm5vZGVbaV0sDQogIGJhZy5mcmFjdGlvbiA9IGh5cGVyX2dyaWQkYmFnLmZyYWN0aW9uW2ldLA0KICB0cmFpbi5mcmFjdGlvbiA9IC43NSwNCiAgbi5jb3JlcyA9IE5VTEwsICMgd2lsbCB1c2UgYWxsIGNvcmVzIGJ5IGRlZmF1bHQNCiAgdmVyYm9zZSA9IEZBTFNFKQ0KDQpwcmVkID0gcHJlZGljdChnYm0udHVuZSwgbmV3ZGF0YSA9IGFsbF9kYXRhX3NwcmVhZF9wbGJbLXRyYWluLC0xXSwgbnRyZWVzID0gNTAwMCApDQogIyBhZGQgbWluIHRyYWluaW5nIGVycm9yIGFuZCB0cmVlcyB0byBncmlkDQogIGh5cGVyX2dyaWQkb3B0aW1hbF90cmVlc1tpXSA8LSB3aGljaC5taW4oZ2JtLnR1bmUkdmFsaWQuZXJyb3IpDQogIGh5cGVyX2dyaWQkbWluX1JNU0VbaV0gPC0gc3FydChtaW4oZ2JtLnR1bmUkdmFsaWQuZXJyb3IpKQ0KICBoeXBlcl9ncmlkJENDQ1tpXSA9IENDQygocHJlZCksIGFsbF9kYXRhX3NwcmVhZF9wbGIkc2V2Wy10cmFpbl0pJHJoby5jJGVzdA0KICANCn0NCg0KYmVzdF9wYXIgPSBoeXBlcl9ncmlkICU+JSANCiAgZHBseXI6OmFycmFuZ2UoLUNDQykgJT4lDQogIGhlYWQoMTApDQpiZXN0X3Bhcg0KIyBnYm0udHVuZSRmaXQNCmBgYA0KDQojIyMgQmVzdCBtb2RlbA0KDQpgYGB7cn0NCiMgZm9yIHJlcHJvZHVjaWJpbGl0eQ0Kc2V0LnNlZWQoMTIzKQ0KDQojIHRyYWluIEdCTSBtb2RlbA0KZ2JtLmZpdC5maW5hbF9wbGIgPC0gZ2JtKA0KICBmb3JtdWxhID0gc2V2IH5CR0krQkkrR0xJK0hJK0hVRStOR1JESStWQVJJK2dyYXkrIFJlZCtHcmVlbitCbHVlICArIFNJICsgU0NJLCANCiAgZGF0YSA9IGFsbF9kYXRhX3NwcmVhZF9wbGJbdHJhaW4sXSwNCiAgZGlzdHJpYnV0aW9uID0gImdhdXNzaWFuIiwNCiAgbi50cmVlcyA9IGJlc3RfcGFyJG9wdGltYWxfdHJlZXNbMV0sDQogIGludGVyYWN0aW9uLmRlcHRoID0gYmVzdF9wYXIkaW50ZXJhY3Rpb24uZGVwdGhbMV0sDQogIHNocmlua2FnZSA9IGJlc3RfcGFyJHNocmlua2FnZVsxXSwNCiAgbi5taW5vYnNpbm5vZGUgPSBiZXN0X3BhciRuLm1pbm9ic2lubm9kZVsxXSwNCiAgYmFnLmZyYWN0aW9uID0gYmVzdF9wYXIkYmFnLmZyYWN0aW9uWzFdLCANCiAgdHJhaW4uZnJhY3Rpb24gPTAuNzUsDQogIG4uY29yZXMgPSBOVUxMLCAjIHdpbGwgdXNlIGFsbCBjb3JlcyBieSBkZWZhdWx0DQogIHZlcmJvc2UgPSBGQUxTRQ0KICApDQoNCg0KYGBgDQoNCiMjIyBSZWxhdGl2ZSBpbmZsdWVuY2UNCg0KYGBge3J9DQpwYXIobWFyID0gYyg1LCA4LCAxLCAxKSkNCnN1bW1hcnlfZ2JtX3BsYiA9IHN1bW1hcnkoDQogIGdibS5maXQuZmluYWxfcGxiLCANCiAgY0JhcnMgPSAxMywNCiAgbWV0aG9kID0gcmVsYXRpdmUuaW5mbHVlbmNlLCAjIGFsc28gY2FuIHVzZSBwZXJtdXRhdGlvbi50ZXN0LmdibQ0KICBsYXMgPSAyDQogICkNCg0KcmVsX3BsYiA9IHN1bW1hcnlfZ2JtX3BsYiAgJT4lIA0KICByb3duYW1lc190b19jb2x1bW4oImluZGV4IikgJT4lIA0KICBnZ3Bsb3QoYWVzKHJlbC5pbmYsIHJlb3JkZXIodmFyLCByZWwuaW5mKSkpKw0KICBnZW9tX2NvbChhZXMoZmlsbCA9cmVsLmluZj4xLCBjb2xvciA9cmVsLmluZj4xICksIHdpZHRoID0gMC44NSkrDQogIHRoZW1lX21pbmltYWxfdmdyaWQoKSsNCiAgbGFicyh4ID0gIlJlbGF0aXZlIGluZmx1ZW5jZSAoJSkiLA0KICAgICAgIHkgPSAiTW9kZWwgcHJlZGljdG9ycyIsDQogICAgICAgZmlsbCA9ICJSSSA+IDElIiwNCiAgICAgICBjb2xvciA9ICJSSSA+IDElIikNCnJlbF9wbGINCiMgZ2dzYXZlKCJmaWdzL3Zhcl9pbmZsdWVuY2UucG5nIixkcGkgPSA2MDAsIGhlaWdodCA9IDQsIHdpZHRoID0gNikNCmBgYA0KDQpQYXJ0aWFsIGRlcGVuZGVuY2UgcGxvdHMNCg0KYGBge3J9DQpnYm0uZml0LmZpbmFsX3BsYiAlPiUNCiAgcGRwOjpwYXJ0aWFsKHByZWQudmFyID0gIkJHSSIsIG4udHJlZXMgPSBnYm0uZml0LmZpbmFsX3BsYiRuLnRyZWVzLCBncmlkLnJlc29sdXRpb24gPSAxMDApICU+JQ0KICBnZ3Bsb3QoYWVzKCBCR0ksKHloYXQpKSkrDQogIGdlb21fbGluZSgpDQpgYGANCg0KTElNRQ0KDQpgYGB7cn0NCmxpYnJhcnkobGltZSkNCmBgYA0KDQpgYGB7cn0NCm1vZGVsX3R5cGUuZ2JtIDwtIGZ1bmN0aW9uKHgsIC4uLikgew0KICByZXR1cm4oInJlZ3Jlc3Npb24iKQ0KfQ0KDQpwcmVkaWN0X21vZGVsLmdibSA8LSBmdW5jdGlvbih4LCBuZXdkYXRhLCAuLi4pIHsNCiAgcHJlZCA8LSBwcmVkaWN0KHgsIG5ld2RhdGEsIG4udHJlZXMgPSB4JG4udHJlZXMpDQogIHJldHVybihhcy5kYXRhLmZyYW1lKHByZWQpKQ0KfQ0KYGBgDQoNCmBgYHtyfQ0KIyBnZXQgYSBmZXcgb2JzZXJ2YXRpb25zIHRvIHBlcmZvcm0gbG9jYWwgaW50ZXJwcmV0YXRpb24gb24NCmxvY2FsX29icyA8LSAoYWxsX2RhdGFfc3ByZWFkX3BsYlstdHJhaW4sXSlbMTo0LCBdDQoNCiMgYXBwbHkgTElNRQ0KZXhwbGFpbmVyIDwtIGxpbWUoYWxsX2RhdGFfc3ByZWFkX3BsYlt0cmFpbixdLCBnYm0uZml0LmZpbmFsX3BsYikNCmV4cGxhbmF0aW9uIDwtIGxpbWU6OmV4cGxhaW4obG9jYWxfb2JzLCBleHBsYWluZXIsIG5fZmVhdHVyZXMgPSA3LCBuLnRyZWVzID0xKQ0KcGxvdF9mZWF0dXJlcyhleHBsYW5hdGlvbikNCg0KDQpgYGANCg0KIyMgUHJlZGljdGlvbg0KDQpgYGB7cn0NCiMgcHJlZGljdCB2YWx1ZXMgZm9yIHRlc3QgZGF0YQ0KcHJlZCA8LSBwcmVkaWN0KGdibS5maXQuZmluYWxfcGxiLCBuLnRyZWVzID0gZ2JtLmZpdC5maW5hbF9wbGIkbi50cmVlcywgYWxsX2RhdGFfc3ByZWFkX3BsYlstdHJhaW4sXSkNCg0KIyByZXN1bHRzDQpjYXJldDo6Uk1TRShwcmVkLCBhbGxfZGF0YV9zcHJlYWRfcGxiWy10cmFpbixdJHNldikNCkNDQyhwcmVkLCBhbGxfZGF0YV9zcHJlYWRfcGxiJHNldlstdHJhaW5dKSRyaG8uYyRlc3QNCmNvcihwcmVkLCBhbGxfZGF0YV9zcHJlYWRfcGxiJHNldlstdHJhaW5dKV4yDQpgYGANCg0KYGBge3J9DQphY2N1cmFjeV9waSA9ZGF0YS5mcmFtZShwcmVkaT1wcmVkLCBhY3R1YWwgPSBhbGxfZGF0YV9zcHJlYWRfcGxiJHNldlstdHJhaW5dKSAlPiUgDQogIHN1bW1hcmlzZShSTVNFID0gY2FyZXQ6OlJNU0UocHJlZCwgYWN0dWFsKSwNCiAgICAgICAgICAgIHIgPSBjb3IocHJlZCwgYWN0dWFsKSwNCiAgICAgICAgICAgIHMuc2hpZnQgPSBDQ0MocHJlZCwgYWN0dWFsKSRzLnNoaWZ0LA0KICAgICAgICAgICAgbC5zaGlmdCA9IENDQyhwcmVkLCBhY3R1YWwpJGwuc2hpZnQsDQogICAgICAgICAgICBDLmIgPSBDQ0MocHJlZCwgYWN0dWFsKSRDLmIsDQogICAgICAgICAgICBDQ0MgPSBDQ0MocHJlZCwgYWN0dWFsKSRyaG8uYyRlc3QsDQogICAgICAgICAgICBDSVMgPSBwYXN0ZSgNCiAgcm91bmQoQ0NDKHByZWQsIGFsbF9kYXRhX3NwcmVhZF9wbGIkc2V2Wy10cmFpbl0pJHJoby5jWzJdLDIpLCIsIiwiICIsDQogIHJvdW5kKENDQyhwcmVkLCBhbGxfZGF0YV9zcHJlYWRfcGxiJHNldlstdHJhaW5dKSRyaG8uY1szXSwyKSxzZXAgPSAiIg0KICApKQ0KYWNjdXJhY3lfcGkNCmBgYA0KDQoNCg0KIyMjIyBwbG90DQpgYGB7cn0NCg0KY29uY19waSA9IGRhdGEuZnJhbWUocHJlZGljdCA9IHByZWQsIGFjdHVhbCA9YWxsX2RhdGFfc3ByZWFkX3BsYiRzZXZbLXRyYWluXSkgJT4lIA0KZ2dwbG90KGFlcyhhY3R1YWwscHJlZGljdCkpKw0KICBnZW9tX3BvaW50KHNpemUgPTIsIGNvbG9yID0gImdyYXkiKSsNCiAgZ2VvbV9hYmxpbmUoaW50ZXJjZXB0ID0gMCwgc2xvcGU9IDEsIHNpemUgPSAuODEsIGNvbG9yID0gImJsYWNrIiwgbGluZXR5cGUgPSAiZGFzaGVkIikrDQogIGdlb21fc21vb3RoKG1ldGhvZCA9ICJsbSIsIA0KICAgICAgICAgICAgICBjb2xvciA9ICJyZWQiLA0KICAgICAgICAgICAgICBzaXplID0uODEsIHNlID1GLA0KICAgICAgICAgICAgICBmdWxscmFuZ2U9VCkrDQogIHRoZW1lX21pbmltYWxfZ3JpZCgpKw0KICBsYWJzKHggPSAiUHJlZGljdGVkIFNldmVyaXR5ICglKSIsDQogICAgICAgeSA9ICJBY3R1YWwgU2V2ZXJpdHkgKCUpIikrDQogIGNvb3JkX2VxdWFsKHhsaW0gPSBjKDAsMTAwKSwNCiAgICAgICAgICAgICAgeWxpbSA9IGMoMCwxMDApKSsNCiAgeGxpbSgwLDEwMCkNCg0KDQojIGdnc2F2ZSgiZmlncy9jb25jb3JkYW5jZS5wbmciLCBkcGkgPSA2MDAsIGhlaWdodCA9IDMuNSwgd2lkdGggPSA0KQ0KDQpgYGANCg0KIyBDYWxvbmVjdHJpYSBsZWFmIGJsaWdodA0KDQpgYGB7ciBldmFsPUZBTFNFLCBpbmNsdWRlPVRSVUV9DQpwaWNzPC1saXN0LmZpbGVzKCIuL3BpY3MvMDEtQ2Fsb25lY3RyaWFfbGVhZl9ibGlndGgiKQ0KIyBsZW5ndGgocGljcykNCiNpbmRpY2VzDQppbmRleCA9IGMoIkJJIiwiU0NJIiwiR0xJIiwiSEkiLCJTSSIsIlZBUkkiLCJIVUUiLCJCR0kiLCJOR1JESSIpDQoNCg0KYm94ID0gZGF0YS5mcmFtZSgpDQoNCmZvcihpIGluIDE6bGVuZ3RoKHBpY3MpKXsNCg0KRVguTDE8LXN0YWNrKHBhc3RlKCIuL3BpY3MvMDEtQ2Fsb25lY3RyaWFfbGVhZl9ibGlndGgvIixwaWNzW2ldLHNlcCA9ICIiKSkNCkVYLkwxPC1hZ2dyZWdhdGUoRVguTDEsIGZhY3Q9NykNCkVYLkwuU2hhcGU8LWZpZWxkUG9seWdvbihtb3NhaWM9RVguTDEsIGV4dGVudD1ULCBwbG90ID0gRikNCg0KRVgxLkluZGljZXM8LSBmaWVsZEluZGV4KG1vc2FpYyA9IEVYLkwxLA0KICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaW5kZXgsIA0KICAgICAgICAgICAgICAgICAgICAgICAgIG15SW5kZXggPSBjKCJHcmVlbiIpLCBwbG90ID0gRikNCg0KRVguTDI8LWZpZWxkTWFzayhtb3NhaWM9RVguTDEsICBteUluZGV4ID0gYygiQmx1ZSIpLCBjcm9wVmFsdWU9MTc1LCBjcm9wQWJvdmU9VCwgcGxvdCA9IEYpDQoNCmN1dCA9IG1hc2soRVguTDEsIEVYLkwyJG5ld01vc2FpYykNCkVYLkw0PC1maWVsZEluZGV4KG1vc2FpYz1jdXQsDQogICAgICAgICAgICAgICAgICBpbmRleCA9aW5kZXgsDQogICAgICAgICAgICAgICAgICBwbG90ID1GKQ0KDQoNCmRmID0gYXMoRVguTDQsICJTcGF0aWFsUGl4ZWxzRGF0YUZyYW1lIikNCmRmZiA9IGFzLmRhdGEuZnJhbWUoZGYpICU+JSANCiAgbXV0YXRlKGdyYXkgPSAwLjI5OSpSZWQrMC41ODcqR3JlZW4rMC4xMTQqQmx1ZSkgJT4lIA0KICBnYXRoZXIoYygxOigzK2xlbmd0aChpbmRleCkpLDE1KSwga2V5ID0gImluZGV4IiwgdmFsdWUgPSAidmFsdWUiICkgJT4lDQogIGZpbHRlcighaXMubmEodmFsdWUpLA0KICAgICAgICAgIWlzLmluZmluaXRlKHZhbHVlKSkgJT4lIA0KICBncm91cF9ieShpbmRleCkgJT4lIA0KICBkcGx5cjo6c3VtbWFyaXNlKG1lYW4gPSBtZWFuKHZhbHVlLCBuYS5ybSA9IFQpLA0KICAgICAgICAgICAgc3RkID0gc2QodmFsdWUpLA0KICAgICAgICAgICAgUTI1ID0gcXVhbnRpbGUodmFsdWUsMC4yNSksDQogICAgICAgICAgICBRNTAgPSBxdWFudGlsZSh2YWx1ZSwwLjUwKSwNCiAgICAgICAgICAgIFE3NSA9IHF1YW50aWxlKHZhbHVlLDAuNzUpKSAlPiUgDQogIG11dGF0ZShsZWFmID0gcGljc1tpXSkNCg0KDQpib3ggPSBib3ggJT4lIA0KICBiaW5kX3Jvd3MoZGZmKX0NCmxlbmd0aCh1bmlxdWUoYm94JGxlYWYpKQ0Kd3JpdGUudGFibGUoYm94LCJkYXRhL2luZGV4ZXNfY2Fsb25lYy50eHQiKQ0KYGBgDQoNCmBgYHtyfQ0KYm94ID0gcmVhZC50YWJsZSgiZGF0YS9pbmRleGVzX2NhbG9uZWMudHh0IikNCmBgYA0KDQoNCiMjIyBMb2FkIHNldg0KYGBge3J9DQpkYXRhX2NhbG9fbG9hZCA9IGdzaGVldDJ0YmwoImh0dHBzOi8vZG9jcy5nb29nbGUuY29tL3NwcmVhZHNoZWV0cy9kLzFENUNuNkNORDhPalF3ZHZfQVZ0X3N4SjBIMjFEaklRbmZtQjdIS3dxWVhJL2VkaXQ/dXNwPXNoYXJpbmciKSAlPiUgDQogIG11dGF0ZShmaWxlID0gYXMuY2hhcmFjdGVyKGZpbGUpKSAlPiUgDQogIGRwbHlyOjpzZWxlY3QoZmlsZSxhcmVhX3RvdGFsLGFyZWFfZG9lbnRlX3JveGEsYXJlYV9kb2VudGUsc2V2X3JveGEsc2V2KQ0KaGVhZChkYXRhX2NhbG9fbG9hZCkNCmBgYA0KDQpgYGB7cn0NCmRhdGFfY2FsbyA9IGJveCAlPiUgDQogIHNlcGFyYXRlKGxlYWYsIGludG89YygiZmlsZSIsImZvcm1hdCIpLCBzZXAgPSIuanBnIikgJT4lIA0KICBkcGx5cjo6c2VsZWN0KC1mb3JtYXQpICU+JSANCiAgZnVsbF9qb2luKGRhdGFfY2Fsb19sb2FkLCBieT0iZmlsZSIpICU+JSANCiAgbXV0YXRlKHNldj1zZXZfcm94YSkNCiMgZGF0YV9jYWxvDQoNCmxlbmd0aCh1bmlxdWUoZGF0YV9jYWxvJHNldikpDQpgYGANCmBgYHtyfQ0Kc3VtbWFyeShkYXRhX2NhbG8kc2V2KQ0KYGBgDQoNCg0KIyMjIEltYWdlcw0KDQoNCmBgYHtyfQ0KaGlzdF9zZXZfY2FsbyA9ICBkYXRhX2NhbG8gJT4lIA0KICBwaXZvdF93aWRlcihpZF9jb2wgPSBjKGZpbGUsc2V2X3JveGEpLA0KICAgICAgICAgICAgICBuYW1lc19mcm9tID0gaW5kZXgsIA0KICAgICAgICAgICAgICB2YWx1ZXNfZnJvbSA9ICBtZWFuKSAlPiUNCiAgZ2dwbG90KGFlcyhzZXZfcm94YSkpKw0KICBnZW9tX2hpc3RvZ3JhbShjb2xvciA9ICJ3aGl0ZSIsIGZpbGwgPSAiYmxhY2siLCBiaW5zID0gMjApKw0KICB0aGVtZV9taW5pbWFsX2hncmlkKGZvbnRfc2l6ZSA9IDEwKSsNCiAgbGFicyh4ID0gIlNldmVyaXR5ICglKSIsDQogICAgICAgeSA9ICJGcmVxdWVuY3kiKSsNCiAgc2NhbGVfeF9jb250aW51b3VzKGxpbWl0cyA9IGMoLTUsMTA1KSwgYnJlYWtzID0gc2VxKDAsMTAwLDI1KSkrDQogICMgdGhlbWVfdm9pZCgpKw0KICAjIGNvb3JkX2ZpeGVkKCkrDQogIHRoZW1lKHBhbmVsLmJhY2tncm91bmQgPSBlbGVtZW50X3JlY3QoY29sb3IgPSAiYmxhY2siKSwNCiAgICAgICAgYXhpcy50aXRsZS55ID0gZWxlbWVudF90ZXh0KHNpemU9OCkpDQoNCmBgYA0KDQpgYGB7cn0NCkVYLkwxPC1zdGFjayhwYXN0ZSgiLi9waWNzLzAxLUNhbG9uZWN0cmlhX2xlYWZfYmxpZ3RoLyIsIjU3LmpwZyIsc2VwID0gIiIpKQ0KRVguTDE8LWFnZ3JlZ2F0ZShFWC5MMSwgZmFjdD03KQ0KRVguTC5TaGFwZTwtZmllbGRQb2x5Z29uKG1vc2FpYz1FWC5MMSwgZXh0ZW50PVQsIHBsb3QgPSBGKQ0KDQojIEVYMS5JbmRpY2VzPC0gZmllbGRJbmRleChtb3NhaWMgPSBFWC5MMSwNCiMgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaW5kZXgsIA0KIyAgICAgICAgICAgICAgICAgICAgICAgICAgbXlJbmRleCA9IGMoIkdyZWVuIiksIHBsb3QgPSBGKQ0KDQpFWC5MMjwtZmllbGRNYXNrKG1vc2FpYz1FWC5MMSwgIG15SW5kZXggPSBjKCJCbHVlIiksIGNyb3BWYWx1ZT0xNzUsIGNyb3BBYm92ZT1ULCBwbG90ID0gRikNCg0KY3V0ID0gbWFzayhFWC5MMSwgRVguTDIkbmV3TW9zYWljKQ0KRVguTDQ8LWZpZWxkSW5kZXgobW9zYWljPWN1dCwNCiAgICAgICAgICAgICAgICAgIGluZGV4ID1pbmRleCwNCiAgICAgICAgICAgICAgICAgIHBsb3QgPUYpDQojIHBsb3QoRVguTDQkSFVFKQ0KYGBgDQoNCmBgYHtyfQ0KcmdiX2ZpZ19jYWxvID0gUlN0b29sYm94OjpnZ1JHQihFWC5MMiRuZXdNb3NhaWMsDQogICAgICAgICAgICAgICAgIHIgPSAxLA0KICAgICAgICAgICAgICAgICBnID0gMiwNCiAgICAgICAgICAgICAgICAgYiA9IDMpKw0KICB0aGVtZV9tYXAoKSsNCiAgY29vcmRfZml4ZWQoKSsNCiAgdGhlbWUocGFuZWwuYmFja2dyb3VuZCA9IGVsZW1lbnRfcmVjdChjb2xvciA9ICJ3aGl0ZSIpKQ0KDQoNCmdsaV9maWdfY2FsbyA9IGFzLmRhdGEuZnJhbWUoRVguTDQkSFVFLCB4eT1UUlVFLCBuYS5ybSA9VCkgJT4lIA0KICBnZ3Bsb3QoYWVzKHgsIHksIGZpbGwgPSBIVUUpKSsNCiAgZ2VvbV90aWxlKCkrDQogIHNjYWxlX2ZpbGxfdmlyaWRpc19jKG9wdGlvbiA9ICJCIixkaXJlY3Rpb24gPSAtMSkrDQogIHRoZW1lX21hcCgpKw0KICBjb29yZF9maXhlZCgpKw0KICB0aGVtZShwYW5lbC5iYWNrZ3JvdW5kID0gZWxlbWVudF9yZWN0KGNvbG9yID0gIndoaXRlIiksDQogICAgICAgIGxlZ2VuZC50aXRsZSA9IGVsZW1lbnRfdGV4dChzaXplID0gOCksDQogICAgICAgIGxlZ2VuZC50ZXh0ID0gZWxlbWVudF90ZXh0KHNpemUgPSA4KSkNCg0KcmdiX2ZpZ19jYWxvKyBnbGlfZmlnX2NhbG8NCmBgYA0KDQpgYGB7ciBmaWcuaGVpZ2h0PTksIGZpZy53aWR0aD03fQ0KcmdiX2ZpZ19zYnIgKyBnbGlfZmlnX3NiciArIGhpc3Rfc2V2X3NiciArDQogIHJnYl9maWdfeHkgKyBnbGlfZmlnX3h5ICtoaXN0X3Nldl94eSsNCiAgcmdiX2ZpZ19jYWxvICsgZ2xpX2ZpZ19jYWxvICsgaGlzdF9zZXZfY2FsbysNCiAgcmdiX2ZpZ193bGIgKyBnbGlfZmlnX3dsYiArIGhpc3Rfc2V2X1dMQisNCiAgcmdiX2ZpZ19waSArIGdsaV9maWdfcGkgKyBoaXN0X3Nldl9waSsNCiAgIHBsb3RfbGF5b3V0KHdpZHRocyA9IGMoMSwgMSwgMSksDQogICAgICAgICAgICAgICBoZWlnaHRzID0gYygxLDEsMSwxLDEpKSsNCiAgcGxvdF9hbm5vdGF0aW9uKHRhZ19sZXZlbHMgPSAnQScpJg0KICB0aGVtZShsZWdlbmQua2V5LnNpemUgPSB1bml0KDMsICdtbScpLA0KICAgICAgICBsZWdlbmQudGV4dCA9IGVsZW1lbnRfdGV4dChzaXplID02KSkNCg0KZ2dzYXZlKCJmaWdzL2xlYWZfZ2xpLnBuZyIsZHBpID0gNjAwLCBoZWlnaHQgPSA5LCB3aWR0aCA9NykNCmBgYA0KDQoNCg0KIyMjIFJlbGF0aW9uc2hpcCBzZXYgaW5kaWNlcw0KDQoNCmBgYHtyfQ0KIHJnYl9nZ19jYWxvID0gIGRhdGFfY2FsbyAlPiUgDQogIGZpbHRlcihpbmRleCAlaW4lIGMoIlJlZCIsICJCbHVlIiwgIkdyZWVuIikpICU+JQ0KICAgIGdncGxvdChhZXMobWVhbiwgc2V2X3JveGEsIGNvbG9yID0gaW5kZXgpKSArIA0KICAjIGdlb21fdGV4dCgpKw0KICBnZW9tX3BvaW50KGNvbG9yID0gImdyYXkiLCBzaXplICA9MykrDQogIGdlb21fc21vb3RoKHNlID0gRiwgc2l6ZSA9IDIpKw0KICBmYWNldF93cmFwKH5pbmRleCwgc2NhbGVzID0gImZyZWVfeCIsIG5yb3cgPTEpKw0KICBzY2FsZV9jb2xvcl9tYW51YWwodmFsdWVzID0gYygic3RlZWxibHVlIiwiZGFya2dyZWVuIiwgImRhcmtyZWQiKSkrDQogIHRoZW1lX21pbmltYWxfaGdyaWQoKSsNCiAgbGFicyh4ID0gIk1lYW4gdmFsdWUgaW4gdGhlIGltYWdlIiwNCiAgICAgICB5ID0gIkRpc2Vhc2Ugc2V2ZXJpdHkgKCUpIikrDQogIHRoZW1lKHBhbmVsLmJvcmRlciA9IGVsZW1lbnRfcmVjdChjb2xvciA9ICJncmF5IikpKw0KICB0aGVtZShsZWdlbmQucG9zaXRpb24gPSAibm9uZSIpDQpyZ2JfZ2dfY2Fsbw0KYGBgDQoNCg0KYGBge3J9DQppbmRleF9nZ19jYWxvID0gZGF0YV9jYWxvICU+JSANCiAgZmlsdGVyKCFpbmRleCAlaW4lIGMoIlJlZCIsICJCbHVlIiwgIkdyZWVuIikpICU+JSANCiAgICBnZ3Bsb3QoYWVzKG1lYW4sIHNldl9yb3hhLCBsYWJlbCA9IGZpbGUpKSArIA0KICAjIGdlb21fdGV4dCgpKw0KICBnZW9tX3BvaW50KGNvbG9yID0gImdyYXkiLCBzaXplICA9MykrDQogIGdlb21fc21vb3RoKGNvbG9yID0gImJsYWNrIiwgc2UgPSBGLCBzaXplID0gMikrDQogIGZhY2V0X3dyYXAofmluZGV4LCBzY2FsZXMgPSAiZnJlZV94IiwgbnJvdyA9MikrDQogIHRoZW1lX21pbmltYWxfaGdyaWQoKSsNCiAgbGFicyh4ID0gIk1lYW4gaW5kZXggdmFsdWUgaW4gdGhlIGltYWdlIiwNCiAgICAgICB5ID0gIkRpc2Vhc2Ugc2V2ZXJpdHkgKCUpIikrDQogIHRoZW1lKHBhbmVsLmJvcmRlciA9IGVsZW1lbnRfcmVjdChjb2xvciA9ICJncmF5IikpDQppbmRleF9nZ19jYWxvDQpgYGANCg0KYGBge3J9DQpwbG90X2dyaWQoDQogIHBsb3RfZ3JpZChOVUxMLHJnYl9nZ19jYWxvLE5VTEwsIHJlbF93aWR0aHMgPWMoMC4xOCwxLDAuMiksIG5yb3cgPSAxKSwNCiAgICAgICAgICBpbmRleF9nZ19jYWxvLA0KICAgICAgICAgIG5yb3cgPSAyLA0KICAgICAgICAgIHJlbF9oZWlnaHRzID0gYygwLjUsMSkpDQpnZ3NhdmUoImZpZ3MvaW5kZXhfc2V2X2NhbG8ucG5nIiwgZHBpID0gNTAwLCBoZWlnaHQgPSA4LCB3aWR0aCA9IDEwKQ0KYGBgDQoNCg0KYGBge3J9DQpjb3JfY2FsbyA9IGRhdGFfY2FsbyAlPiUgDQogIGdyb3VwX2J5KGluZGV4KSAlPiUgDQogIGRwbHlyOjpzdW1tYXJpc2UoY29yID0gcm91bmQoICBjb3IudGVzdChtZWFuLHNldl9yb3hhLCBtZXRob2QgPSAic3BlYXJtYW4iKSRlc3RpbWF0ZSwzKSwNCiAgICAgICAgICAgICAgICAgICBQX3ZhbHVlID0gcm91bmQoY29yLnRlc3QobWVhbixzZXZfcm94YSwgbWV0aG9kID0gInNwZWFybWFuIikkcC52YWx1ZSw0KSkgJT4lIA0KICBhcnJhbmdlKC1jb3IpDQpjb3JfY2Fsbw0KYGBgDQoNCiMjIyBTcHJlYWQgZGYNCg0KYGBge3J9DQphbGxfZGF0YV9zcHJlYWRfY2FsbyA9IGRhdGFfY2FsbyAlPiUgDQogIHBpdm90X3dpZGVyKGlkX2NvbCA9IGMoZmlsZSxzZXZfcm94YSksDQogICAgICAgICAgICAgIG5hbWVzX2Zyb20gPSBpbmRleCwgDQogICAgICAgICAgICAgIHZhbHVlc19mcm9tID0gIG1lYW4pICU+JSANCiAgbXV0YXRlKHNldiA9IHNldl9yb3hhKSAlPiUgDQogIGRwbHlyOjpzZWxlY3QoLXNldl9yb3hhKQ0KDQpoZWFkKGFsbF9kYXRhX3NwcmVhZF9jYWxvKQ0KYGBgDQoNCiMjIyBHQk0NCg0KYGBge3J9DQp0cmFpbj1zYW1wbGUoeCA9IDE6bGVuZ3RoKGFsbF9kYXRhX3NwcmVhZF9jYWxvJHNldiksIA0KICAgICAgICAgICAgIHNpemUgPSByb3VuZCgwLjc1Kmxlbmd0aChhbGxfZGF0YV9zcHJlYWRfY2FsbyRzZXYpLDEpKQ0KIyBsZW5ndGgodHJhaW4pDQpnYm0uZml0ID0gZ2JtKHNldiB+QkdJK0JJK0dMSStISStIVUUrTkdSREkrVkFSSStncmF5KyBSZWQrR3JlZW4rQmx1ZSAgKyBTSSArIFNDSSwNCiAgICAgICAgICAgICBkYXRhID0gYWxsX2RhdGFfc3ByZWFkX2NhbG9bdHJhaW4sXSwNCiAgICAgICAgICAgICBkaXN0cmlidXRpb24gPSAiZ2F1c3NpYW4iLA0KICAgICAgICAgICAgICBuLnRyZWVzID0gMTAwMCwNCiAgICAgICAgICAgICBpbnRlcmFjdGlvbi5kZXB0aCA9IDMsDQogICAgICAgICAgICAgc2hyaW5rYWdlID0gMC4xLA0KICAgICAgICAgICAgIGN2LmZvbGRzID0gNSwNCiAgICAgICAgICAgICBuLmNvcmVzID0gTlVMTCwgIyB3aWxsIHVzZSBhbGwgY29yZXMgYnkgZGVmYXVsdA0KICAgICAgICAgICAgIHZlcmJvc2UgPSBGQUxTRSkNCnByaW50KGdibS5maXQpDQpzcXJ0KG1pbihnYm0uZml0JGN2LmVycm9yKSkNCmBgYA0KDQpgYGB7cn0NCmdibS5wZXJmKGdibS5maXQsIG1ldGhvZCA9ICJjdiIpDQojIGZpbmQgaW5kZXggZm9yIG4gdHJlZXMgd2l0aCBtaW5pbXVtIENWIGVycm9yDQpgYGANCg0KYGBge3J9DQptaW5fTVNFIDwtIHdoaWNoLm1pbihnYm0uZml0JGN2LmVycm9yKQ0Kc3FydChnYm0uZml0JGN2LmVycm9yW21pbl9NU0VdKQ0KYGBgDQoNCmBgYHtyfQ0KIyBiZXN0Lml0ZXIgPC0gZ2JtLnBlcmYobW9kZWwxLCBtZXRob2QgPSAidGVzdCIpDQojIHByaW50KGJlc3QuaXRlcikNCg0KcHJlZCA9IHByZWRpY3QoZ2JtLmZpdCwgbmV3ZGF0YSA9IGFsbF9kYXRhX3NwcmVhZF9jYWxvWy10cmFpbiwtMV0sIG50cmVlcyA9IDUwMDAgKQ0KDQpzcXJ0KG1lYW4oKChwcmVkKS1hbGxfZGF0YV9zcHJlYWRfY2FsbyRzZXZbLXRyYWluXSleMikpDQpDQ0MoKHByZWQpLCBhbGxfZGF0YV9zcHJlYWRfY2FsbyRzZXZbLXRyYWluXSkkcmhvLmMkZXN0DQoNCnBsb3QoKHByZWQpLCAocHJlZCktYWxsX2RhdGFfc3ByZWFkX2NhbG8kc2V2Wy10cmFpbl0pDQphYmxpbmUoYT0wLGI9MCkNCmBgYA0KDQojIyMgVGVzdGluZyB2YXJpb3VzIGh5cGVycGFyYW1ldGVycw0KDQpDcmVhdGUgaHlwZXJwYXJhbWV0ZXIgZ3JpZA0KDQpgYGB7cn0NCg0KaHlwZXJfZ3JpZCA8LSBleHBhbmQuZ3JpZCgNCiAgc2hyaW5rYWdlID0gYyguMDAxLCAuMDEsIC4xLCAuMyksDQogIGludGVyYWN0aW9uLmRlcHRoID0gYygxLCAzLCA1LCA2KSwNCiAgbi5taW5vYnNpbm5vZGUgPSBjKDUsIDEwLCAxNSksDQogIGJhZy5mcmFjdGlvbiA9IGMoLjUsLjY1LCAuOCwgMSksIA0KICBvcHRpbWFsX3RyZWVzID0gMCwgICAgICAgICAgICAgICAjIGEgcGxhY2UgdG8gZHVtcCByZXN1bHRzDQogIG1pbl9STVNFID0gMCwNCiAgQ0NDID0wICMgYSBwbGFjZSB0byBkdW1wIHJlc3VsdHMNCikNCiMgdG90YWwgbnVtYmVyIG9mIGNvbWJpbmF0aW9ucw0KbnJvdyhoeXBlcl9ncmlkKQ0KYGBgDQoNCmBgYHtyIG1lc3NhZ2U9RkFMU0UsIHdhcm5pbmc9RkFMU0V9DQojIHJhbmRvbWl6ZSBkYXRhDQpzZXQuc2VlZCgxMjM0KQ0KdHJhaW49c2FtcGxlKHggPSAxOmxlbmd0aChhbGxfZGF0YV9zcHJlYWRfY2FsbyRzZXYpLCANCiAgICAgICAgICAgICBzaXplID0gcm91bmQoMC44MCpsZW5ndGgoYWxsX2RhdGFfc3ByZWFkX2NhbG8kc2V2KSwxKSkNCg0KIyBncmlkIHNlYXJjaCANCmZvcihpIGluIDE6bnJvdyhoeXBlcl9ncmlkKSkgew0KDQojIHJlcHJvZHVjaWJpbGl0eQ0Kc2V0LnNlZWQoMTIzKQ0KDQoNCiAjIHRyYWluIG1vZGVsDQpnYm0udHVuZSA8LSBnYm0oDQogIGZvcm11bGEgPSBzZXYgfkJHSStCSStHTEkrSEkrSFVFK05HUkRJK1ZBUkkrZ3JheSsgUmVkK0dyZWVuK0JsdWUgICsgU0kgKyBTQ0ksIA0KICBkYXRhID0gYWxsX2RhdGFfc3ByZWFkX2NhbG9bdHJhaW4sXSwNCiAgZGlzdHJpYnV0aW9uID0gImdhdXNzaWFuIiwNCiAgbi50cmVlcyA9IDUwMDAsDQogIGludGVyYWN0aW9uLmRlcHRoID0gaHlwZXJfZ3JpZCRpbnRlcmFjdGlvbi5kZXB0aFtpXSwNCiAgc2hyaW5rYWdlID0gaHlwZXJfZ3JpZCRzaHJpbmthZ2VbaV0sDQogIG4ubWlub2JzaW5ub2RlID0gaHlwZXJfZ3JpZCRuLm1pbm9ic2lubm9kZVtpXSwNCiAgYmFnLmZyYWN0aW9uID0gaHlwZXJfZ3JpZCRiYWcuZnJhY3Rpb25baV0sDQogIHRyYWluLmZyYWN0aW9uID0gLjc1LA0KICBuLmNvcmVzID0gTlVMTCwgIyB3aWxsIHVzZSBhbGwgY29yZXMgYnkgZGVmYXVsdA0KICB2ZXJib3NlID0gRkFMU0UpDQoNCnByZWQgPSBwcmVkaWN0KGdibS50dW5lLCBuZXdkYXRhID0gYWxsX2RhdGFfc3ByZWFkX2NhbG9bLXRyYWluLC0xXSwgbnRyZWVzID0gNTAwMCApDQogIyBhZGQgbWluIHRyYWluaW5nIGVycm9yIGFuZCB0cmVlcyB0byBncmlkDQogIGh5cGVyX2dyaWQkb3B0aW1hbF90cmVlc1tpXSA8LSB3aGljaC5taW4oZ2JtLnR1bmUkdmFsaWQuZXJyb3IpDQogIGh5cGVyX2dyaWQkbWluX1JNU0VbaV0gPC0gc3FydChtaW4oZ2JtLnR1bmUkdmFsaWQuZXJyb3IpKQ0KICBoeXBlcl9ncmlkJENDQ1tpXSA9IENDQygocHJlZCksIGFsbF9kYXRhX3NwcmVhZF9jYWxvJHNldlstdHJhaW5dKSRyaG8uYyRlc3QNCiAgDQp9DQoNCmJlc3RfcGFyID0gaHlwZXJfZ3JpZCAlPiUgDQogIGRwbHlyOjphcnJhbmdlKC1DQ0MpICU+JQ0KICBoZWFkKDEwKQ0KYmVzdF9wYXINCiMgZ2JtLnR1bmUkZml0DQpgYGANCg0KIyMjIEJlc3QgbW9kZWwNCg0KYGBge3J9DQojIGZvciByZXByb2R1Y2liaWxpdHkNCnNldC5zZWVkKDEyMykNCg0KIyB0cmFpbiBHQk0gbW9kZWwNCmdibS5maXQuZmluYWxfY2FsbyA8LSBnYm0oDQogIGZvcm11bGEgPSBzZXYgfkJHSStCSStHTEkrSEkrSFVFK05HUkRJK1ZBUkkrZ3JheSsgUmVkK0dyZWVuK0JsdWUgICsgU0kgKyBTQ0ksIA0KICBkYXRhID0gYWxsX2RhdGFfc3ByZWFkX2NhbG9bdHJhaW4sXSwNCiAgZGlzdHJpYnV0aW9uID0gImdhdXNzaWFuIiwNCiAgbi50cmVlcyA9IGJlc3RfcGFyJG9wdGltYWxfdHJlZXNbMV0sDQogIGludGVyYWN0aW9uLmRlcHRoID0gYmVzdF9wYXIkaW50ZXJhY3Rpb24uZGVwdGhbMV0sDQogIHNocmlua2FnZSA9IGJlc3RfcGFyJHNocmlua2FnZVsxXSwNCiAgbi5taW5vYnNpbm5vZGUgPSBiZXN0X3BhciRuLm1pbm9ic2lubm9kZVsxXSwNCiAgYmFnLmZyYWN0aW9uID0gYmVzdF9wYXIkYmFnLmZyYWN0aW9uWzFdLCANCiAgdHJhaW4uZnJhY3Rpb24gPTAuNzUsDQogIG4uY29yZXMgPSBOVUxMLCAjIHdpbGwgdXNlIGFsbCBjb3JlcyBieSBkZWZhdWx0DQogIHZlcmJvc2UgPSBGQUxTRQ0KICApDQoNCg0KYGBgDQoNCiMjIyBSZWxhdGl2ZSBpbmZsdWVuY2UNCg0KYGBge3J9DQpwYXIobWFyID0gYyg1LCA4LCAxLCAxKSkNCnN1bW1hcnlfZ2JtX2NhbG8gPSBzdW1tYXJ5KA0KICBnYm0uZml0LmZpbmFsX2NhbG8sIA0KICBjQmFycyA9IDEzLA0KICBtZXRob2QgPSByZWxhdGl2ZS5pbmZsdWVuY2UsICMgYWxzbyBjYW4gdXNlIHBlcm11dGF0aW9uLnRlc3QuZ2JtDQogIGxhcyA9IDINCiAgKQ0KDQpyZWxfY2FsbyA9IHN1bW1hcnlfZ2JtX2NhbG8gJT4lIA0KICByb3duYW1lc190b19jb2x1bW4oImluZGV4IikgJT4lIA0KICBnZ3Bsb3QoYWVzKHJlbC5pbmYsIHJlb3JkZXIodmFyLCByZWwuaW5mKSkpKw0KICBnZW9tX2NvbChhZXMoZmlsbCA9cmVsLmluZj4xLCBjb2xvciA9cmVsLmluZj4xICksIHdpZHRoID0gMC44NSkrDQogIHRoZW1lX21pbmltYWxfdmdyaWQoKSsNCiAgbGFicyh4ID0gIlJlbGF0aXZlIGluZmx1ZW5jZSAoJSkiLA0KICAgICAgIHkgPSAiTW9kZWwgcHJlZGljdG9ycyIsDQogICAgICAgZmlsbCA9ICJSSSA+IDElIiwNCiAgICAgICBjb2xvciA9ICJSSSA+IDElIikNCnJlbF9jYWxvDQojIGdnc2F2ZSgiZmlncy92YXJfaW5mbHVlbmNlLnBuZyIsZHBpID0gNjAwLCBoZWlnaHQgPSA0LCB3aWR0aCA9IDYpDQpgYGANCg0KUGFydGlhbCBkZXBlbmRlbmNlIHBsb3RzDQoNCmBgYHtyfQ0KZ2JtLmZpdC5maW5hbF9jYWxvICU+JQ0KICBwZHA6OnBhcnRpYWwocHJlZC52YXIgPSAiSFVFIiwgbi50cmVlcyA9IGdibS5maXQuZmluYWxfY2FsbyRuLnRyZWVzLCBncmlkLnJlc29sdXRpb24gPSAxMDApICU+JQ0KICBnZ3Bsb3QoYWVzKCBIVUUsKHloYXQpKSkrDQogIGdlb21fbGluZSgpDQpgYGANCg0KTElNRQ0KDQpgYGB7cn0NCmxpYnJhcnkobGltZSkNCmBgYA0KDQpgYGB7cn0NCm1vZGVsX3R5cGUuZ2JtIDwtIGZ1bmN0aW9uKHgsIC4uLikgew0KICByZXR1cm4oInJlZ3Jlc3Npb24iKQ0KfQ0KDQpwcmVkaWN0X21vZGVsLmdibSA8LSBmdW5jdGlvbih4LCBuZXdkYXRhLCAuLi4pIHsNCiAgcHJlZCA8LSBwcmVkaWN0KHgsIG5ld2RhdGEsIG4udHJlZXMgPSB4JG4udHJlZXMpDQogIHJldHVybihhcy5kYXRhLmZyYW1lKHByZWQpKQ0KfQ0KYGBgDQoNCmBgYHtyfQ0KIyBnZXQgYSBmZXcgb2JzZXJ2YXRpb25zIHRvIHBlcmZvcm0gbG9jYWwgaW50ZXJwcmV0YXRpb24gb24NCmxvY2FsX29icyA8LSAoYWxsX2RhdGFfc3ByZWFkX2NhbG9bLXRyYWluLF0pWzE6NCwgXQ0KDQojIGFwcGx5IExJTUUNCmV4cGxhaW5lciA8LSBsaW1lKGFsbF9kYXRhX3NwcmVhZF9jYWxvW3RyYWluLF0sIGdibS5maXQuZmluYWxfY2FsbykNCmV4cGxhbmF0aW9uIDwtIGxpbWU6OmV4cGxhaW4obG9jYWxfb2JzLCBleHBsYWluZXIsIG5fZmVhdHVyZXMgPSA3LCBuLnRyZWVzID0xKQ0KcGxvdF9mZWF0dXJlcyhleHBsYW5hdGlvbikNCg0KDQpgYGANCg0KIyMgUHJlZGljdGlvbg0KDQpgYGB7cn0NCiMgcHJlZGljdCB2YWx1ZXMgZm9yIHRlc3QgZGF0YQ0KcHJlZCA8LSBwcmVkaWN0KGdibS5maXQuZmluYWxfY2Fsbywgbi50cmVlcyA9IGdibS5maXQuZmluYWxfY2FsbyRuLnRyZWVzLCBhbGxfZGF0YV9zcHJlYWRfY2Fsb1stdHJhaW4sXSkNCg0KIyByZXN1bHRzDQpjYXJldDo6Uk1TRShwcmVkLCBhbGxfZGF0YV9zcHJlYWRfY2Fsb1stdHJhaW4sXSRzZXYpDQpDQ0MocHJlZCwgYWxsX2RhdGFfc3ByZWFkX2NhbG8kc2V2Wy10cmFpbl0pJHJoby5jJGVzdA0KY29yKHByZWQsIGFsbF9kYXRhX3NwcmVhZF9jYWxvJHNldlstdHJhaW5dKV4yDQpgYGANCg0KYGBge3J9DQphY2N1cmFjeV9jYWxvID0gZGF0YS5mcmFtZShwcmVkaT1wcmVkLCBhY3R1YWwgPSBhbGxfZGF0YV9zcHJlYWRfY2FsbyRzZXZbLXRyYWluXSkgJT4lIA0KICBzdW1tYXJpc2UoUk1TRSA9IGNhcmV0OjpSTVNFKHByZWQsIGFjdHVhbCksDQogICAgICAgICAgICByID0gY29yKHByZWQsIGFjdHVhbCksDQogICAgICAgICAgICBzLnNoaWZ0ID0gQ0NDKHByZWQsIGFjdHVhbCkkcy5zaGlmdCwNCiAgICAgICAgICAgIGwuc2hpZnQgPSBDQ0MocHJlZCwgYWN0dWFsKSRsLnNoaWZ0LA0KICAgICAgICAgICAgQy5iID0gQ0NDKHByZWQsIGFjdHVhbCkkQy5iLA0KICAgICAgICAgICAgQ0NDID0gQ0NDKHByZWQsIGFjdHVhbCkkcmhvLmMkZXN0LA0KICAgICAgICAgICAgQ0lTID0gcGFzdGUoDQogIHJvdW5kKENDQyhwcmVkLCBhbGxfZGF0YV9zcHJlYWRfY2FsbyRzZXZbLXRyYWluXSkkcmhvLmNbMl0sMiksIiwiLCIgIiwNCiAgcm91bmQoQ0NDKHByZWQsIGFsbF9kYXRhX3NwcmVhZF9jYWxvJHNldlstdHJhaW5dKSRyaG8uY1szXSwyKSxzZXAgPSAiIg0KICApKQ0KYWNjdXJhY3lfY2Fsbw0KYGBgDQoNCg0KDQoNCiMjIyMgcGxvdA0KYGBge3J9DQoNCmNvbmNfY2FsbyA9IGRhdGEuZnJhbWUocHJlZGljdCA9IHByZWQsIGFjdHVhbCA9YWxsX2RhdGFfc3ByZWFkX2NhbG8kc2V2Wy10cmFpbl0pICU+JSANCmdncGxvdChhZXMoYWN0dWFsLHByZWRpY3QpKSsNCiAgZ2VvbV9wb2ludChzaXplID0yLCBjb2xvciA9ICJncmF5IikrDQogIGdlb21fYWJsaW5lKGludGVyY2VwdCA9IDAsIHNsb3BlPSAxLCBzaXplID0gLjgxLCBjb2xvciA9ICJibGFjayIsIGxpbmV0eXBlID0gImRhc2hlZCIpKw0KICBnZW9tX3Ntb290aChtZXRob2QgPSAibG0iLCANCiAgICAgICAgICAgICAgY29sb3IgPSAicmVkIiwNCiAgICAgICAgICAgICAgc2l6ZSA9LjgxLCBzZSA9RiwNCiAgICAgICAgICAgICAgZnVsbHJhbmdlPVQpKw0KICB0aGVtZV9taW5pbWFsX2dyaWQoKSsNCiAgbGFicyh4ID0gIlByZWRpY3RlZCBTZXZlcml0eSAoJSkiLA0KICAgICAgIHkgPSAiQWN0dWFsIFNldmVyaXR5ICglKSIpKw0KICBjb29yZF9lcXVhbCh4bGltID0gYygwLDEwMCksDQogICAgICAgICAgICAgIHlsaW0gPSBjKDAsMTAwKSkrDQogIHhsaW0oMCwxMDApDQoNCg0KIyBnZ3NhdmUoImZpZ3MvY29uY29yZGFuY2UucG5nIiwgZHBpID0gNjAwLCBoZWlnaHQgPSAzLjUsIHdpZHRoID0gNCkNCg0KYGBgDQoNCg0KDQojIENvcnJlbGF0aW9uDQoNCmBgYHtyfQ0KaW5kX29yZGVyID0gYygiUmVkIiwiR3JlZW4iLCJCbHVlIiwiQkkiLCJTQ0kiLCJHTEkiLCJISSIsIk5HUkRJIiwiU0kiLCJWQVJJIiwiSFVFIiwiQkdJIiwiZ3JheSIpDQpiaW5kX3Jvd3MoDQpjb3Jfc2JyICU+JSBtdXRhdGUoZGlzZWFzZT0iU0JSIiksDQpjb3JfY2FsbyAlPiUgbXV0YXRlKGRpc2Vhc2U9IkNMQiIpLA0KY29yX3h5ICU+JSBtdXRhdGUoZGlzZWFzZT0iTnRYZiIpLA0KY29yX3dsYiAlPiUgbXV0YXRlKGRpc2Vhc2U9IldMQiIpLA0KY29yX1BJICU+JSBtdXRhdGUoZGlzZWFzZT0iUExCIikpICU+JSANCiAgbXV0YXRlKHNpZyA9IGNhc2Vfd2hlbihQX3ZhbHVlIDwwLjA1IH4gIiAiLA0KICAgICAgICAgICAgICAgICAgICAgICAgIFBfdmFsdWUgPjAuMDUgfiAiUD4wLjA1IikpICU+JSANCiAgbXV0YXRlKGRpc2Vhc2UgPSBmYWN0b3IoZGlzZWFzZSwgbGV2ZWxzID0gYygiUExCIiwgIldMQiIsIk50WGYiLCJDTEIiLCAiU0JSIikpLA0KICAgICAgICAgaW5kZXggPSBmYWN0b3IoaW5kZXgsIGxldmVscyA9IGluZF9vcmRlcikpICU+JSANCiAgZ2dwbG90KGFlcyhpbmRleCxkaXNlYXNlLCBmaWxsID0gY29yLCBsYWJlbCA9IHJvdW5kKGNvciwzKSkpKw0KICBnZW9tX3RpbGUoKSsNCiAgZ2VvbV90ZXh0KHNpemUgPTMuNSkrDQogIGdlb21fcG9pbnQoYWVzKGluZGV4LGRpc2Vhc2UsIGNvbG9yID0gc2lnKSwgc2hhcGUgPSAiWCIsIHNpemUgPTgsIGFscGhhID0gMC42KSsNCiAgIyBzY2FsZV9maWxsX2dyYWRpZW50Mihsb3cgPSAiZGFya3JlZCIsIG1pZCA9IE5BLCBoaWdoID0gImRhcmtncmVlbiIpKw0KICBzY2FsZV9maWxsX2Rpc3RpbGxlcihwYWxldHRlID0gIlJkQnUiLCBkaXJlY3Rpb24gPSAxKSsNCiAgc2NhbGVfY29sb3JfbWFudWFsKHZhbHVlcyA9IGMoTkEsImJsYWNrIikpKw0KICB0aGVtZV9oYWxmX29wZW4oKSsNCiAgbGFicyh4ID0gIiIsDQogICAgICAgeSA9ICIiLCANCiAgICAgICBmaWxsID0gIiAgciIsDQogICAgICAgY29sb3IgPSIiKQ0KZ2dzYXZlKCJmaWdzL2NvcnIucG5nIixkcGkgPSA2MDAsIGhlaWdodCA9IDMuNSwgd2lkdGggPTEwKQ0KYGBgDQoNCg0KDQoNCg0KIyBSZWxhdGl2ZSBpbmZsdWVuY2UgY29tYm8NCmBgYHtyfQ0KIyBzdW1tYXJ5X2dibV9zYnINCiMgc3VtbWFyeV9nYm1fY2Fsbw0KIyBzdW1tYXJ5X2dibV94eQ0KIyBzdW1tYXJ5X2dibV93bGINCiMgc3VtbWFyeV9nYm1fcGxiDQpgYGANCg0KDQpgYGB7cn0NCnJlbF9zYnIgKyBsYWJzKHRpdGxlID0gcGFzdGUoIlNveWJlYW4gcnVzdCIpKSsNCiAgcmVsX2NhbG8gK2xhYnModGl0bGUgPSBwYXN0ZSgiQ2Fsb25lY3RyaWEgbGVhZiBibGlnaHQiKSkrDQogIHJlbF93bGIgK2xhYnModGl0bGUgPSBwYXN0ZSgiV2hlYXQgbGVhZiBibGFzdCIpKSsNCiAgcmVsX3BsYiArbGFicyh0aXRsZSA9IHBhc3RlKCJQb3RhdG8gbGF0ZSBibGlnaHQiKSkrDQogIHJlbF94eSArbGFicyh0aXRsZSA9IGV4cHJlc3Npb24oYm9sZGl0YWxpYygiTi4gdGFiYWN1bS1YLiBmYXN0aWRpb3NhIikpKStndWlkZV9hcmVhKCkrDQogIHBsb3RfbGF5b3V0KG5jb2wgPTMsIGd1aWRlcyA9ICJjb2xsZWN0IikrDQogIHBsb3RfYW5ub3RhdGlvbih0YWdfbGV2ZWxzID0gJ0EnKSYNCiAgdGhlbWVfbWluaW1hbF9ncmlkKGZvbnRfc2l6ZSA9IDkpJg0KICB0aGVtZShwbG90LnRpdGxlID0gZWxlbWVudF90ZXh0KHNpemUgPTgpKSYNCiAgeGxpbSgwLDEwMCkNCmdnc2F2ZSgiZmlncy9yZWxhdGl2ZV9pbmZsdWVuY2VfY29tYm8ucG5nIiwgZHBpID0gMzAwLCBoZWlnaHQgPSA1LCB3aWR0aCA9IDYpDQpgYGANCmBgYHtyfQ0KYmlwbG90X3JpID0gZnVuY3Rpb24oZGF0YV9jb3IsIGRhdGFfcmksIHRpdGxlLCBmYWNlPSJwbGFpbiIpew0KDQpkYXRhX3JpICU+JSANCiAgcmVuYW1lKGluZGV4ID0gdmFyKSAlPiUgDQogIGZ1bGxfam9pbihkYXRhX2NvcikgJT4lIA0KICBnZ3Bsb3QoYWVzKHJlbC5pbmYsYWJzKGNvciksbGFiZWwgPSBpbmRleCwgY29sb3IgPSBpbmRleCkpKw0KICAjIGdlb21fc21vb3RoKGNvbG9yID0gImdyYXk5MCIsc2UgPSBGKSsNCiAgZ2VvbV9wb2ludChzaXplID0gMykrDQogIGdncmVwZWw6Omdlb21fdGV4dF9yZXBlbChzaXplPTMpKw0KICBjb29yZF9jYXJ0ZXNpYW4oeGxpbSA9IGMoMCwxMDApLA0KICAgICAgICAgICAgICAgICAgeWxpbSA9IGMoMCwxKSkrDQogIHRoZW1lX21pbmltYWwoKSsNCiAgdGhlbWUobGVnZW5kLnBvc2l0aW9uID0gIm5vbmUiLA0KICAgICAgICBwYW5lbC5ncmlkID0gZWxlbWVudF9ibGFuaygpLA0KICAgICAgICBwbG90LnRpdGxlID0gZWxlbWVudF90ZXh0KHNpemUgPSAxMCwgZmFjZSA9IGZhY2UpLA0KICAgICAgICBheGlzLnRpY2tzID0gZWxlbWVudF9saW5lKGNvbG9yID0gImdyYXkiKSwNCiAgICAgICAgYXhpcy5saW5lID0gZWxlbWVudF9saW5lKGNvbG9yID0gImdyYXkiKSkrDQogIGxhYnMoeSA9ICJBYnNvbHV0ZSBTcGVhcm1hbidzIHIiLA0KICAgICAgIHggPSAiUmVsYXRpdmUgSW5mbHVlbmNlICglKSIsDQogICAgICAgdGl0bGUgID0gcGFzdGUodGl0bGUpKQ0KfQ0KYGBgDQoNCg0KYGBge3J9DQpiaXBsb3RfcmkoZGF0YV9jb3IgPSBjb3Jfc2JyLCBkYXRhX3JpID0gc3VtbWFyeV9nYm1fc2JyLCB0aXRsZSA9ICJTb3liZWFuIHJ1c3QiKSsNCmJpcGxvdF9yaShkYXRhX2NvciA9IGNvcl9jYWxvLCBkYXRhX3JpID0gc3VtbWFyeV9nYm1fY2FsbywgdGl0bGUgPSAiQ2Fsb25lY3RyaWEgbGVhZiBibGlnaHQiKSsNCiAgYmlwbG90X3JpKGRhdGFfY29yID0gY29yX3h5LCBkYXRhX3JpID0gc3VtbWFyeV9nYm1feHksIHRpdGxlID0gIk4uIHRhYmFjdW0tWC4gZmFzdGlkaW9zYSIsZmFjZSA9ICJpdGFsaWMiKSsNCiAgYmlwbG90X3JpKGRhdGFfY29yID0gY29yX3dsYiwgZGF0YV9yaSA9IHN1bW1hcnlfZ2JtX3dsYiwgdGl0bGUgPSAiV2hlYXQgbGVhZiBibGFzdCIpKw0KICBiaXBsb3RfcmkoZGF0YV9jb3IgPSBjb3JfUEksIGRhdGFfcmkgPSBzdW1tYXJ5X2dibV9wbGIsIHRpdGxlID0gIlBvdGF0byBsYXRlIGJsaWdodCIpKw0KICBwbG90X2xheW91dChucm93ID0gMywNCiAgICAgICAgICAgICAgbmNvbCA9IDIpKw0KICBwbG90X2Fubm90YXRpb24odGFnX2xldmVscyA9ICJBIikrDQpnZ3NhdmUoImZpZ3MvcmlfY29yLnBuZyIsZHBpID0gMzAwLCBoZWlnaHQgPSA4LCB3aWR0aCA9NikNCg0KYGBgDQoNCg0KDQoNCiMjIyBBZ3JlZW1lbnQNCg0KYGBge3J9DQogY29uY19zYnIrbGFicyh0aXRsZSA9IHBhc3RlKCJTb3liZWFuIHJ1c3QiKSwNCiAgICAgICAgICAgICAgIHN1YnRpdGxlID0gcGFzdGUoIlJNU0UgPSAiLHJvdW5kKGFjY3VyYWN5X3NiciRSTVNFLDIpLCIsICIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJDQ0MgPSAiLHJvdW5kKGFjY3VyYWN5X3NiciRDQ0MsMykpKSsNCiAgY29uY19jYWxvK2xhYnModGl0bGUgPSBwYXN0ZSgiQ2Fsb25lY3RyaWEgbGVhZiBibGlnaHQiKSwNCiAgICAgICAgICAgICAgIHN1YnRpdGxlID0gcGFzdGUoIlJNU0UgPSAiLHJvdW5kKGFjY3VyYWN5X2NhbG8kUk1TRSwyKSwiLCAiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiQ0NDID0gIixyb3VuZChhY2N1cmFjeV9jYWxvJENDQywzKSkpKw0KICBjb25jX3dsYitsYWJzKHRpdGxlID0gcGFzdGUoIldoZWF0IGxlYWYgYmxhc3QiKSwNCiAgICAgICAgICAgICAgIHN1YnRpdGxlID0gcGFzdGUoIlJNU0UgPSAiLHJvdW5kKGFjY3VyYWN5X3dsYiRSTVNFLDIpLCIsICIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJDQ0MgPSAiLHJvdW5kKGFjY3VyYWN5X3dsYiRDQ0MsMykpKSsNCiAgY29uY19waStsYWJzKHRpdGxlID0gcGFzdGUoIlBvdGF0byBsYXRlIGJsaWdodCIpLA0KICAgICAgICAgICAgICAgc3VidGl0bGUgPSBwYXN0ZSgiUk1TRSA9ICIscm91bmQoYWNjdXJhY3lfcGkkUk1TRSwyKSwiLCAiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiQ0NDID0gIixyb3VuZChhY2N1cmFjeV9waSRDQ0MsMykpKSsNCiAgY29uY194eStsYWJzKHRpdGxlID0gZXhwcmVzc2lvbihib2xkaXRhbGljKCJOLiB0YWJhY3VtLVguIGZhc3RpZGlvc2EiKSksDQogICAgICAgICAgICAgICBzdWJ0aXRsZSA9IHBhc3RlKCJSTVNFID0gIixyb3VuZChhY2N1cmFjeV94eSRSTVNFLDIpLCIsICIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJDQ0MgPSAiLHJvdW5kKGFjY3VyYWN5X3h5JENDQywzKSkpKw0KICANCiAgDQogICBwbG90X2xheW91dChuY29sID0gMywNCiAgICAgICAgICAgICAgIHdpZHRocyA9IGMoMSwgMSwxKSwNCiAgICAgICAgICAgICAgIGhlaWdodHMgPSBjKDEsMSkpKw0KDQogIHBsb3RfYW5ub3RhdGlvbih0YWdfbGV2ZWxzID0gJ0EnKSYNCiAgICB0aGVtZV9taW5pbWFsX2dyaWQoZm9udF9zaXplID0gMTApJg0KICB0aGVtZShwbG90LnRpdGxlID0gZWxlbWVudF90ZXh0KHNpemUgPTEwLCBmYWNlID0iYm9sZCIpLA0KICAgICAgcGxvdC5zdWJ0aXRsZSA9IGVsZW1lbnRfdGV4dChzaXplID0xMCwgZmFjZSA9ICJwbGFpbiIpKQ0KDQpnZ3NhdmUoImZpZ3MvY29uY29yZGFuY2UucG5nIiwgZHBpID0gNjAwLCBoZWlnaHQgPSA2LCB3aWR0aCA9IDgpDQpgYGANCg0KIyBSR0IgYmFuZHMgYnkgbGVhZg0KDQoNCg0KIyMjIyBGdW5jdGlvbg0KDQpgYGB7cn0NCmRlbnNpdHlfcmdiMiA9IGZ1bmN0aW9uKA0KZmlsZV9sb3cgPSAiLi9waWNzLzAxLXNveWJlYW4tcnVzdC1iZy1ibHVlL0ZlcnJ1Z2VtIDUyX01lZGlhbi5qcGciLA0KZmlsZV9oaWdoID0gIi4vcGljcy8wMS1zb3liZWFuLXJ1c3QtYmctYmx1ZS9GZXJydWdlbSA0OV9NZWRpYW4uanBnIiwNCmxpbWlhciA9IDEwMCwNCmluZGV4X2N1dCA9ICJCbHVlIiwNCmNyb3BBYm92ZT1ULA0KdGl0bGUgPSAiU295YmVhbiBSdXN0IixmYWNlID0gInBsYWluIil7DQoNCiMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tDQpTQlJfbG93X0VYLkwxPC1zdGFjayhwYXN0ZShmaWxlX2xvdyApKQ0KU0JSX2xvd19FWC5MMTwtYWdncmVnYXRlKFNCUl9sb3dfRVguTDEsIGZhY3Q9NSkNCg0KU0JSX2xvd19FWC5MMjwtZmllbGRNYXNrKG1vc2FpYz1TQlJfbG93X0VYLkwxLCBteUluZGV4ID0gYyhpbmRleF9jdXQpLCBjcm9wVmFsdWU9bGltaWFyLCBjcm9wQWJvdmU9Y3JvcEFib3ZlLCBwbG90ID0gRikNCg0KY3V0ID0gbWFzayhTQlJfbG93X0VYLkwxLCBTQlJfbG93X0VYLkwyJG5ld01vc2FpYykNClNCUl9sb3dfRVguTDQ8LWZpZWxkSW5kZXgobW9zYWljPWN1dCwNCiAgICAgICAgICAgICAgICAgICMgaW5kZXggPWluZGV4LA0KICAgICAgICAgICAgICAgICAgcGxvdCA9RikNCg0KU0JSX2xvdyA9IFJTdG9vbGJveDo6Z2dSR0IoU0JSX2xvd19FWC5MMiRuZXdNb3NhaWMsciA9IDEsZyA9IDIsYiA9IDMpKw0KICB0aGVtZV9tYXAoKStjb29yZF9maXhlZCgpKw0KICB0aGVtZShwYW5lbC5iYWNrZ3JvdW5kID0gZWxlbWVudF9yZWN0KGNvbG9yID0gTkEsIGZpbGwgPSBOQSksDQogICAgICAgIHBsb3QudGl0bGUgPSBlbGVtZW50X3RleHQoc2l6ZT04LCBmYWNlID0gInBsYWluIikpKw0KICBsYWJzKHRpdGxlID0gIkxvdyIpDQoNClNCUl9sb3dfY29tYiA9IGRhdGEuZnJhbWUoUiA9IGFzLmRhdGEuZnJhbWUoU0JSX2xvd19FWC5MNCRSZWQpLA0KICAgICAgICAgICBHID0gYXMuZGF0YS5mcmFtZShTQlJfbG93X0VYLkw0JEJsdWUpLA0KICAgICAgICAgICBCID0gYXMuZGF0YS5mcmFtZShTQlJfbG93X0VYLkw0JEdyZWVuKSkgJT4lDQogIG5hLm9taXQoKSAlPiUgDQogIHBpdm90X2xvbmdlcigxOjMsbmFtZXNfdG8gPSAiYmFuZCIsIHZhbHVlc190byA9ICJ2YWx1ZSIpICU+JQ0KICBtdXRhdGUoc2V2PSJMb3ciKQ0KIy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0NCg0KU0JSX2hpZ2hfRVguTDE8LXN0YWNrKHBhc3RlKGZpbGVfaGlnaCkpDQpTQlJfaGlnaF9FWC5MMTwtYWdncmVnYXRlKFNCUl9oaWdoX0VYLkwxLCBmYWN0PTUpDQoNClNCUl9oaWdoX0VYLkwyPC1maWVsZE1hc2sobW9zYWljPVNCUl9oaWdoX0VYLkwxLCAgbXlJbmRleCA9IGMoaW5kZXhfY3V0KSwgY3JvcFZhbHVlPWxpbWlhciwgY3JvcEFib3ZlPWNyb3BBYm92ZSwgcGxvdCA9IEYpDQoNCmN1dCA9IG1hc2soU0JSX2hpZ2hfRVguTDEsIFNCUl9oaWdoX0VYLkwyJG5ld01vc2FpYykNClNCUl9oaWdoX0VYLkw0PC1maWVsZEluZGV4KG1vc2FpYz1jdXQsDQogICAgICAgICAgICAgICAgICAjIGluZGV4ID1pbmRleCwNCiAgICAgICAgICAgICAgICAgIHBsb3QgPUYpDQoNClNCUl9oaWdoID0gUlN0b29sYm94OjpnZ1JHQihTQlJfaGlnaF9FWC5MMiRuZXdNb3NhaWMsciA9IDEsZyA9IDIsYiA9IDMpKw0KICB0aGVtZV9tYXAoKStjb29yZF9maXhlZCgpKw0KICB0aGVtZShwYW5lbC5iYWNrZ3JvdW5kID0gZWxlbWVudF9yZWN0KGNvbG9yID0gTkEsIGZpbGwgPSBOQSksDQogICAgICAgIHBsb3QudGl0bGUgPSBlbGVtZW50X3RleHQoc2l6ZT04LCBmYWNlID0gInBsYWluIikpKw0KICBsYWJzKHRpdGxlID0gIkhpZ2giKQ0KDQpTQlJfaGlnaF9jb21iID0gZGF0YS5mcmFtZShSID0gYXMuZGF0YS5mcmFtZShTQlJfaGlnaF9FWC5MNCRSZWQpLA0KICAgICAgICAgICBHID0gYXMuZGF0YS5mcmFtZShTQlJfaGlnaF9FWC5MNCRCbHVlKSwNCiAgICAgICAgICAgQiA9IGFzLmRhdGEuZnJhbWUoU0JSX2hpZ2hfRVguTDQkR3JlZW4pKSAlPiUNCiAgbmEub21pdCgpICU+JSANCiAgcGl2b3RfbG9uZ2VyKDE6MyxuYW1lc190byA9ICJiYW5kIiwgdmFsdWVzX3RvID0gInZhbHVlIikgJT4lDQogIG11dGF0ZShzZXY9IkhpZ2giKQ0KDQojLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQ0KYWxsX2NvbWIgPSBiaW5kX3Jvd3MoU0JSX2xvd19jb21iLFNCUl9oaWdoX2NvbWIpICU+JSANCiAgbXV0YXRlKHNldiA9ZmFjdG9yKHNldiwgbGV2ZWxzID1jKCJMb3ciLCJIaWdoIikpKQ0KIy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0NCg0KYWxsX2NvbWIgJT4lIA0KICBnZ3Bsb3QoYWVzKHZhbHVlLHNldikpKw0KICBzdGF0X3NsYWIoYWVzKGZpbGwgPSBiYW5kKSwgYWxwaGEgPSAwLjcpKw0KICAgc3RhdF9wb2ludGludGVydmFsKGFlcyhjb2xvciA9IGJhbmQpLA0KICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gcG9zaXRpb25fZG9kZ2Uod2lkdGggPSAuNSwgcHJlc2VydmUgPSAic2luZ2xlIiksDQogICAgICAgICAgICAgICAgICAgICAjIGNvbG9yID0gImdyYXk0MCIsDQogICAgICAgICAgICAgICAgICAgICAud2lkdGggPSBjKDAsMC45NSkpKw0KICANCiAgc2NhbGVfZmlsbF9tYW51YWwodmFsdWVzID0gYygiYmx1ZSIsICJncmVlbiIsInJlZCIgKSkrDQogIHNjYWxlX2NvbG9yX21hbnVhbCh2YWx1ZXMgPSBjKCJibHVlIiwgImdyZWVuIiwicmVkIiApKSsNCiAgdGhlbWVfbWluaW1hbCgpKw0KICB4bGltKDAsMjU1KSsNCiAgdGhlbWUocGFuZWwuZ3JpZCA9IGVsZW1lbnRfYmxhbmsoKSwNCiAgICAgICAgcGxvdC50aXRsZSA9IGVsZW1lbnRfdGV4dChzaXplID0gMTAsIGZhY2UgPSBmYWNlKSwNCiAgICAgICAgYXhpcy50aWNrcyA9IGVsZW1lbnRfbGluZShjb2xvciA9ICJncmF5IiksDQogICAgICAgIGF4aXMubGluZSA9IGVsZW1lbnRfbGluZShjb2xvciA9ICJncmF5IikpKw0KICBsYWJzKHggPSAiUGl4ZWwgaW50ZW5zaXR5IiwNCiAgICAgICB5ID0gIlNldmVyaXR5IiwNCiAgICAgICBmaWxsID0iIiwNCiAgICAgICB0aXRsZSA9IHBhc3RlKHRpdGxlKSkrICANCiAgZ3VpZGVzKGNvbG9yID1GKSMrDQogICNTQlJfbG93K1NCUl9oaWdoKw0KICAjcGxvdF9sYXlvdXQod2lkdGhzID0gYygxLCAuMiwuMikpDQp9DQpgYGANCg0KDQojIyMgcGxvdHMgDQpgYGB7ciBtZXNzYWdlPUZBTFNFLCBpbmNsdWRlPUZBTFNFfQ0KU0JSX2Rpc3QgPSBkZW5zaXR5X3JnYjIoKQ0KY2Fsb19kaXN0ID1kZW5zaXR5X3JnYjIoZmlsZV9sb3cgPSIuL3BpY3MvMDEtQ2Fsb25lY3RyaWFfbGVhZl9ibGlndGgvMTA4LmpwZyIsDQogICAgICAgICAgICAgICAgICAgICAgICBmaWxlX2hpZ2ggPSAiLi9waWNzLzAxLUNhbG9uZWN0cmlhX2xlYWZfYmxpZ3RoLzE1My5qcGciLA0KICAgICAgICAgICAgICAgICAgICAgICAgbGltaWFyID0gMTc1LGluZGV4X2N1dCA9ICJCbHVlIixjcm9wQWJvdmU9VCwNCiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlID0gIkNhbG9uZWN0cmlhIGxlYWYgYmxpZ2h0IikNCg0KeHlfZGlzdCA9IGRlbnNpdHlfcmdiMihmaWxlX2xvdyA9Ii4vcGljcy8wMS1YeWxlbGxhLXRvYmFjY28tYmctd2hpdGUvNjguanBnIiwNCiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVfaGlnaCA9ICIuL3BpY3MvMDEtWHlsZWxsYS10b2JhY2NvLWJnLXdoaXRlLzgyLmpwZyIsDQogICAgICAgICAgICAgICAgICAgICAgICBsaW1pYXIgPSAyMDAsaW5kZXhfY3V0ID0gIkJsdWUiLCBjcm9wQWJvdmU9VCwNCiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlID0gIk4uIHRhYmFjdW0tWC4gZmFzdGlkaW9zYSIsIGZhY2UgPSAiaXRhbGljIikNCg0KDQp3bGJfZGlzdCA9IGRlbnNpdHlfcmdiMihmaWxlX2xvdyA9Ii4vcGljcy8wMS1XaGVhdF9sZWFmX2JsYXN0L0dfMTA4X1IzLmpwZyIsDQogICAgICAgICAgICAgICAgICAgICAgICBmaWxlX2hpZ2ggPSAiLi9waWNzLzAxLVdoZWF0X2xlYWZfYmxhc3QvVF8yMzlfUjEuanBnIiwNCiAgICAgICAgICAgICAgICAgICAgICAgIGxpbWlhciA9IDE4MCxpbmRleF9jdXQgPSAiQmx1ZSIsY3JvcEFib3ZlPVQsDQogICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSA9ICJXaGVhdCBsZWFmIGJsYXN0IikNCg0KcGxiX2Rpc3QgPSBkZW5zaXR5X3JnYjIoZmlsZV9sb3cgPSIuL3BpY3MvMDEtcG90YXRvX2xhdGVfYmxpZ2gvUEkyNF82Qi5wbmciLA0KICAgICAgICAgICAgICAgICAgICAgICAgZmlsZV9oaWdoID0gIi4vcGljcy8wMS1wb3RhdG9fbGF0ZV9ibGlnaC9QSTA3XzJBLnBuZyIsDQogICAgICAgICAgICAgICAgICAgICAgICBsaW1pYXIgPSAxLGluZGV4X2N1dCA9ICJSZWQiLGNyb3BBYm92ZT1GLA0KICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGUgPSAiUG90YXRvIGxhdGUgYmxpZ2h0IikNCmBgYA0KDQoNCg0KIyMjIyBjb21ibw0KDQoNCmBgYHtyIGZpZy5oZWlnaHQ9NywgZmlnLndpZHRoPTZ9DQooU0JSX2Rpc3QrY2Fsb19kaXN0K3h5X2Rpc3Qrd2xiX2Rpc3QrcGxiX2Rpc3QrZ3VpZGVfYXJlYSgpKSsNCiAgcGxvdF9sYXlvdXQobnJvdyA9IDMsDQogICAgICAgICAgICAgIG5jb2wgPSAyLA0KICAgICAgICAgICAgICB0YWdfbGV2ZWwgPSAia2VlcCIsDQogICAgICAgICAgICAgICMgd2lkdGhzID0gYygxLDEsMSwxLDEpLA0KICAgICAgICAgICAgICBndWlkZXMgPSAnY29sbGVjdCcpKw0KICBwbG90X2Fubm90YXRpb24odGFnX2xldmVscyA9ICJBIikrDQogICMgcGxvdF9hbm5vdGF0aW9uKHRhZ19sZXZlbHMgPSBsaXN0KHRhZ3MyKSkmDQogIHRoZW1lKGxlZ2VuZC5rZXkuc2l6ZSA9IHVuaXQoNSwgJ21tJyksDQogICAgICAgIGxlZ2VuZC5wb3NpdGlvbiA9ICJub25lIiwNCiAgICAgICAgbGVnZW5kLnRleHQgPSBlbGVtZW50X3RleHQoc2l6ZSA9MTApKQ0KZ2dzYXZlKCJmaWdzL1JHQl9kZW5zMi5wbmciLGRwaSA9IDYwMCwgaGVpZ2h0ID0gNywgd2lkdGggPTYpDQpgYGANCg0KYGBge3J9DQpkZW5zaXR5X3JnYl9pbWFnZXMgPSBmdW5jdGlvbigNCmZpbGVfbG93ID0gIi4vcGljcy8wMS1zb3liZWFuLXJ1c3QtYmctYmx1ZS9GZXJydWdlbSA1Ml9NZWRpYW4uanBnIiwNCmZpbGVfaGlnaCA9ICIuL3BpY3MvMDEtc295YmVhbi1ydXN0LWJnLWJsdWUvRmVycnVnZW0gNDlfTWVkaWFuLmpwZyIsDQpsaW1pYXIgPSAxMDAsDQppbmRleF9jdXQgPSAiQmx1ZSIsDQpjcm9wQWJvdmU9VCwNCnRpdGxlID0gIlNveWJlYW4gUnVzdCIsZmFjZSA9ICJwbGFpbiIpew0KDQojLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQ0KU0JSX2xvd19FWC5MMTwtc3RhY2socGFzdGUoZmlsZV9sb3cgKSkNClNCUl9sb3dfRVguTDE8LWFnZ3JlZ2F0ZShTQlJfbG93X0VYLkwxLCBmYWN0PTUpDQoNClNCUl9sb3dfRVguTDI8LWZpZWxkTWFzayhtb3NhaWM9U0JSX2xvd19FWC5MMSwgbXlJbmRleCA9IGMoaW5kZXhfY3V0KSwgY3JvcFZhbHVlPWxpbWlhciwgY3JvcEFib3ZlPWNyb3BBYm92ZSwgcGxvdCA9IEYpDQoNCmN1dCA9IG1hc2soU0JSX2xvd19FWC5MMSwgU0JSX2xvd19FWC5MMiRuZXdNb3NhaWMpDQpTQlJfbG93X0VYLkw0PC1maWVsZEluZGV4KG1vc2FpYz1jdXQsDQogICAgICAgICAgICAgICAgICAjIGluZGV4ID1pbmRleCwNCiAgICAgICAgICAgICAgICAgIHBsb3QgPUYpDQoNClNCUl9sb3cgPSBSU3Rvb2xib3g6OmdnUkdCKFNCUl9sb3dfRVguTDIkbmV3TW9zYWljLHIgPSAxLGcgPSAyLGIgPSAzKSsNCiAgdGhlbWVfbWFwKCkrY29vcmRfZml4ZWQoKSsNCiAgdGhlbWUocGFuZWwuYmFja2dyb3VuZCA9IGVsZW1lbnRfcmVjdChjb2xvciA9IE5BLCBmaWxsID0gTkEpLA0KICAgICAgICBwbG90LnRpdGxlID0gZWxlbWVudF90ZXh0KHNpemU9OCwgZmFjZSA9ICJwbGFpbiIpKSMrDQogICMgbGFicyh0aXRsZSA9ICJMb3ciKQ0KDQpTQlJfbG93X2NvbWIgPSBkYXRhLmZyYW1lKFIgPSBhcy5kYXRhLmZyYW1lKFNCUl9sb3dfRVguTDQkUmVkKSwNCiAgICAgICAgICAgRyA9IGFzLmRhdGEuZnJhbWUoU0JSX2xvd19FWC5MNCRCbHVlKSwNCiAgICAgICAgICAgQiA9IGFzLmRhdGEuZnJhbWUoU0JSX2xvd19FWC5MNCRHcmVlbikpICU+JQ0KICBuYS5vbWl0KCkgJT4lIA0KICBwaXZvdF9sb25nZXIoMTozLG5hbWVzX3RvID0gImJhbmQiLCB2YWx1ZXNfdG8gPSAidmFsdWUiKSAlPiUNCiAgbXV0YXRlKHNldj0iTG93IikNCiMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tDQoNClNCUl9oaWdoX0VYLkwxPC1zdGFjayhwYXN0ZShmaWxlX2hpZ2gpKQ0KU0JSX2hpZ2hfRVguTDE8LWFnZ3JlZ2F0ZShTQlJfaGlnaF9FWC5MMSwgZmFjdD01KQ0KDQpTQlJfaGlnaF9FWC5MMjwtZmllbGRNYXNrKG1vc2FpYz1TQlJfaGlnaF9FWC5MMSwgIG15SW5kZXggPSBjKGluZGV4X2N1dCksIGNyb3BWYWx1ZT1saW1pYXIsIGNyb3BBYm92ZT1jcm9wQWJvdmUsIHBsb3QgPSBGKQ0KDQpjdXQgPSBtYXNrKFNCUl9oaWdoX0VYLkwxLCBTQlJfaGlnaF9FWC5MMiRuZXdNb3NhaWMpDQpTQlJfaGlnaF9FWC5MNDwtZmllbGRJbmRleChtb3NhaWM9Y3V0LA0KICAgICAgICAgICAgICAgICAgIyBpbmRleCA9aW5kZXgsDQogICAgICAgICAgICAgICAgICBwbG90ID1GKQ0KDQpTQlJfaGlnaCA9IFJTdG9vbGJveDo6Z2dSR0IoU0JSX2hpZ2hfRVguTDIkbmV3TW9zYWljLHIgPSAxLGcgPSAyLGIgPSAzKSsNCiAgdGhlbWVfbWFwKCkrY29vcmRfZml4ZWQoKSsNCiAgdGhlbWUocGFuZWwuYmFja2dyb3VuZCA9IGVsZW1lbnRfcmVjdChjb2xvciA9IE5BLCBmaWxsID0gTkEpLA0KICAgICAgICBwbG90LnRpdGxlID0gZWxlbWVudF90ZXh0KHNpemU9OCwgZmFjZSA9ICJwbGFpbiIpKSMrDQogICMgbGFicyh0aXRsZSA9ICJIaWdoIikNCg0KU0JSX2hpZ2hfY29tYiA9IGRhdGEuZnJhbWUoUiA9IGFzLmRhdGEuZnJhbWUoU0JSX2hpZ2hfRVguTDQkUmVkKSwNCiAgICAgICAgICAgRyA9IGFzLmRhdGEuZnJhbWUoU0JSX2hpZ2hfRVguTDQkQmx1ZSksDQogICAgICAgICAgIEIgPSBhcy5kYXRhLmZyYW1lKFNCUl9oaWdoX0VYLkw0JEdyZWVuKSkgJT4lDQogIG5hLm9taXQoKSAlPiUgDQogIHBpdm90X2xvbmdlcigxOjMsbmFtZXNfdG8gPSAiYmFuZCIsIHZhbHVlc190byA9ICJ2YWx1ZSIpICU+JQ0KICBtdXRhdGUoc2V2PSJIaWdoIikNCg0KIy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0NCmFsbF9jb21iID0gYmluZF9yb3dzKFNCUl9sb3dfY29tYixTQlJfaGlnaF9jb21iKSAlPiUgDQogIG11dGF0ZShzZXYgPWZhY3RvcihzZXYsIGxldmVscyA9YygiTG93IiwiSGlnaCIpKSkNCiMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tDQoNCiMgYWxsX2NvbWIgJT4lIA0KIyAgIGdncGxvdChhZXModmFsdWUsc2V2KSkrDQojICAgc3RhdF9zbGFiKGFlcyhmaWxsID0gYmFuZCksIGFscGhhID0gMC43KSsNCiMgICAgc3RhdF9wb2ludGludGVydmFsKGFlcyhjb2xvciA9IGJhbmQpLA0KIyAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbl9kb2RnZSh3aWR0aCA9IC41LCBwcmVzZXJ2ZSA9ICJzaW5nbGUiKSwNCiMgICAgICAgICAgICAgICAgICAgICAgIyBjb2xvciA9ICJncmF5NDAiLA0KIyAgICAgICAgICAgICAgICAgICAgICAud2lkdGggPSBjKDAsMC45NSkpKw0KIyAgIA0KIyAgIHNjYWxlX2ZpbGxfbWFudWFsKHZhbHVlcyA9IGMoImJsdWUiLCAiZ3JlZW4iLCJyZWQiICkpKw0KIyAgIHNjYWxlX2NvbG9yX21hbnVhbCh2YWx1ZXMgPSBjKCJibHVlIiwgImdyZWVuIiwicmVkIiApKSsNCiMgICB0aGVtZV9taW5pbWFsKCkrDQojICAgeGxpbSgwLDI1NSkrDQojICAgdGhlbWUocGFuZWwuZ3JpZCA9IGVsZW1lbnRfYmxhbmsoKSwNCiMgICAgICAgICBwbG90LnRpdGxlID0gZWxlbWVudF90ZXh0KHNpemUgPSAxMCwgZmFjZSA9IGZhY2UpLA0KIyAgICAgICAgIGF4aXMudGlja3MgPSBlbGVtZW50X2xpbmUoY29sb3IgPSAiZ3JheSIpLA0KIyAgICAgICAgIGF4aXMubGluZSA9IGVsZW1lbnRfbGluZShjb2xvciA9ICJncmF5IikpKw0KIyAgIGxhYnMoeCA9ICJQaXhlbCBpbnRlbnNpdHkiLA0KIyAgICAgICAgeSA9ICJTZXZlcml0eSIsDQojICAgICAgICBmaWxsID0iIiwNCiMgICAgICAgIHRpdGxlID0gcGFzdGUodGl0bGUpKSsgIA0KIyAgIGd1aWRlcyhjb2xvciA9RikjKw0KICBTQlJfbG93fFNCUl9oaWdoDQogICNwbG90X2xheW91dCh3aWR0aHMgPSBjKDEsIC4yLC4yKSkNCn0NCmBgYA0KDQoNCiMjIyBwbG90cyANCmBgYHtyIG1lc3NhZ2U9RkFMU0UsIGluY2x1ZGU9RkFMU0V9DQpTQlJfZGlzdF9pbWcgPSBkZW5zaXR5X3JnYl9pbWFnZXMoKQ0KY2Fsb19kaXN0X2ltZyA9ZGVuc2l0eV9yZ2JfaW1hZ2VzKGZpbGVfbG93ID0iLi9waWNzLzAxLUNhbG9uZWN0cmlhX2xlYWZfYmxpZ3RoLzEwOC5qcGciLA0KICAgICAgICAgICAgICAgICAgICAgICAgZmlsZV9oaWdoID0gIi4vcGljcy8wMS1DYWxvbmVjdHJpYV9sZWFmX2JsaWd0aC8xNTMuanBnIiwNCiAgICAgICAgICAgICAgICAgICAgICAgIGxpbWlhciA9IDE3NSxpbmRleF9jdXQgPSAiQmx1ZSIsY3JvcEFib3ZlPVQsDQogICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSA9ICJDYWxvbmVjdHJpYSBsZWFmIGJsaWdodCIpDQoNCnh5X2Rpc3RfaW1nID0gZGVuc2l0eV9yZ2JfaW1hZ2VzKGZpbGVfbG93ID0iLi9waWNzLzAxLVh5bGVsbGEtdG9iYWNjby1iZy13aGl0ZS82OC5qcGciLA0KICAgICAgICAgICAgICAgICAgICAgICAgZmlsZV9oaWdoID0gIi4vcGljcy8wMS1YeWxlbGxhLXRvYmFjY28tYmctd2hpdGUvODIuanBnIiwNCiAgICAgICAgICAgICAgICAgICAgICAgIGxpbWlhciA9IDIwMCxpbmRleF9jdXQgPSAiQmx1ZSIsIGNyb3BBYm92ZT1ULA0KICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGUgPSAiTi4gdGFiYWN1bS1YLiBmYXN0aWRpb3NhIiwgZmFjZSA9ICJpdGFsaWMiKQ0KDQoNCndsYl9kaXN0X2ltZyA9IGRlbnNpdHlfcmdiX2ltYWdlcyhmaWxlX2xvdyA9Ii4vcGljcy8wMS1XaGVhdF9sZWFmX2JsYXN0L0dfMTA4X1IzLmpwZyIsDQogICAgICAgICAgICAgICAgICAgICAgICBmaWxlX2hpZ2ggPSAiLi9waWNzLzAxLVdoZWF0X2xlYWZfYmxhc3QvVF8yMzlfUjEuanBnIiwNCiAgICAgICAgICAgICAgICAgICAgICAgIGxpbWlhciA9IDE4MCxpbmRleF9jdXQgPSAiQmx1ZSIsY3JvcEFib3ZlPVQsDQogICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSA9ICJXaGVhdCBsZWFmIGJsYXN0IikNCg0KcGxiX2Rpc3RfaW1nID0gZGVuc2l0eV9yZ2JfaW1hZ2VzKGZpbGVfbG93ID0iLi9waWNzLzAxLXBvdGF0b19sYXRlX2JsaWdoL1BJMjRfNkIucG5nIiwNCiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVfaGlnaCA9ICIuL3BpY3MvMDEtcG90YXRvX2xhdGVfYmxpZ2gvUEkwN18yQS5wbmciLA0KICAgICAgICAgICAgICAgICAgICAgICAgbGltaWFyID0gMSxpbmRleF9jdXQgPSAiUmVkIixjcm9wQWJvdmU9RiwNCiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlID0gIlBvdGF0byBsYXRlIGJsaWdodCIpDQpgYGANCg0KDQoNCiMjIyMgY29tYm8NCg0KDQpgYGB7ciBmaWcuaGVpZ2h0PTcsIGZpZy53aWR0aD02fQ0KU0JSX2Rpc3RfaW1nL2NhbG9fZGlzdF9pbWcveHlfZGlzdF9pbWcvd2xiX2Rpc3RfaW1nL3BsYl9kaXN0X2ltZysNCiAgcGxvdF9sYXlvdXQobmNvbCA9IDEsDQogICAgICAgICAgICAgIG5yb3cgPTUpKw0KICBwbG90X2Fubm90YXRpb24odGFnX2xldmVscyA9ICJBIikmDQogIHRoZW1lKGxlZ2VuZC50ZXh0ID0gZWxlbWVudF90ZXh0KHNpemUgPTEwKSkNCmdnc2F2ZSgiZmlncy9SR0JfZGVuc19pbWcucG5nIixkcGkgPSA5MDAsIGhlaWdodCA9IDYsIHdpZHRoID0zKQ0KYGBgDQoNCiMjIFByaW5jaXBhbCBjb21wb25lbnQgYW5hbHlzaXMNCiMjIyBTQlINCmBgYHtyfQ0KcGNhX3NiciA9IFBDQShhbGxfZGF0YV9zcHJlYWRfc2JyWzI6MTVdLCBncmFwaCA9IEYpDQpiaXBsb3Rfc2JyID0gZnZpel9wY2FfYmlwbG90KHBjYV9zYnIsIGdlb20gPSAicG9pbnQiLA0KICAgICAgICAgICAgICAgIGdlb20udmFyID0gYygidGV4dCIsImFycm93IiksDQogICAgICAgICAgICAgICAgY29sLmluZCA9IGFsbF9kYXRhX3NwcmVhZF9zYnIkc2V2LCANCiAgICAgICAgICAgICAgICBjb2wudmFyID0gImJsYWNrIiwNCiAgICAgICAgICAgICAgICByZXBlbCA9IFQsDQogICAgICAgICAgICAgICAgbGFiZWxzaXplID0gMikrDQogIGxhYnModGl0bGUgPSAiU295YmVhbiBydXN0IikrDQogIHNjYWxlX2NvbG9yX2dyYWRpZW50KGxvdyA9ICJncmF5OTAiLCBoaWdoID0gImdyYXk0MCIsIG5hbWUgPSAiU2V2ZXJpdHkgKCUpIiwgbGltaXRzID1jKDAsMTAwKSkNCmBgYA0KDQojIyMgQ2Fsb25lY3RyaWENCmBgYHtyfQ0KcGNhX2NhbG8gPSBQQ0EoYWxsX2RhdGFfc3ByZWFkX2NhbG9bMjoxNV0sIGdyYXBoID0gRikNCmJpcGxvdF9jYWxvID0gZnZpel9wY2FfYmlwbG90KHBjYV9jYWxvLCBnZW9tID0gInBvaW50IiwNCiAgICAgICAgICAgICAgICBnZW9tLnZhciA9IGMoInRleHQiLCJhcnJvdyIpLA0KICAgICAgICAgICAgICAgIGNvbC5pbmQgPSBhbGxfZGF0YV9zcHJlYWRfY2FsbyRzZXYsIA0KICAgICAgICAgICAgICAgIGNvbC52YXIgPSAiYmxhY2siLA0KICAgICAgICAgICAgICAgIHJlcGVsID0gVCwNCiAgICAgICAgICAgICAgICBsYWJlbHNpemUgPSAyKSsNCiAgbGFicyh0aXRsZSA9ICJDYWxvbmVjdHJpYSBsZWFmIGJsaWdodCIpKw0KICBzY2FsZV9jb2xvcl9ncmFkaWVudChsb3cgPSAiZ3JheTkwIiwgaGlnaCA9ICJncmF5NDAiLCBuYW1lID0gIlNldmVyaXR5ICglKSIsIGxpbWl0cyA9YygwLDEwMCkpDQpgYGANCg0KIyMjIE50WGYNCmBgYHtyfQ0KcGNhX3h5ID0gUENBKGFsbF9kYXRhX3NwcmVhZF94eVsyOjE1XSwgZ3JhcGggPSBGKQ0KYmlwbG90X3h5ID0gZnZpel9wY2FfYmlwbG90KHBjYV94eSwgIGdlb20gPSAicG9pbnQiLA0KICAgICAgICAgICAgICAgIGdlb20udmFyID0gYygidGV4dCIsImFycm93IiksDQogICAgICAgICAgICAgICAgY29sLmluZCA9IGFsbF9kYXRhX3NwcmVhZF94eSRzZXYsIA0KICAgICAgICAgICAgICAgIGNvbC52YXIgPSAiYmxhY2siLA0KICAgICAgICAgICAgICAgIHJlcGVsID0gVCwNCiAgICAgICAgICAgICAgICBsYWJlbHNpemUgPSAyKSsNCiAgbGFicyh0aXRsZSA9IGV4cHJlc3Npb24oaXRhbGljKCJOLiB0YWJhY3VtLVguZmFzdGlkaW9zYSIpKSkrDQogIHNjYWxlX2NvbG9yX2dyYWRpZW50KGxvdyA9ICJncmF5OTAiLCBoaWdoID0gImdyYXk0MCIsIG5hbWUgPSAiU2V2ZXJpdHkgKCUpIiwgbGltaXRzID1jKDAsMTAwKSkNCmBgYA0KDQojIyMgV0xCDQoNCg0KYGBge3J9DQpwY2Ffd2xiID0gUENBKGFsbF9kYXRhX3NwcmVhZF93bGJbMjoxNV0sIGdyYXBoID0gRikNCg0KYmlwbG90X3dsYiA9IGZ2aXpfcGNhX2JpcGxvdChwY2Ffd2xiLCBnZW9tID0gInBvaW50IiwNCiAgICAgICAgICAgICAgICBnZW9tLnZhciA9IGMoInRleHQiLCJhcnJvdyIpLA0KICAgICAgICAgICAgICAgIGNvbC5pbmQgPSBhbGxfZGF0YV9zcHJlYWRfd2xiJHNldiwgDQogICAgICAgICAgICAgICAgY29sLnZhciA9ICJibGFjayIsDQogICAgICAgICAgICAgICAgcmVwZWwgPSBULA0KICAgICAgICAgICAgICAgIGxhYmVsc2l6ZSA9IDIpKw0KICBsYWJzKHRpdGxlID0gIldoZWF0IGxlYWYgYmxhc3QiKSsNCiAgc2NhbGVfY29sb3JfZ3JhZGllbnQobG93ID0gImdyYXk5MCIsIGhpZ2ggPSAiZ3JheTQwIiwgbmFtZSA9ICJTZXZlcml0eSAoJSkiLCBsaW1pdHMgPWMoMCwxMDApKQ0KYGBgDQoNCiMjI1BMQg0KDQpgYGB7cn0NCnBjYV9wbGIgPSBQQ0EoYWxsX2RhdGFfc3ByZWFkX3BsYlsyOjE1XSwgZ3JhcGggPSBGKQ0KYmlwbG90X3BsYiA9IGZ2aXpfcGNhX2JpcGxvdChwY2FfcGxiLCBnZW9tID0gInBvaW50IiwNCiAgICAgICAgICAgICAgICBnZW9tLnZhciA9IGMoInRleHQiLCJhcnJvdyIpLA0KICAgICAgICAgICAgICAgIGNvbC5pbmQgPSBhbGxfZGF0YV9zcHJlYWRfcGxiJHNldiwgDQogICAgICAgICAgICAgICAgY29sLnZhciA9ICJibGFjayIsDQogICAgICAgICAgICAgICAgcmVwZWwgPSBULA0KICAgICAgICAgICAgICAgIGxhYmVsc2l6ZSA9IDIpKw0KICBsYWJzKHRpdGxlID0gIlBvdGF0byBsYXRlIGJsaWdodCIpKw0KICBzY2FsZV9jb2xvcl9ncmFkaWVudChsb3cgPSAiZ3JheTkwIiwgaGlnaCA9ICJncmF5NDAiLCBuYW1lID0gIlNldmVyaXR5ICglKSIsIGxpbWl0cyA9YygwLDEwMCkpDQpgYGANCg0KIyMjDQpgYGB7ciBmaWcuaGVpZ2h0PTgsIGZpZy53aWR0aD02fQ0KYmlwbG90X3NicitiaXBsb3RfY2FsbytiaXBsb3RfeHkrYmlwbG90X3dsYitiaXBsb3RfcGxiK2d1aWRlX2FyZWEoKSsNCiAgcGxvdF9sYXlvdXQobmNvbCA9IDIsDQogICAgICAgICAgICAgIGd1aWRlcyA9ICJjb2xsZWN0IikrDQogIHBsb3RfYW5ub3RhdGlvbih0YWdfbGV2ZWxzID0gIkEiKSYNCiAgdGhlbWVfbWluaW1hbCgpKw0KICB0aGVtZSgjbGVnZW5kLnBvc2l0aW9uID0gIm5vbmUiLA0KICAgICAgICBheGlzLnRleHQgPSBlbGVtZW50X3RleHQoc2l6ZT04KSwNCiAgICAgICAgYXhpcy50aXRsZSA9IGVsZW1lbnRfdGV4dChzaXplPTgpLA0KICAgICAgICBwbG90LnRpdGxlID0gZWxlbWVudF90ZXh0KHNpemU9MTApLA0KICAgICAgICBwYW5lbC5ncmlkID0gZWxlbWVudF9ibGFuaygpLA0KICAgICAgICBheGlzLnRpY2tzID0gZWxlbWVudF9saW5lKGNvbG9yID0gImdyYXkiKSwNCiAgICAgICAgYXhpcy5saW5lID0gZWxlbWVudF9saW5lKGNvbG9yID0gImdyYXkiKSkNCg0KZ2dzYXZlKCJmaWdzL2JpcGxvdHMucG5nIixkcGkgPSA2MDAsIGhlaWdodCA9IDgsIHdpZHRoID02KQ0KYGBgDQoNCg==</div>


Copyright 2017 Emerson Del Ponte


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("main_code_RGB_index.Rmd");
});
</script>

<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = false;
    options.smoothScroll = false;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
